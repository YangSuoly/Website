<h1 id="introduction">1. Introduction</h1>
<h2 id="language-model">1.1 Language model</h2>
<ul>
<li><p>什么是语言模型？</p>
<p>语言模型是指衡量一句话（词组合）出现的概率或合理性，即判断一个人有多大概率会讲出一句话。</p>
<p><span class="math display">\[P(W) = P(w_1, w_2, \dots, w_n)\]</span></p>
<ul>
<li><p>次序</p>
<p><span class="math display">\[P(\text{厦大是一所好学校}) &gt; P(\text{厦大一是学好所校}) \]</span></p></li>
<li><p>选词</p>
<p><span class="math display">\[P(\text{厦大是一所好学校}) &gt; P(\text{厦大是一所好桌子})\]</span></p></li>
</ul></li>
<li><p>链式法则</p>
<p>训练语言模型时会遵循 <strong>链式法则</strong>，即：</p>
<p><span class="math display">\[
\begin{align*}
P(A, B) &amp;= P(A)P(B|A) \\
P(x_1, x_2, x_3, \dots, x_n) &amp;= P(x_1)P(x_2|x_1)P(x_3|x_1, x_2)\dots P(x_n|x_1,\dots,x_{n-1})
\end{align*}
\]</span></p>
<p>应用到语言模型中，有：</p>
<p><span class="math display">\[
\begin{array}{c}
\mathrm{P}(\mathrm{W})=\mathrm{P}\left(w_{1}, w_{2}, w_{3}, w_{4}, w_{5} \ldots w_{n}\right) \\
P\left(w_{1} w_{2} \ldots w_{n}\right)=\prod_\limits{i} P\left(w_{i} \mid w_{1} w_{2} \ldots w_{i-1}\right)
\end{array}
\]</span></p></li>
<li><p>Markov 假设</p>
<p>每个单词只跟它之前 <span class="math inline">\(n\)</span> 个单词有关。</p>
<ul>
<li><p><span class="math inline">\(n=1\)</span> :</p>
<p><span class="math display">\[P(\text {the | its water is so transparent that}) \approx P(\text {the | that})\]</span></p></li>
<li><p><span class="math inline">\(n=2\)</span> :</p>
<p><span class="math display">\[P(\text {the | its water is so transparent that}) \approx P(\text {the I transparent that})\]</span></p></li>
</ul></li>
<li><p>Evaluation of language model</p>
<ul>
<li>Perplexity</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
P P(W) &amp;=P\left(w_{1} w_{2} \ldots w_{N}\right)^{-\frac{1}{N}} \\
&amp;=\sqrt[N]{\frac{\cdots}{P\left(w_{1} w_{2} \ldots w_{N}\right)}} \\
&amp;=\sqrt[N]{\prod_{i=1}^{N} \frac{1}{P\left(w_{i} \mid w_{1} \ldots w_{i-1}\right)}}
\end{aligned}
\]</span></p></li>
</ul>
<h2 id="recurrent-neural-network">1.2 Recurrent Neural Network</h2>
<p>可以用循环神经网络训练语言模型，每一个单词都是前一个单词的训练时的输出结果。</p>
<center>
<img src = "assets/markdown-img-paste-20210805203740755.png" style = "zoom: 60%" />
</center>
<ul>
<li>每一步的参数 <span class="math inline">\(W\)</span> 是固定的</li>
<li>当前隐状态包含了所有前面出现的单词信息。</li>
</ul>
<p>Steps: 1. 给定一列词向量</p>
<p><span class="math display">\[x_1, \dots, x_{t-1}, x_t, x_{t+1}, \dots, x_T\]</span></p>
<ol start="2" type="1">
<li><code>RNN</code> 每一个步骤</li>
</ol>
<p><span class="math display">\[
  \begin{align*}
  h_t &amp;= \sigma\left(W^{(hh)} h_{t-1} + W^{(hx)} x_{[t]} \right) \\
  \hat{y_t} &amp;= \mathrm{softmax} \left(W^{(S)} h_t \right)
  \end{align*}
  \]</span></p>
<center>
<img src = "assets/markdown-img-paste-20210805204002978.png" style = "zoom: 60%" />
</center>
<ol start="3" type="1">
<li>Loss function (Cross Entropy)</li>
</ol>
<p><span class="math display">\[J^{(t)}(\theta)=-\sum_{j=1}^{|V|} y_{t, j} \log \hat{y}_{t, j}\]</span></p>
<ol start="4" type="1">
<li>梯度下降 (<code>SGD</code>, <code>Adam</code>, <code>RMSprop</code>)</li>
</ol>
<p><span class="math display">\[\begin{array}{l}
J=-\frac{1}{T} \sum_\limits{t=1}^{T} \sum_\limits{j=1}^{|V|} y_{t, j} \log \hat{y}_{t, j}\\
\text { Perplexity: } 2^{J}
\end{array}\]</span></p>
<p>然而，在实际训练 <code>RNN</code> 过程中，存在许多问题，如： - Gradient vanishing and explosion</p>
<center>
<img src="assets/markdown-img-paste-20210805205408128.png" style = "zoom:60%" />
</center>
<p>根据反向传播（链式法则），梯度会不断相乘，很容易导致梯度消失或梯度爆炸问题。</p>
<center>
<img src="assets/markdown-img-paste-20210805205710583.png" style = "zoom:60%" />
</center>
<p>其导数会不断叠加：</p>
<p><span class="math display">\[\frac{\partial E_{3}}{\partial W}=\sum_{k=0}^{3} \frac{\partial E_{3}}{\partial \hat{y}_{3}} \frac{\partial \hat{y}_{3}}{\partial s_{3}}\left(\prod_{j=k+1}^{3} \frac{\partial s_{j}}{\partial s_{j-1}}\right) \frac{\partial s_{k}}{\partial W}\]</span></p>
<ul>
<li><p>长期依赖问题</p>
<p>距离当前节点较远的信息不容易被 <code>RNN</code> 保留。但有时较远的信息仍然较为重要。如：</p>
<center>
<p><img src="assets/markdown-img-paste-20210805210443282.png" style = "zoom:40%" /></p>
</center></li>
</ul>
<h2 id="long-short-term-memory">1.3 Long Short-term Memory</h2>
<h3 id="comparison-between-rnn-and-lstm">1.3.1 Comparison between RNN and LSTM</h3>
<p>为了应对上述普通 <code>RNN</code> 存在的不足，学者 <a href="https://ieeexplore.ieee.org/abstract/document/6795963">Hochreiter and Schmidhuber (1997)</a> 提出了新的循环神经网络 <code>Long Short-term Memory</code>。</p>
<p><code>LSTM</code> 是 <code>RNN</code> 的一种，大体结构几乎一样，区别是： 1. 它的“记忆细胞”改造过； 2. 需要记忆的信息会一直传递，不该记忆的信息会被“遗忘门”截断。</p>
<ul>
<li><p><code>RNN</code> 记忆细胞</p>
<center>
<p><img src = "assets/markdown-img-paste-20210805211113956.png" style = "zoom: 60%" /></p>
</center></li>
<li><p><code>LSTM</code> 记忆细胞</p>
<center>
<p><img src = "assets/markdown-img-paste-2021080521113189.png" style = "zoom: 60%" /></p>
</center></li>
</ul>
<h3 id="implementation-steps-of-lstm">1.3.2 Implementation steps of LSTM</h3>
<ul>
<li><p><code>LSTM</code> 关键：“细胞状态”</p>
<ul>
<li>细胞状态类似于传送带。直接在整个链上运行，只有一些少量的线性交互。信息在上面流传保持不变会很容易。</li>
</ul>
<center>
<p><img src = "assets/markdown-img-paste-2021080521201929.png" style = "zoom: 30%" /></p>
</center>
<ul>
<li><p><code>LSTM</code> 如何控制“细胞状态”？</p>
<ul>
<li>通过“门”让信息选择性通过，来去除或者增加信息到细胞状态</li>
<li>包含一个 <code>Sigmoid</code> 神经网络从和一个 <code>pointwise</code> 乘法操作</li>
<li><code>Sigmoid</code> 层输出 <code>0</code> 到 <code>1</code> 之间的概率值，描述每个部分有多少量可以通过。<code>0</code> 表示“不允许任何信息通过”，<code>1</code> 表示“允许所有信息通过”。</li>
</ul>
<center>
<p><img src = "assets/markdown-img-paste-20210805212413491.png" style = "zoom: 60%" /></p>
</center></li>
</ul></li>
<li><p>Steps:</p>
<ol type="1">
<li><p>遗忘门：决定从“细胞状态”中丢弃什么信息</p>
<p>比如在完形填空中填“他”或者“她”的问题，细胞状态可能包含当前主语的类别，当我们看到新的代词，我们希望忘记旧的代词。</p>
<center>
<p><img src = "assets/markdown-img-paste-20210805212659884.png" style = "zoom: 60%" /></p>
</center>
<p>衰减系数计算公式：</p>
<p><span class="math display">\[f_t = \sigma \left( W_f \cdot \left[h_{t-1}, x_t \right] + b_f\right)\]</span></p>
<p>在 <span class="math inline">\(t-1\)</span> 时刻，网络输出的 <span class="math inline">\(h_{t-1}\)</span> 和这一步的网络输入 <span class="math inline">\(x_t\)</span> 结合起来，然后作用线性变换 <span class="math inline">\(W_f \cdot \left[h_{t-1}, x_t \right] + b_f\)</span>，最后再经过 <code>Sigmoid</code> 激活函数，将结果映射到 <code>0~1</code>作为记忆（细胞状态）的衰减系数，记作 <span class="math inline">\(f_t\)</span>。</p>
<p>可以看到网络具体要保留多少记忆是由前一刻的输出和这一时刻的输入共同决定的。</p></li>
<li><p>纳入新的信息到“细胞状态”</p>
<ul>
<li><code>Sigmoid</code> 层决定什么值需要更新</li>
<li><code>Tanh</code> 层创建一个新的候选值向量 <span class="math inline">\(\tilde{C}_t\)</span></li>
<li>上述 2 步为状态更新做准备</li>
</ul>
<center>
<p><img src = "assets/markdown-img-paste-20210805213845396.png" style = "zoom: 60%" /></p>
</center>
<p>该时刻学习的记忆的衰减系数和被记忆的信息计算公式：</p>
<p><span class="math display">\[
 \begin{align*}
 i_t &amp;= \sigma \left( W_i \cdot \left[h_{t-1}, x_t \right] + b_i\right) \\
 \tilde{C}_t &amp;= \tanh \left( W_C \cdot \left[ h_{t-1}, x_t\right] + b_C\right)
 \end{align*}
 \]</span></p>
<p>首先对该时刻学到的记忆应用一个衰减系数，这个系数应用跟上一步的方式相同，再使用线性变换，然后使用 <code>Sigmoid</code> 激活函数，将结果映射到 <code>0~1</code> 之间，这个结果作为当前学习到的记忆的衰减系数，基座 <span class="math inline">\(i_t\)</span>。当前学习到的记忆 <span class="math inline">\(\tilde{C}_t\)</span> 是通过变换 <span class="math inline">\(W_C \cdot \left[ h_{t-1}, x_t\right] + b_C\)</span> 和 <span class="math inline">\(\tanh\)</span> 激活函数得到的。</p></li>
<li><p>更新“细胞状态”</p>
<ul>
<li>更新 <span class="math inline">\(C_{t-1}\)</span> 为 <span class="math inline">\(C_t\)</span></li>
<li>把旧状态与 <span class="math inline">\(f_t\)</span> 相乘，丢弃掉我们确定需要的丢弃的信息</li>
<li>加上 <span class="math inline">\(i_t * C_t\)</span>。这就是新的候选值，根据我们决定更新每个状态的程度进行变化。</li>
</ul>
<center>
<p><img src = "assets/markdown-img-paste-20210806155335879.png" style = "zoom: 60%" /></p>
</center>
<p>更新的计算公式如下：</p>
<p><span class="math display">\[f_t = \sigma \left( W_f \cdot \left[h_{t-1}, x_t \right] + b_f\right)\]</span></p>
<p>将 <span class="math inline">\(t-1\)</span> 时刻的衰减系数 <span class="math inline">\(f_t\)</span> 乘以 <span class="math inline">\(t-1\)</span> 时刻的记忆 <span class="math inline">\(C_{t-1}\)</span>，加上该时刻 <span class="math inline">\(t\)</span> 下学到的记忆 <span class="math inline">\(\tilde{C}_t\)</span> 乘以它对应的衰减系数 <span class="math inline">\(i_t\)</span>，这样便得到了 <span class="math inline">\(t\)</span> 时刻下的记忆状态 <span class="math inline">\(C_t\)</span>。</p>
<ol start="4" type="1">
<li><p>输出门：基于“细胞状态”得到输出</p>
<ul>
<li>首先运行一个 <code>Sigmoid</code> 层来确定细胞状态的哪个部分将输出</li>
<li>接着用 <span class="math inline">\(\tanh\)</span> 来处理细胞状态（得到一个再 -1 到 1 之间的值），再将它和 <code>Sigmoid</code> 的输出相乘，输出我们确定输出的那部分</li>
<li>比如我们可能需要单复数信息来确定输出“她”还是“她们”</li>
</ul>
<center>
<p><img src = "assets/markdown-img-paste-20210806155928153.png" style = "zoom: 60%" /></p>
</center>
<p>当前时刻 <span class="math inline">\(t\)</span> 的网络输出 <span class="math inline">\(h_t\)</span> 取决于当前时刻 <span class="math inline">\(t\)</span> 的记忆状态 <span class="math inline">\(C_t\)</span> 和 <span class="math inline">\(t\)</span> 时刻的输入 <span class="math inline">\(x_t\)</span>、<span class="math inline">\(t-1\)</span> 时刻的输出 <span class="math inline">\(h_{t-1}\)</span>。具体计算公式如下：</p>
<p><span class="math display">\[
\begin{align*}
o_t &amp;= \sigma \left( W_o \cdot \left[h_{t-1}, x_t \right] + b_o\right) \\
h_t &amp;= o_t * \tanh(C_t)
\end{align*}
\]</span></p>
<p>首先使用类似于计算记忆衰减系数的方法计算得到输出们的系数 <span class="math inline">\(o_t\)</span>，这个系数决定输出的多少，最后网络的输出由 <span class="math inline">\(h_t = o_t \times \tanh (C_t)\)</span> 得到，这就是输出门如何控制网络输出的原理。</p></li>
</ol></li>
</ol></li>
</ul>
<h3 id="gated-recurrent-unit-gru">1.3.3 Gated Recurrent Unit (GRU)</h3>
<p><code>GRU</code> 模型由 <a href="https://arxiv.org/abs/1406.1078">Cho et al. (2014)</a> 等提出，<code>GRU</code> 和 <code>LSTM</code> 最大的不同在于：</p>
<ul>
<li><code>GRU</code> 将遗忘门和输入们合成了一个“更新门”</li>
<li>网络不再额外给出记忆状态 <span class="math inline">\(C_t\)</span>，而是将输出结果 <span class="math inline">\(h_t\)</span> 作为记忆状态不断向后循环传递，</li>
<li>网络的输入和输出都变得特别简单</li>
</ul>
<center>
<img src = "assets/markdown-img-paste-20210806161559379.png" style = "zoom: 60%" />
</center>
<p>具体计算公式如下：</p>
<p><span class="math display">\[
\begin{align*}
z_t &amp;= \sigma\left( W_z \cdot \left[ h_{t-1}, x_t \right]\right) \\
r_t &amp;= \sigma\left( W_r \cdot \left[ h_{t-1}, x_t \right]\right) \\
\tilde{h}_t &amp;= \tanh\left( W \cdot \left[ r_t * h_{t-1}, x_t \right]\right) \\
h_t &amp;= (1-z_t) * h_{t-1} + z_t * \tilde{h}_t
\end{align*}
\]</span></p>
<p>本质上，<code>GRU</code> 和 <code>LSTM</code> 是相同的，将上一时刻 <span class="math inline">\(t-1\)</span> 的输出和当前 <span class="math inline">\(t\)</span> 时刻的输入 <span class="math inline">\(x_t\)</span> 结合起来计算各种衰减系数，略微不同的是，线性变换没有使用偏置，由于记忆状态也是 <span class="math inline">\(h_{t-1}\)</span>，所以直接对它进行更新就可以了，最后输出网络的结果 <span class="math inline">\(h_t\)</span>，这个结果也是网络的记忆状态。</p>
<h1 id="text-classification">2. Text Classification</h1>
<center>
<img src = "assets/markdown-img-paste-20210807201312557.png" style = "zoom: 60%" />
</center>
