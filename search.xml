<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Conda channel setting</title>
    <url>/2020/11/23/Conda%20channel%20setting/</url>
    <content><![CDATA[<h1 id="show-channel">1 Show channel</h1>
<p><code>conda config --show</code>显示所有的 conda 的config 信息，<code>conda config --show channels</code>显示所有 channel 信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>conda config --show channels</span><br><span class="line">channels:</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/win-<span class="number">64</span>/</span><br><span class="line">  - defaults</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="delete-channel">2 Delete channel</h1>
<p>Using <code>conda config --remove channels</code> to delete channels from config</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br></pre></td></tr></table></figure>
<h1 id="add-channel">3 Add channel</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 channel 中安装包时显示channel 的url，这样就可以知道包的安装来源</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装确认中，不默认yes，而是由我来决定</span></span><br><span class="line">conda config --<span class="built_in">set</span> always_yes false</span><br></pre></td></tr></table></figure>
<h1 id="install-package-offline">4 Install package offline</h1>
<h3 id="conda-install">4.1 Conda install</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">conda install --offline &lt; package &gt;</span><br><span class="line"></span><br><span class="line">conda install &lt;包名&gt; <span class="comment">#安装指定包</span></span><br><span class="line">conda remove &lt;包名&gt; <span class="comment">#移除指定包</span></span><br><span class="line">conda update &lt;包名&gt; <span class="comment">#更新指定包</span></span><br></pre></td></tr></table></figure>
<h3 id="pip-install-.whl-package">4.2 pip install '.whl' package</h3>
<p>再命令行窗口用 <code>cd</code> 命令跳转到 <code>whl</code> 文件所在目录，然后使用命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install ***.whl</span><br></pre></td></tr></table></figure>
<h1 id="virtual-environment">5 Virtual environment</h1>
<h2 id="steps">5.1 Steps</h2>
<ul>
<li><p>Open <code>terminal</code> or <code>Command prompt</code></p></li>
<li><p>Input <code>D:</code> to enter drive D</p></li>
<li><p>Then input <code>cd project_dir</code></p></li>
<li><p>Create a virtual environment</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python -m venv &lt;venv name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="activate-venv">5.2 Activate venv</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">.\&lt;venv name&gt;\Scripts\activate <span class="comment"># activate venv</span></span><br><span class="line"></span><br><span class="line">.\venv\Scripts\deactivate <span class="comment"># exit the current venv</span></span><br></pre></td></tr></table></figure>
<h2 id="import-module">5.3 Import module</h2>
<ul>
<li><p>主程序和模块程序在同一目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`-- src</span><br><span class="line">    |-- mod1.py</span><br><span class="line">    `-- test.py</span><br></pre></td></tr></table></figure>
<p><code>test.py</code>导入模块 <code>mod1</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mod1</span><br><span class="line"><span class="keyword">from</span> mod1 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure></li>
<li><p>主程序所在目录是模块所在目录的父(或祖辈)目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`-- src</span><br><span class="line">    |-- mod1.py</span><br><span class="line">    |-- mod2</span><br><span class="line">    |   `-- mod2.py</span><br><span class="line">    `-- test1.py</span><br></pre></td></tr></table></figure>
<p><code>test1.py</code>中导入模块<code>mod2</code>，需要在<code>mod2</code>文件夹中创建<code>__init__.py</code>文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mod2.mod2 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> mod2.mod2</span><br></pre></td></tr></table></figure></li>
<li><p>主程序导入上层目录中模块或其他目录(平级)下的模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">`-- src</span><br><span class="line">    |-- mod1.py</span><br><span class="line">    |-- mod2</span><br><span class="line">    |   `-- mod2.py</span><br><span class="line">    |-- sub</span><br><span class="line">    |   `-- test2.py</span><br><span class="line">    `-- test1.py</span><br></pre></td></tr></table></figure>
<p><code>test2.py</code> 中导入模块 <code>mod1</code> 和 <code>mod2</code>，首先需要在 <code>mod2</code> 下建立 <code>__init__.py</code> 文件，<code>src</code> 下不必建立该文件:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> mod1</span><br><span class="line"><span class="keyword">import</span> mod2.mod2</span><br></pre></td></tr></table></figure></li>
</ul>
<p>从上面可以看出，导入模块关键是能够根据sys.path环境变量的值，找到具体模块的路径</p>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Eviews notes</title>
    <url>/2020/11/22/Eviews/</url>
    <content><![CDATA[<h1 id="create-workfile">1 Create workfile</h1>
<p>Eviews 10 创建时间序列工作文件，界面如下</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DUNDeA.png" /></p>
<center>
figure 1-1 时间序列类型
</center>
<p>参数释义为：</p>
<a id="more"></a>
<ul>
<li>Annual：年度数据</li>
<li>Semi-annual：半年(2010S1 - 2019S1)</li>
<li>Quarteryly：季度 （2010Q3 - 2019Q2）</li>
<li>Monthly：月度（2010M01 - 2019M11）</li>
<li>Bimonthly：半月（2010-3-01 - 2019-8-8）</li>
<li>Fortnightly：两周</li>
<li>Daily-custom week：用户自定义选择周几</li>
<li>Intraday：当日数据，精确到每天每隔多少时间</li>
<li>Integer data：可以是年度（eg：2001 - 2012），也可以是哪一期（eg：3 - 33）</li>
</ul>
<p>创建平衡面板数据：</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DUN0Ld.png" /></p>
<center>
figure 1-2 平衡面板数据
</center>
<h1 id="least-squares最小二乘法">2 Least Squares（最小二乘法）</h1>
<p>Command中输入 <code>ls y c x</code>即可得到如下结果：</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DUNrdI.md.png" /></p>
<center>
figure 1-3 Parameters
</center>
<p>Parameters:</p>
<ul>
<li>Coefficient：系数，参数估计值</li>
<li>Std. Error：参数估计量标准差估计值</li>
<li>t-Statistic：<span class="math inline">\(t\)</span> 统计量的值</li>
<li>Prob: <span class="math inline">\(P\)</span> 值</li>
<li>R-squared: $ R^2$</li>
<li>Adjusted R-squared: $^ - $</li>
<li>S.E. of regression: <span class="math inline">\(\sigma ^2\)</span></li>
<li>Sum squared resid: $ RSS$，残差平方和</li>
<li>Mean dependent var: <span class="math inline">\(\overset{-}{Y}\)</span>，被解释变量的均值</li>
<li>S.D. dependent var: 被解释变量的标准差</li>
</ul>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Software</category>
      </categories>
      <tags>
        <tag>Eviews</tag>
        <tag>Software</tag>
      </tags>
  </entry>
  <entry>
    <title>Git notes</title>
    <url>/2020/11/22/Git-notes/</url>
    <content><![CDATA[<h1 id="版本控制">1. 版本控制</h1>
<h2 id="版本控制迭代">1.1 版本控制（迭代）</h2>
<p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<ul>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>
</ul>
<a id="more"></a>
<h2 id="版本控制工具">1.2 版本控制工具</h2>
<h3 id="主流的版本控制器">1.2.1 主流的版本控制器：</h3>
<ul>
<li><strong>Git</strong></li>
<li><strong>SVN</strong>（Subversion）</li>
<li><strong>CVS</strong>（Concurrent Versions System）</li>
<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>
<li><strong>TFS</strong>（Team Foundation Server）</li>
<li>Visual Studio Online</li>
</ul>
<h3 id="版本控制分类">1.2.2 版本控制分类</h3>
<ul>
<li>本地版本控制：RCS</li>
</ul>
<blockquote>
<p><img src="https://s3.ax1x.com/2020/11/25/DauN11.png" /></p>
</blockquote>
<center>
图 1-1 本地版本控制
</center>
<ul>
<li>集中版本控制：SVN</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/25/Dauu60.png" /></p>
<center>
图 1-2 集中版本控制
</center>
<ul>
<li>分布式版本控制：Git</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/25/DauZfs.md.jpg" /></p>
<center>
图 1-3 分布式版本控制
</center>
<h3 id="git-与-svn-的区别">1.2.3 Git 与 SVN 的区别</h3>
<blockquote>
<ul>
<li><p>SVN是集中式版本控制系统，版本库集中放在中央服务器的，工作时，需要从中央服务器得到最新的版本，完成工作后，把做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p></li>
<li><p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库</p></li>
</ul>
</blockquote>
<h1 id="git-环境配置">2. Git 环境配置</h1>
<h2 id="git配置">2.1 Git配置</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git config -l</span><br><span class="line"><span class="comment"># 查看配置</span></span><br><span class="line"></span><br><span class="line">git config --system --<span class="built_in">list</span></span><br><span class="line"><span class="comment"># 系统配置</span></span><br><span class="line"></span><br><span class="line">git config --<span class="keyword">global</span> --<span class="built_in">list</span></span><br><span class="line"><span class="comment"># 查看当前用户 (global) 配置</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Git 相关的配置文件</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">D:\Program files\Git\Git\etc：</span><br><span class="line"><span class="comment"># Git 安装目录下的 gitconfig --system 系统级</span></span><br><span class="line"></span><br><span class="line">C:\Users\YangSu\.gitconfig</span><br><span class="line"><span class="comment">#  只适用于当前登录用户的配置  --global 全局</span></span><br><span class="line"></span><br><span class="line">git config --<span class="keyword">global</span> user.name <span class="string">&quot;YS&quot;</span> <span class="comment">#名称</span></span><br><span class="line">git config --<span class="keyword">global</span> user.email num@qq.com   <span class="comment"># 邮箱</span></span><br></pre></td></tr></table></figure>
<h1 id="git-基本理论">3. Git 基本理论</h1>
<h2 id="工作区域">3.1 工作区域</h2>
<blockquote>
<p>四个工作区域：</p>
<ul>
<li>工作目录 (Working Directory)</li>
<li>暂存区 (Stage / Index)</li>
<li>资源库 (Repository 或 Git Directory)</li>
<li>远程 Git 仓库 (Remote Directory)</li>
</ul>
</blockquote>
<p><img src="https://s3.ax1x.com/2020/11/25/Daunlq.png" /></p>
<center>
图 1-4 工作区域（核心）
</center>
<ul>
<li>Workspace：工作区，就是你平时存放项目代码的地方</li>
<li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p>
<p><img src="https://s3.ax1x.com/2020/11/25/Daumpn.png" /></p>
<center>
图 1-5 Git示意图
</center>
<ul>
<li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li>
<li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li>
<li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li>
<li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li>
<li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li>
<li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li>
</ul>
<h2 id="工作流程">3.2 工作流程</h2>
<ol type="1">
<li>在工作目录中添加、修改文件；</li>
<li>将需要进行版本管理的文件放入暂存区域；</li>
<li>将暂存区域的文件提交到git仓库。</li>
</ol>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DauKXV.jpg" /></p>
<center>
1-6 工作流程
</center>
<h1 id="项目搭建">4. 项目搭建</h1>
<h2 id="创建工作目录">4.1 创建工作目录</h2>
<p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DauQmT.png" /></p>
<center>
1-7 常用命令
</center>
<h2 id="创建本地仓库">4.2 创建本地仓库</h2>
<ul>
<li>创建全新的仓库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"><span class="comment"># 执行后，项目目录多出了一个.git目录</span></span><br></pre></td></tr></table></figure>
<ul>
<li>克隆远程仓库</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆一个项目和它的整个代码历史(版本信息)</span></span><br><span class="line">$ git clone [url]  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">从 gitee 或 github 中克隆</span></span><br><span class="line"><span class="string">https://gitee.com/kuangstudy/openclass.git</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="git-文件操作">5. Git 文件操作</h1>
<h2 id="文件的四种状态">5.1 文件的四种状态</h2>
<ul>
<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git 库, 不参与版本控制. 通过 git add 状态变为 Staged.</li>
<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为 Modified. 如果使用git rm移出版本库, 则成为 Untracked 文件</li>
<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 !</li>
<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<h2 id="查看文件状态">5.2 查看文件状态</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">touch hello.py</span><br><span class="line"></span><br><span class="line">git status hello.py <span class="comment"># 产看指定文件状态</span></span><br><span class="line">git status <span class="comment"># 查看所有文件状态</span></span><br><span class="line"></span><br><span class="line">git add hello.py <span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">git add . <span class="comment"># 添加所有文件到暂存区 (repository)</span></span><br><span class="line"></span><br><span class="line">git rm --cached hello.py <span class="comment"># 将文件从暂存区移除</span></span><br><span class="line">git restore -staged add.py <span class="comment"># 将文件从暂存区移除</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">&quot;a new file named hello.py&quot;</span> </span><br><span class="line"><span class="comment"># 提交暂存区内容至本地仓库</span></span><br><span class="line"></span><br><span class="line">git push -u origin master -f</span><br><span class="line"><span class="comment"># 第一次使用push的时候加上-u,以后可不加，-f强制上传</span></span><br></pre></td></tr></table></figure>
<h2 id="忽略文件">5.3 忽略文件</h2>
<p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立".gitignore"文件，此文件有如下规则：</p>
<ul>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,...}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果名称的最前面是一个路径分隔符（/），表示要忽略的文件在此目录下，而子目录中的文件不忽略。</li>
<li>如果名称的最后面是一个路径分隔符（/），表示要忽略的是此目录下该名称的子目录，而非文件（默认文件或目录都忽略）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为注释</span></span><br><span class="line">*.txt  <span class="comment"># 忽略.txt结尾的文件,上传时不会被选中！</span></span><br><span class="line">!lib.txt     <span class="comment"># 但lib.txt除外</span></span><br><span class="line">/temp        <span class="comment">#仅忽略项目根目录下的TODO文件,不包括其它目录temp</span></span><br><span class="line">build/       <span class="comment">#忽略build/目录下的所有文件</span></span><br><span class="line">doc/*.txt    <span class="comment">#忽略doc/notes.txt 但不包括 doc/server/arch.txt</span></span><br></pre></td></tr></table></figure>
<h1 id="使用码云">6. 使用码云</h1>
<blockquote>
<p>github 是有墙的，比较慢，国内一般用 gitee</p>
</blockquote>
<h2 id="设置免密码登录">6.1 设置免密码登录</h2>
<ol type="1">
<li><p>设置本机绑定SSH公钥，实现免密码登录！</p>
<p>免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 C:\Users\YangSu\.ssh 目录</span></span><br><span class="line"><span class="comment"># 生成公钥</span></span><br><span class="line">ssh-keygen -t rsa <span class="comment"># 加密算法</span></span><br></pre></td></tr></table></figure></li>
<li><p>将公钥信息public key 添加到码云账户中</p>
<p>密钥信息存储在 id_rsa.pub 文件中</p></li>
<li><p>使用 gitee 创建一个自己的仓库</p>
<p><strong>许可证：</strong>开源是否可以随意转载，开源但是不能商业使用，不能转载，... 限制！</p></li>
</ol>
<h2 id="添加远程库">7.2 添加远程库</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git remote add origin https://gitee.com/yangsuoly/GitStudy.git</span><br><span class="line"><span class="comment"># 添加远程库, HTTPS方式，ssh可以免密</span></span><br><span class="line"></span><br><span class="line">git remote -v <span class="comment"># 查看 clone 的地址</span></span><br><span class="line">git remote rm origin <span class="comment"># 移除远程库地址</span></span><br><span class="line">git remote add origin git@gitee.com:yangsuoly/GitStudy.git <span class="comment"># 添加远程库地址，SSH方式</span></span><br><span class="line"></span><br><span class="line">cat /c/Users/YangSu/.ssh/id_rsa.pub <span class="comment"># 查看公玥</span></span><br><span class="line">    </span><br><span class="line">git push -u origin master -f <span class="comment"># 首次使用</span></span><br><span class="line">git push <span class="comment"># 之后</span></span><br></pre></td></tr></table></figure>
<h1 id="git-分支">8. Git 分支</h1>
<h2 id="git-常用指令">8.1 Git 常用指令</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">git branch [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Group-Pictures</title>
    <url>/2020/12/02/Group-Pictures/</url>
    <content><![CDATA[<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://s3.ax1x.com/2020/11/30/DgWRZ6.png" /></div><div class="group-picture-column" style="width: 50%;"><img src="https://s3.ax1x.com/2020/11/30/DgWA8H.png" /></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 100%;"><img src="https://s3.ax1x.com/2020/11/30/DgWA8H.png" /></div></div><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="https://s3.ax1x.com/2020/11/30/DgWA8H.png" /></div><div class="group-picture-column" style="width: 50%;"><img src="https://s3.ax1x.com/2020/11/30/DgWA8H.png" /></div></div></div></div>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Pics</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux notes</title>
    <url>/2020/11/23/Linux/</url>
    <content><![CDATA[<h1 id="command">1. Command</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd / pwd / ls</span><br><span class="line">mkdir / rmdir</span><br><span class="line">cp / rm / mv</span><br><span class="line">tar / <span class="built_in">zip</span> / unzip</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="cd">1.1 cd</h2>
<p>即 current directory，切换目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd /home/YangSu/Desktop <span class="comment">#按TAB键可以自动补全</span></span><br><span class="line">cd ~/Desktop <span class="comment">#其中~特指用户的主目录</span></span><br><span class="line">cd.. <span class="comment"># 回到上一个目录</span></span><br><span class="line">cd <span class="comment">#回到用户目录位置</span></span><br></pre></td></tr></table></figure>
<h4 id="绝对路径">绝对路径</h4>
<p>/home/YangSu/Desktop</p>
<h4 id="相对路径">相对路径</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">. 当前目录</span><br><span class="line">.. 上级目录</span><br><span class="line">../Videos 上级目录下的Videos子目录</span><br></pre></td></tr></table></figure>
<h2 id="pwd">1.2 pwd</h2>
<p>即 print working directory 显示当前工作目录</p>
<h2 id="ls">1.3 ls</h2>
<p>即 list，列出文件和目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">ls ~/Desktop</span><br><span class="line">ls -l ~/Desktop <span class="comment">#其中，-l参数表示详细模式</span></span><br></pre></td></tr></table></figure>
<h2 id="mkdir">1.4 mkdir</h2>
<p>即 make directory，创建目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkdir abc</span><br><span class="line">mkdir -p abc/<span class="number">123</span>/test </span><br><span class="line"><span class="comment">#使用-p参数，可以将路径的层次目录全部创建</span></span><br></pre></td></tr></table></figure>
<h2 id="touch">1.5 touch</h2>
<p>新建一个文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">touch index.js</span><br><span class="line"><span class="comment"># 在当前目录下新建一个 index.js 文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># windows terminal中</span></span><br><span class="line">new-item index.js</span><br></pre></td></tr></table></figure>
<h2 id="rm">1.6 rm</h2>
<h3 id="rm-1">rm</h3>
<p>即 remove 删除文件或目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rm -rf abc <span class="comment">#删除abc目录，和子项一并删除</span></span><br><span class="line"><span class="comment">#其中，r:recursive, f:force</span></span><br></pre></td></tr></table></figure>
<h3 id="rmdir">rmdir</h3>
<p>即 remove directory，删除空目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rmdir abc <span class="comment">#删除空目录，如果目录非空，则会删除失败</span></span><br></pre></td></tr></table></figure>
<h2 id="cp">1.7 cp</h2>
<p>即 copy，复制文件或者目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cp -rf Test Test1</span><br></pre></td></tr></table></figure>
<h2 id="mv">1.8 mv</h2>
<p>即 move，移动文件或目录（重命名）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mv Test1 HelloWorld</span><br></pre></td></tr></table></figure>
<h2 id="tar">1.9 tar</h2>
<p>即 tape archive档案打包</p>
<h3 id="创建档案包">创建档案包</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tar -cvf example.tar example</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">c: create</span></span><br><span class="line"><span class="string">v: verbose，显示详情</span></span><br><span class="line"><span class="string">f: file</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 也可以多个目录打包</span></span><br><span class="line">tar -cvd xxx.tar file1 file2 file3</span><br></pre></td></tr></table></figure>
<h4 id="还原档案包">还原档案包</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tar -xvf example.tar</span><br><span class="line">tar -xvf example.tar -C outdir</span><br></pre></td></tr></table></figure>
<h4 id="归档并压缩">归档并压缩</h4>
<p>上述的tar格式并没有对文件进行压缩，体积较大</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 并档并压缩</span></span><br><span class="line">tar -czvf example.tar.gz example</span><br><span class="line"><span class="comment"># 解压缩</span></span><br><span class="line">tar -xzvf example.tar.gz -C outdir</span><br></pre></td></tr></table></figure>
<h2 id="man">1.10 man</h2>
<p>即 manual，手册</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">man tar</span><br></pre></td></tr></table></figure>
<h2 id="ln">1.11 ln</h2>
<p>软链接，即Windows中的 “ 快捷方式 ”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ln -s source link</span><br><span class="line"><span class="comment"># s: soft</span></span><br><span class="line">ls -l <span class="comment"># 查看软链接，显示为：test -&gt; Test/</span></span><br><span class="line">ls -l / <span class="comment">#详细列出根目录</span></span><br></pre></td></tr></table></figure>
<h2 id="other">1.12 other</h2>
<ul>
<li>reset：重新初始化终端，即清屏</li>
<li>clear：清屏</li>
<li>history：查看命令历史</li>
<li>help：帮助</li>
<li>exit：推出</li>
<li>#：表示注释</li>
</ul>
<h1 id="management">2 Management</h1>
<h2 id="switch-user">2.1 Switch user</h2>
<ul>
<li>su</li>
</ul>
<p>即 switch user，切换用户。用户管理需要以管理员身份执行，所以，要先切换账户到 <strong>root</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">su <span class="comment"># 默认为 root</span></span><br></pre></td></tr></table></figure>
<h2 id="user-operation">2.2 User operation</h2>
<ul>
<li>useradd</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">useradd username</span><br></pre></td></tr></table></figure>
<ul>
<li>passwd</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">passwd username</span><br></pre></td></tr></table></figure>
<ul>
<li>userdel</li>
</ul>
<p>即 user delete</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">userdel username</span><br></pre></td></tr></table></figure>
<h2 id="group-operation">2.3 Group operation</h2>
<ul>
<li>groupadd</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">groupadd boys <span class="comment"># 创建用户组</span></span><br></pre></td></tr></table></figure>
<ul>
<li>groupdel</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">groupdel boys <span class="comment"># 删除用户组</span></span><br></pre></td></tr></table></figure>
<ul>
<li>useradd</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">useradd -g boys ming <span class="comment"># -g表示添加用户，同时添加到boys中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>usermod</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">usermod -g boys YangSu <span class="comment"># 修改用户信息</span></span><br></pre></td></tr></table></figure>
<ul>
<li>cat</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cat /etc/group <span class="comment"># 查看用户组，每一行表示一个group的信息</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">输出为：名称 + ID</span></span><br><span class="line"><span class="string">YangSu:x:1000:</span></span><br><span class="line"><span class="string">boys:x:1001:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">cat /etc/passwd <span class="comment"># 查看用户列表，每一行表示一个user信息</span></span><br></pre></td></tr></table></figure>
<h2 id="file-permission">2.4 File permission</h2>
<ul>
<li>View Permission</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ls -l test.txt</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">-rw-------</span></span><br><span class="line"><span class="string">第一个字母，如果是文件夹，则为d，文件则为-</span></span><br><span class="line"><span class="string">后面九个字符分为三部分：自己 | 同组 | 别人</span></span><br><span class="line"><span class="string">rwx------ # 自己可读可写可执行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>chmod</li>
</ul>
<p>即 Change file mode，修改文件的访问权限</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chmod o+w test.txt</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">o: other</span></span><br><span class="line"><span class="string">a: all</span></span><br><span class="line"><span class="string">u: user # 省略怎默认修改自己和本组的权限</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+w: add write permission</span></span><br><span class="line"><span class="string">-w: delete write permission</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>chown</li>
</ul>
<p>即 Change owner，修改文件的属主，一般每个用户只操作自己用户目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">su</span><br><span class="line">mkdir /opt/source <span class="comment"># 在/opt目录下创建一个文件夹source</span></span><br><span class="line">chown -R YangSu /opt/source <span class="comment"># 将source目录分配给YangSu</span></span><br><span class="line">ls -ld /opt/source</span><br></pre></td></tr></table></figure>
<h2 id="script">2.5 Script</h2>
<ul>
<li>Shell 脚本： *.sh</li>
<li>Perl 脚本： *.pl</li>
<li>Python 脚本：*.py</li>
</ul>
<p>脚本程序本质上是一个文本文件，具有可执行权限</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Shell 脚本解释器：/<span class="built_in">bin</span>/sh</span><br><span class="line">Perl 脚本解释器：/<span class="built_in">bin</span>/perl</span><br><span class="line">Python 脚本解释器：/usr/<span class="built_in">bin</span>/python3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行一个脚本时，以下两种方式等效</span></span><br><span class="line">./hello.py</span><br><span class="line">/usr/<span class="built_in">bin</span>/python3 hello.py</span><br></pre></td></tr></table></figure>
<ul>
<li>Shell 脚本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑一个文本文件</span></span><br><span class="line"><span class="comment">#!/bin/sh # 申明解释器</span></span><br><span class="line">echo <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存为Hello.sh</span></span><br><span class="line"><span class="comment"># 添加可执行权限，必须要有x权限，才能够执行</span></span><br><span class="line">chmod +x Hello.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行程序</span></span><br><span class="line">./Hello.sh <span class="comment"># 执行程序时，必须加上路径</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">./表示当前路径</span></span><br><span class="line"><span class="string">/home/YangSu/Test/Hello.sh</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Perl 脚本</li>
<li>Py 脚本</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br></pre></td></tr></table></figure>
<h2 id="shell">2.6 Shell</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 定义变量，NAME=value</span></span><br><span class="line">JAVA_HOME=/opt/java #中间不能有空格</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用命令</span></span><br><span class="line">echo $&#123;JAVA_HOME&#125;/bin</span><br><span class="line">ls $&#123;JAVA_HOME&#125; #使用变量</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 逻辑控制</span></span><br><span class="line">if ... while ...</span><br></pre></td></tr></table></figure>
<h1 id="enviroment">3 Enviroment</h1>
<h2 id="enviromental-viriables">3.1 Enviromental Viriables</h2>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/opt/jdk1.8 # 定义临时的环境变量</span><br><span class="line">echo $JAVA_HOME # 显示环境变量</span><br><span class="line">printenv #查看所有环境变量</span><br></pre></td></tr></table></figure>
<p>使用环境变量：</p>
<ul>
<li>在当前命令行中使用</li>
<li>在 Shell 脚本中使用</li>
</ul>
<h2 id="user-viriables">3.2 User Viriables</h2>
<p>用户环境变量定义在：~/.bash_profile 中（注：在 Linux 下，以 . 开头的文件为 <strong>隐藏文件</strong> ）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -la # a 表示 all，显示所有文件</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用户环境变量，g 表示 GNU</span></span><br><span class="line">gedit ~/.bash_profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line">export JAVA_HOME=/opt/jdk1.8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注销当前用户，再次登陆时生效</span></span><br><span class="line">echo $&#123;JAVA_HOME&#125;</span><br></pre></td></tr></table></figure>
<h2 id="system-variables">3.3 System Variables</h2>
<p>系统环境变量定义在：/etc/profile 中，其中的环境变量对 <strong>所有用户</strong> 有效</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以 root 登录或执行</span></span><br><span class="line">gedit /etc/profile</span><br><span class="line"></span><br><span class="line">:&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">在 CentOS 中，一般不可以直接修改 /etc/profile，而是在 /etc/profile.d 创建一个自定义的脚本</span></span><br><span class="line">&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用 gedit 创建一个脚本</span></span><br><span class="line">gedit /etc/profile.d/myprofile.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 定义环境变量</span></span><br><span class="line">export TOMCAT=/opt/tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 注销并重新登录</span></span><br></pre></td></tr></table></figure>
<h2 id="path-variables">3.4 PATH Variables</h2>
<p>PATH，最常见的环境变量，用来描述可执行程序的搜索路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo $PATH </span><br><span class="line"><span class="meta">#</span><span class="bash"> OUTPUT:/home/YangSu/.<span class="built_in">local</span>/bin:/home/YangSu/bin:/home/YangSu/.<span class="built_in">local</span>/bin:/home/YangSu/bin:/home/YangSu/.<span class="built_in">local</span>/bin:/home/YangSu/bin:/usr/<span class="built_in">local</span>/bin:/usr/<span class="built_in">local</span>/sbin:/usr/bin:/usr/sbin</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多个路径之间用冒号分隔</span></span><br></pre></td></tr></table></figure>
<h2 id="network">3.5 Network</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ifconfig <span class="comment"># 检查IP地址，Windows 为ipconfig</span></span><br><span class="line">ping www.baidu.com <span class="comment"># 测试外网</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">虚拟机和宿主机时互相连通的</span></span><br><span class="line"><span class="string">虚拟机：192.168.11.128</span></span><br><span class="line"><span class="string">宿主机：192.168.11.1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="centos8-图形界面和命令行切换">4 CentOS8 图形界面和命令行切换</h1>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看目前默认的启动默认</span></span><br><span class="line">systemctl get-default</span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令行模式:multi-user.target</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 图形界面模式:graphical.target</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为图形界面模式</span></span><br><span class="line">systemctl set-default graphical.target</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置为命令行模式</span></span><br><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy</title>
    <url>/2020/11/29/Numpy/</url>
    <content><![CDATA[<h1 id="numpy-version">1 NumPy version</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(np.__version__) <span class="comment"># 查看 numpy 版本</span></span><br></pre></td></tr></table></figure>
<p>NumPy( Numerical Python) 是 Python 数值计算最重要的基础库，核心是 N 维数组对象 ndarray ( N-dimensional array )。</p>
<a id="more"></a>
<h1 id="create-ndarray">2 Create ndarray</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">array_1x6 = np.array([<span class="number">1.0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], dtype = np.float64) <span class="comment"># 用 list 创建 array，可以通过 dtype 参数指定元素的类型  </span></span><br><span class="line"></span><br><span class="line">print(array_1x6.dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># number of dimension</span></span><br><span class="line">print(<span class="string">&#x27;number of dim: &#x27;</span>,array_1x6.ndim)</span><br><span class="line">print(<span class="string">&#x27;shape: &#x27;</span>,array_1x6.shape)</span><br><span class="line">print(<span class="string">&#x27;size: &#x27;</span>,array_1x6.size) </span><br><span class="line"><span class="comment"># total number of elements </span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(array_1x6) <span class="comment"># 空格分隔元素</span></span><br><span class="line">[<span class="number">1.</span> <span class="number">2.</span> <span class="number">3.</span> <span class="number">4.</span> <span class="number">5.</span> <span class="number">6.</span>]</span><br></pre></td></tr></table></figure>
<h1 id="special-ndarray">4 Special ndarray</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br></pre></td></tr></table></figure>
<ul>
<li><p>零矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a1 = np.zeros((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 零矩阵</span></span><br></pre></td></tr></table></figure></li>
<li><p>1 矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a2 = np.ones((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 1 矩阵</span></span><br></pre></td></tr></table></figure></li>
<li><p>1空矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a3 = np.empty((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 未初始化的空矩阵</span></span><br></pre></td></tr></table></figure></li>
<li><p>对角矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a7 = np.identity(<span class="number">5</span>) <span class="comment"># 5x5 的对角矩阵</span></span><br><span class="line">a8 = np.mat(np.identity(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>线段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a5 = np.arange(<span class="number">12</span>)</span><br><span class="line">a6 = np.linspace(<span class="number">1</span>, <span class="number">10</span>, <span class="number">5</span>) <span class="comment"># 5 个元素的线段</span></span><br><span class="line">print(a6 &lt; <span class="number">5</span>) <span class="comment"># 返回布尔类型的矩阵</span></span><br></pre></td></tr></table></figure></li>
<li><p>对角矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a7 = np.identity(<span class="number">5</span>) <span class="comment"># 5x5 的对角矩阵</span></span><br><span class="line">a8 = np.mat(np.identity(<span class="number">5</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>随机矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.random.random((<span class="number">2</span>, <span class="number">4</span>)) <span class="comment"># 0-1的随机数</span></span><br><span class="line">print(np.<span class="built_in">sum</span>(a), np.<span class="built_in">min</span>(a), np.<span class="built_in">max</span>(a))</span><br><span class="line">np.<span class="built_in">sum</span>(a, axis = <span class="number">0</span>) <span class="comment"># 列操作，axis = 1行操作，the default, axis = None，will sum all of the elements of the input array</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="array-operations">4 Array operations</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([[<span class="number">10</span>, <span class="number">20</span>], [<span class="number">30</span>, <span class="number">40</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">print(a, b, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;-------------&#x27;</span>)</span><br><span class="line">c1 = a + b</span><br><span class="line">c2 = a * b <span class="comment"># 对应元素相乘</span></span><br><span class="line"></span><br><span class="line">c3 = np.dot(a, b) <span class="comment"># 矩阵相乘，点乘</span></span><br><span class="line">c4 = a.dot(b) <span class="comment"># 和上式相同，a 值不改变</span></span><br><span class="line">print(c1, c2, c3, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="array-basic-methods">5 Array basic methods</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># find elements</span></span><br><span class="line">A = np.arange(<span class="number">2</span>, <span class="number">14</span>).reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">index = np.argmax(A)  <span class="comment"># 最大值索引or argmin</span></span><br><span class="line">mean = np.mean(A) <span class="comment"># 均值</span></span><br><span class="line">median = np.median(A) <span class="comment"># 中位数</span></span><br><span class="line">print(index, mean, median, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">上述函数皆默认axis = None, the index is into the flattened array，若添加参数：axis = 1 则返回每一行的相关操作，axis = 0 则返回每一列的相关操作，具体参照: help(np.mean)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A：3x4 的数组</span></span><br><span class="line">cumsum = np.cumsum(A) </span><br><span class="line"><span class="comment"># 累加，axis默认为None，输出1x12数组</span></span><br><span class="line">diff = np.diff(A) </span><br><span class="line"><span class="comment"># 差分，默认axis=-1，即行操作与axis=1效果相同，返回3X3的数组，axis=0，返回2x4数组</span></span><br><span class="line"></span><br><span class="line">non = np.nonzero(A)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">查找非零元素的索引，返回两个array，第一个为行索引，第二个为列索引</span></span><br><span class="line"><span class="string">输出：</span></span><br><span class="line"><span class="string">(array([0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2], dtype=int64), array([0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3], dtype=int64))</span></span><br><span class="line"><span class="string"> &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵转置, transpose array</span></span><br><span class="line">transpose1 = np.transpose(A)</span><br><span class="line">transpose2 = A.T</span><br><span class="line">print(transpose1, transpose2, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">print(transpose1.dot(A)) <span class="comment"># $&#123;A * A^T&#125;$ </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clip</span></span><br><span class="line">a = np.arange(<span class="number">2</span>, <span class="number">14</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">clip = np.clip(a, <span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">print(a, clip, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Given an interval [5, 9], values outside this interval are clipped to this interval edges, namely 5 and 9</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 行迭代输出</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> a:</span><br><span class="line">    print(row)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 列迭代输出    </span></span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> a.T:</span><br><span class="line">    print(column.T)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 元素迭代, flat返回迭代器，flatten()返回array</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> a.flat: <span class="comment"># or a.flatten()</span></span><br><span class="line">    print(item)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="array-joint">6 Array joint</h1>
<h2 id="vstack-and-hstack">6.1 vstack and hstack</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">c = np.vstack((a, b)) <span class="comment">#vertical stack 纵向</span></span><br><span class="line">d = np.hstack((a, b)) <span class="comment"># horizontal stack 横</span></span><br><span class="line">print(a.shape, c.shape) <span class="comment"># a 的shape为序列</span></span><br><span class="line">print(c, d, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(a.T.shape) <span class="comment"># 并未改变shape，0x3维</span></span><br><span class="line">a1 = a[:, np.newaxis] <span class="comment"># 在后面加维度，3x1维</span></span><br><span class="line">a2 = a[np.newaxis, :] <span class="comment"># add before, 1x3</span></span><br><span class="line">c= np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],[<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]]) <span class="comment"># 2x3</span></span><br><span class="line">c1 = c[np.newaxis, :] <span class="comment"># add before 1x2x3</span></span><br><span class="line">c2 = c[:, np.newaxis] <span class="comment"># same as c3</span></span><br><span class="line">c3 = c[:, np.newaxis, :] <span class="comment"># 2x1x3</span></span><br><span class="line">c4 = c[:, :, np.newaxis] <span class="comment"># 2x3x1</span></span><br></pre></td></tr></table></figure>
<h2 id="concatenate">6.2 concatenate</h2>
<p>Join a sequence of arrays along a existing axis, default axis is o, if axis = None, arrays will be flattened before use.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])[:, np.newaxis]</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>])[:, np.newaxis]</span><br><span class="line"></span><br><span class="line">c1 = np.concatenate((a,b,b,a)) <span class="comment"># same as c2</span></span><br><span class="line">c2 = np.concatenate((a,b,b,a), axis = <span class="number">0</span>)</span><br><span class="line">c3 = np.concatenate((a,b,b,a), axis = <span class="number">1</span>)</span><br><span class="line">c4 = np.concatenate((a,b,b,a), axis = <span class="literal">None</span>)</span><br><span class="line">print(c1, c2, c3, c4, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="array-split">7 Array split</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">2</span>, <span class="number">14</span>).reshape(<span class="number">3</span>, <span class="number">4</span>) <span class="comment"># 3x4</span></span><br><span class="line">print(a)</span><br><span class="line">print(np.split(a, <span class="number">3</span>, axis = <span class="number">0</span>)) <span class="comment"># vertical</span></span><br><span class="line">print(np.split(a, <span class="number">2</span>, axis = <span class="number">1</span>)) <span class="comment">#horizontal</span></span><br><span class="line"><span class="comment"># 只能进行相等的分割</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>np.split(ary, indices_or sections, axis = 0)</strong></li>
</ul>
<p>Array to be divided into multiple sub-arrays along the given 'axis ', if such split is not possible, then an error will be rasied.</p>
<h1 id="array-copy">8 Array copy</h1>
<ul>
<li><strong>Copy and deep copy</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">b = a <span class="comment"># shallow copy</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">print(a, b)</span><br><span class="line">b1 = a.copy() <span class="comment"># deep copy</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">20</span></span><br><span class="line">print(a, b1)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Python module</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Data analysis</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF_test</title>
    <url>/2020/12/01/PDF-test/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;% pdf https://yangsuoly.com/file/Latex-Notes.pdf %&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas</title>
    <url>/2020/11/27/Pandas/</url>
    <content><![CDATA[<h1 id="series">1 Series</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">t = pd.Timestamp(<span class="string">&#x27;20180901&#x27;</span>) <span class="comment"># time type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># np.nan means NaN</span></span><br><span class="line">s = pd.Series([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, np.nan, <span class="number">44</span>, <span class="number">1</span>])</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dates = pd.date_range(<span class="string">&#x27;20200101&#x27;</span>, periods = <span class="number">6</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dates</span><br><span class="line">DatetimeIndex([<span class="string">&#x27;2020-01-01&#x27;</span>, <span class="string">&#x27;2020-01-02&#x27;</span>, <span class="string">&#x27;2020-01-03&#x27;</span>, <span class="string">&#x27;2020-01-04&#x27;</span>,<span class="string">&#x27;2020-01-05&#x27;</span>, <span class="string">&#x27;2020-01-06&#x27;</span>],dtype=<span class="string">&#x27;datetime64[ns]&#x27;</span>, freq=<span class="string">&#x27;D&#x27;</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li><strong>DataFrame</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># create a dataframe based on imported array</span></span><br><span class="line">df0 = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>), index = dates, columns = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df1 = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># create a dataframe based on dict</span></span><br><span class="line">df3 = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1.</span>, <span class="string">&#x27;B&#x27;</span>:pd.Timestamp(<span class="string">&#x27;20160901&#x27;</span>), <span class="string">&#x27;C&#x27;</span>:pd.Series(<span class="number">1</span>,index=<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">4</span>)),dtype=<span class="string">&#x27;float32&#x27;</span>), <span class="string">&#x27;D&#x27;</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>, dtype =<span class="string">&#x27;int32&#x27;</span>),<span class="string">&#x27;E&#x27;</span>:pd.Categorical([<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>]),<span class="string">&#x27;F&#x27;</span>:<span class="string">&#x27;foo&#x27;</span>&#125;)</span><br><span class="line">print(df0, df1, df3, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df3.dtypes <span class="comment"># dimensional type</span></span><br><span class="line">df3.index <span class="comment"># row index name</span></span><br><span class="line">df3.columns <span class="comment"># column name</span></span><br><span class="line">df3.describe() <span class="comment"># describe numerical characteristics, including count, mean, std, min etc.</span></span><br><span class="line">df3.T </span><br><span class="line">df3.transpose() <span class="comment"># transpose array</span></span><br><span class="line">df3.sort_index(axis = <span class="number">1</span>, ascending = <span class="literal">False</span>)</span><br><span class="line"><span class="comment"># horizontal descending sort</span></span><br></pre></td></tr></table></figure>
<h1 id="choose-data">2 Choose data</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1.</span>, <span class="string">&#x27;B&#x27;</span>:pd.Timestamp(<span class="string">&#x27;20160901&#x27;</span>), <span class="string">&#x27;C&#x27;</span>:pd.Series(<span class="number">1</span>,index=<span class="built_in">list</span>(arange(<span class="number">4</span>)),dtype=<span class="string">&#x27;float32&#x27;</span>), <span class="string">&#x27;D&#x27;</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>, dtype =<span class="string">&#x27;int32&#x27;</span>),<span class="string">&#x27;E&#x27;</span>:pd.Categorical([<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>]),<span class="string">&#x27;F&#x27;</span>:<span class="string">&#x27;foo&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">df1 = df.A <span class="comment"># same sa df.[&#x27;A&#x27;]</span></span><br><span class="line">df2 = df[<span class="number">0</span>:<span class="number">3</span>] <span class="comment"># row operation, 0-3 row</span></span><br><span class="line">df2_1 = df[<span class="number">0</span>:<span class="number">1</span>] <span class="comment"># single row</span></span><br><span class="line">df2_2 = df[<span class="string">&#x27;A&#x27;</span>] <span class="comment"># single column</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># select by label based index: loc</span></span><br><span class="line">df3 = df.loc[<span class="number">1</span>] <span class="comment"># the second row</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># selct by postitional index: iloc</span></span><br><span class="line">df4 = df.iloc[:,<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># 1-3 column</span></span><br><span class="line"><span class="comment"># mixed selection: ix</span></span><br><span class="line">df5 = df.ix[:<span class="number">2</span>,[<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>]] <span class="comment"># deprecated</span></span><br><span class="line"></span><br><span class="line">df6 = df[df[<span class="string">&#x27;A&#x27;</span>] &gt; <span class="number">4</span>]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">df[&#x27;A&#x27;] &gt; 4 return the row index which number is bigger than 4, let me name this index as iRow, then df[iRow] return the row date that meets above filter condition</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="set-value">3 Set Value</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1.</span>, <span class="string">&#x27;B&#x27;</span>:pd.Timestamp(<span class="string">&#x27;20160901&#x27;</span>), <span class="string">&#x27;C&#x27;</span>:pd.Series(<span class="number">1</span>,index=<span class="built_in">list</span>(arange(<span class="number">4</span>)),dtype=<span class="string">&#x27;float32&#x27;</span>), <span class="string">&#x27;D&#x27;</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>, dtype =<span class="string">&#x27;int32&#x27;</span>),<span class="string">&#x27;E&#x27;</span>:pd.Categorical([<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>]),<span class="string">&#x27;F&#x27;</span>:<span class="string">&#x27;foo&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">df.iloc[<span class="number">2</span>, <span class="number">2</span>] = <span class="number">111</span></span><br><span class="line">df.loc[<span class="number">0</span>,<span class="string">&#x27;B&#x27;</span>] = pd.Timestamp(<span class="string">&#x27;20180901&#x27;</span>)</span><br><span class="line"><span class="comment"># Note: below command will create a new column named (0, &#x27;B&#x27;) which values are given</span></span><br><span class="line">df[<span class="number">0</span>,<span class="string">&#x27;B&#x27;</span>] = pd.Timestamp(<span class="string">&#x27;20180901&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="process-default-value">4 Process default value</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>:<span class="number">1.</span>, <span class="string">&#x27;B&#x27;</span>:pd.Timestamp(<span class="string">&#x27;20160901&#x27;</span>), <span class="string">&#x27;C&#x27;</span>:pd.Series(<span class="number">1</span>,index=<span class="built_in">list</span>(arange(<span class="number">4</span>)),dtype=<span class="string">&#x27;float32&#x27;</span>), <span class="string">&#x27;D&#x27;</span>:np.array([<span class="number">3</span>]*<span class="number">4</span>, dtype =<span class="string">&#x27;int32&#x27;</span>),<span class="string">&#x27;E&#x27;</span>:pd.Categorical([<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>,<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;train&#x27;</span>]),<span class="string">&#x27;F&#x27;</span>:<span class="string">&#x27;foo&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># let (0,2) become default value</span></span><br><span class="line">df.iloc[<span class="number">2</span>, <span class="number">2</span>] = <span class="number">111</span></span><br><span class="line">df.loc[<span class="number">0</span>,<span class="string">&#x27;C&#x27;</span>] = np.nan </span><br><span class="line"></span><br><span class="line"><span class="comment"># Drop NaN</span></span><br><span class="line">df.dropna(axis =<span class="number">0</span>, how = <span class="string">&#x27;any&#x27;</span>) </span><br><span class="line"><span class="comment"># how = [&#x27;any, &#x27;all&#x27;], default is any</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill NaN, can&#x27;t do it with df.fillna(0)</span></span><br><span class="line">df[<span class="string">&#x27;C&#x27;</span>] = df[<span class="string">&#x27;C&#x27;</span>].fillna(<span class="number">0</span>)</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment"># maybe below command also can work?</span></span><br><span class="line">df_1 = df.fillna(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">df.isnull() <span class="comment"># find which position is null, return a dataframe same size as df</span></span><br><span class="line">np.<span class="built_in">any</span>(df.isnull()) == <span class="literal">True</span> </span><br></pre></td></tr></table></figure>
<h1 id="read-and-save-file">5 Read and save file</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;xx.csv&#x27;</span>) <span class="comment"># read</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;xxx.csv&#x27;</span>) <span class="comment"># save file</span></span><br></pre></td></tr></table></figure>
<h1 id="merge-dataframes">6 Merge dataframes</h1>
<h2 id="concatenation">6.1 Concatenation</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1 array multiply o is o</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>, <span class="number">4</span>)) * <span class="number">0</span>, columns = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>, <span class="number">4</span>)) * <span class="number">1</span>, columns = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>, <span class="number">4</span>)) * <span class="number">2</span>, columns = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>])</span><br><span class="line">res = pd.concat([df1, df2, df3], axis = <span class="number">0</span>, ignore_index = <span class="literal">True</span>) <span class="comment"># default don&#x27;t ignore index, the difference seen in below pic</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s3.ax1x.com/2020/11/25/DamaCR.png" /></p>
<center>
fig. 1 differenc of ignoring index
</center>
<ul>
<li><strong>join = ['inner', 'outer']</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>, <span class="number">4</span>)) * <span class="number">0</span>, columns = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>], index = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>, <span class="number">4</span>)) * <span class="number">1</span>, columns = [<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], index = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># default join is outer, fill the null space with NaN</span></span><br><span class="line">df3 = pd.concat([df1, df2], axis = <span class="number">0</span>, join = <span class="string">&#x27;outer&#x27;</span>, sort=<span class="literal">False</span>, ignore_index = <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># inner will take the intersection index of two arrays</span></span><br><span class="line">df4 = pd.concat([df1, df2], axis = <span class="number">0</span>, join = <span class="string">&#x27;inner&#x27;</span>, sort=<span class="literal">False</span>, ignore_index = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 df2 合并到 df1，并基于 index 去掉 df2 中有而 df1 没有的数据， 并填充 NaN</span></span><br><span class="line">df5 = pd.concat([df1, df2], axis = <span class="number">1</span>, join_axes = [df1.index])</span><br></pre></td></tr></table></figure>
<h2 id="append">6.2 append</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df1 &#x3D; pd.DataFrame(np.ones((3, 4)) * 0, columns &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span><br><span class="line">df2 &#x3D; pd.DataFrame(np.ones((3, 4)) * 1, columns &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span><br><span class="line">df3 &#x3D; pd.DataFrame(np.ones((3, 4)) * 1, columns &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span><br><span class="line"> </span><br><span class="line">res &#x3D; df1.append([df2, df3], ignore_index &#x3D; True)</span><br><span class="line"></span><br><span class="line"># add a row series into a df</span><br><span class="line">s1 &#x3D; pd.Series([1, 2, 3, 4], index &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;])</span><br><span class="line">res1 &#x3D; df1.append(s1, ignore_index &#x3D; True)</span><br></pre></td></tr></table></figure>
<h2 id="merge">6.3 merge</h2>
<ul>
<li>merged by single key</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>, <span class="string">&#x27;K3&#x27;</span>],<span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],<span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>, <span class="string">&#x27;K3&#x27;</span>],<span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],<span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge two dfs based on the same key value</span></span><br><span class="line">res = pd.merge(left, right, on = <span class="string">&#x27;key&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>merged by multiple keys</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],<span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>],<span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, 		<span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],<span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;key1&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>],<span class="string">&#x27;key2&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K0&#x27;</span>],<span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, 		<span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],<span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge two dfs based the same key value, default how = inner</span></span><br><span class="line">res1 = pd.merge(left, right, on = [<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>])</span><br><span class="line">res2 = pd.merge(left, right, on = [<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>], how = <span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">res2 = pd.merge(left, right, on = [<span class="string">&#x27;key1&#x27;</span>,<span class="string">&#x27;key2&#x27;</span>], indicator = <span class="literal">True</span>) </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">how = [&#x27;inner, &#x27;outer&#x27;,&#x27;left&#x27;,&#x27;right&#x27;]</span></span><br><span class="line"><span class="string">if how = &#x27;right&#x27;, this operation will fill left void space with NaN when left haven&#x27;t same key value with right, then merge into right</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">default indicator is False, this parameter will create a new column named _merge(indicator = &#x27;indicator_column&#x27;, then the new column&#x27;s name is indicator_column), which show if both arrays have a meanful value. </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>merged by index</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">&#x27;A&#x27;</span>: [<span class="string">&#x27;A0&#x27;</span>, <span class="string">&#x27;A1&#x27;</span>, <span class="string">&#x27;A2&#x27;</span>, <span class="string">&#x27;A3&#x27;</span>],<span class="string">&#x27;B&#x27;</span>: [<span class="string">&#x27;B0&#x27;</span>, <span class="string">&#x27;B1&#x27;</span>, <span class="string">&#x27;B2&#x27;</span>, <span class="string">&#x27;B3&#x27;</span>]&#125;, index = [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>,<span class="string">&#x27;K4&#x27;</span>])</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">&#x27;C&#x27;</span>: [<span class="string">&#x27;C0&#x27;</span>, <span class="string">&#x27;C1&#x27;</span>, <span class="string">&#x27;C2&#x27;</span>, <span class="string">&#x27;C3&#x27;</span>],<span class="string">&#x27;D&#x27;</span>: [<span class="string">&#x27;D0&#x27;</span>, <span class="string">&#x27;D1&#x27;</span>, <span class="string">&#x27;D2&#x27;</span>, <span class="string">&#x27;D3&#x27;</span>]&#125;, index = [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K3&#x27;</span>,<span class="string">&#x27;K5&#x27;</span>])</span><br><span class="line">print(left, right, sep = <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># left_index and right_index</span></span><br><span class="line">res1 = pd.merge(left, right, left_index = <span class="literal">True</span>, right_index = <span class="literal">True</span>, how = <span class="string">&#x27;inner&#x27;</span>) <span class="comment"># based on left_index = right_index</span></span><br><span class="line">res2 = pd.merge(left, right, left_index = <span class="literal">True</span>, right_index = <span class="literal">True</span>, how = <span class="string">&#x27;outer&#x27;</span>) <span class="comment"># fill the blank with NaN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>suffixes para</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">boys = pd.DataFrame(&#123;<span class="string">&#x27;K&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>,<span class="string">&#x27;K4&#x27;</span>],<span class="string">&#x27;age&#x27;</span>: [<span class="number">11</span>, <span class="number">23</span>, <span class="number">32</span>, <span class="number">12</span>]&#125;)</span><br><span class="line">girls = pd.DataFrame(&#123;<span class="string">&#x27;K&#x27;</span>: [<span class="string">&#x27;K0&#x27;</span>, <span class="string">&#x27;K1&#x27;</span>, <span class="string">&#x27;K2&#x27;</span>,<span class="string">&#x27;K4&#x27;</span>],<span class="string">&#x27;age&#x27;</span>: [<span class="number">14</span>, <span class="number">43</span>, <span class="number">12</span>, <span class="number">22</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># suffixex means the named methods of same positional column</span></span><br><span class="line">res = pd.merge(boys, girls, on = <span class="string">&#x27;K&#x27;</span>, suffixes = [<span class="string">&#x27;_boys&#x27;</span>, <span class="string">&#x27;_girls&#x27;</span>], how = <span class="string">&#x27;inner&#x27;</span>)</span><br><span class="line">print(res) <span class="comment">#  age_boys  age_girls</span></span><br></pre></td></tr></table></figure>
<h1 id="matplotlib">7 matplotlib</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data1 = pd.Series(np.random.randn(<span class="number">1000</span>), index = np.arange(<span class="number">1000</span>))</span><br><span class="line">data2 = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>), index = np.arange(<span class="number">1000</span>), columns = <span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line"><span class="comment"># print(data1, data2, sep = &#x27;\n&#x27;)</span></span><br><span class="line">data1 = data1.cumsum()</span><br><span class="line">data2 = data2.cumsum()</span><br><span class="line"><span class="comment"># print(data)</span></span><br><span class="line">data1.plot()</span><br><span class="line">data2.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li><p>plot methods</p>
<p>bar, hist, box, kde, area, scatter, hexbin, pie</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>), index = np.arange(<span class="number">1000</span>), columns = <span class="built_in">list</span>(<span class="string">&#x27;ABCD&#x27;</span>))</span><br><span class="line"></span><br><span class="line">data = data.cumsum()</span><br><span class="line"></span><br><span class="line">ax = data.plot.scatter(x = <span class="string">&#x27;A&#x27;</span>, y = <span class="string">&#x27;B&#x27;</span>,color = <span class="string">&#x27;DarkBlue&#x27;</span>, label = <span class="string">&#x27;Class1&#x27;</span>)</span><br><span class="line">data.plot.scatter(x = <span class="string">&#x27;A&#x27;</span>, y = <span class="string">&#x27;C&#x27;</span>,color = <span class="string">&#x27;DarkGreen&#x27;</span>,label = <span class="string">&#x27;Class2&#x27;</span>,ax = ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/11/25/Damd81.png" /></p>
<center>
fig. 2 scatter figure
</center>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Python module</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Data analysis</tag>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Scikit-learn</title>
    <url>/2020/11/22/Scikit-learn/</url>
    <content><![CDATA[<h1 id="installing-scikit-learn">1 Installing scikit-learn</h1>
<ul>
<li><p>Windows</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -U scikit-learn</span><br></pre></td></tr></table></figure></li>
<li><p>macOS</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install -U scikit-learn</span><br></pre></td></tr></table></figure></li>
<li><p>Linux</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install -U scikit-learn</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Check installation:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip show scikit-learn</span><br></pre></td></tr></table></figure>
<p>See more about scikit-learn via clicking <a href="https://scikit-learn.org/stable/index.html#">here</a>.</p>
<a id="more"></a>
<h1 id="general-study-mode">2 General study mode</h1>
<p>Steps:</p>
<ol type="1">
<li>Load datas</li>
<li>Split datas into two part: train and test part</li>
<li>Training model</li>
<li>Testing and evaluating model</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># instance for iris</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np </span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">iris_x = iris.data <span class="comment"># features</span></span><br><span class="line">iris_y = iris.target <span class="comment"># types</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(iris_X[:2, :])</span></span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(iris_x, iris_y, test_size = <span class="number">0.3</span>) <span class="comment"># split original data into train and test part</span></span><br><span class="line"><span class="comment"># the percentage of test sets is 30%</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(y_train) # 会打乱原始数据</span></span><br><span class="line">knn = KNeighborsClassifier() <span class="comment"># Classifier</span></span><br><span class="line">knn.fit(x_train, y_train) <span class="comment"># Train</span></span><br><span class="line">print(knn.predict(x_test)) <span class="comment"># Use trained model to predict</span></span><br><span class="line">print(y_test)</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">2</span> <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h1 id="sklearn.datasets">3 Sklearn.datasets</h1>
<h2 id="generate-regressiong-datas">3.1 Generate regressiong datas</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># instance for making datasets</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">X, y = datasets.make_regression(n_samples = <span class="number">100</span>, </span><br><span class="line">                n_features = <span class="number">1</span>, n_targets = <span class="number">1</span>, noise = <span class="number">2</span>)</span><br><span class="line"><span class="comment"># X, y = datasets.make_regression(n_samples = 100, </span></span><br><span class="line"><span class="comment">#                 n_features = 1, n_targets = 1, noise = 10)</span></span><br><span class="line"></span><br><span class="line">plt.scatter(X, y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>Result:<img src="https://s3.ax1x.com/2020/11/25/DUaqr4.png" /></p>
<center>
fig. 3-1 Synthetic data
</center>
<h2 id="load-datasets-of-linear-regression">3.2 Load datasets of Linear Regression</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># instance for loading boston datasets</span></span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line"><span class="comment"># LinearRegression example</span></span><br><span class="line">loaded_data = datasets.load_boston()</span><br><span class="line"><span class="comment"># X, y = datasets_loadboston(retern_X_y = true)</span></span><br><span class="line">data_X, data_y = loaded_data.data, loaded_data.target</span><br><span class="line"></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(data_X, data_y)</span><br><span class="line"></span><br><span class="line">print(data_y[:<span class="number">4</span>])</span><br><span class="line">print(model.predict(data_X[:<span class="number">4</span>, :]))</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">24.</span>  <span class="number">21.6</span> <span class="number">34.7</span> <span class="number">33.4</span>]</span><br><span class="line">[<span class="number">30.00384338</span> <span class="number">25.02556238</span> <span class="number">30.56759672</span> <span class="number">28.60703649</span>]</span><br></pre></td></tr></table></figure>
<h2 id="normalization">3.3 Normalization</h2>
<ul>
<li><p>Demo</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># cross_validation 更新为 model_selection</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"> a = np.array([[<span class="number">10</span>, <span class="number">2.7</span>, <span class="number">3.6</span>],</span><br><span class="line">               [-<span class="number">100</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">               [<span class="number">120</span>, <span class="number">20</span>, <span class="number">40</span>]], dtype = np.float64)</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(preprocessing.scale(a)) <span class="comment"># normalization</span></span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[  <span class="number">10.</span>     <span class="number">2.7</span>    <span class="number">3.6</span>]</span><br><span class="line"> [-<span class="number">100.</span>     <span class="number">5.</span>     <span class="number">2.</span> ]</span><br><span class="line"> [ <span class="number">120.</span>    <span class="number">20.</span>    <span class="number">40.</span> ]]</span><br><span class="line">[[ <span class="number">0.</span>         -<span class="number">0.85170713</span> -<span class="number">0.66102858</span>]</span><br><span class="line"> [-<span class="number">1.22474487</span> -<span class="number">0.55187146</span> -<span class="number">0.75220493</span>]</span><br><span class="line"> [ <span class="number">1.22474487</span>  <span class="number">1.40357859</span>  <span class="number">1.41323351</span>]]</span><br></pre></td></tr></table></figure></li>
<li><p>Comparison of accuracy before and after normalization</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># cross_validation 更新为 model_selection</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets.samples_generator <span class="keyword">import</span> make_classification</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">X, y = make_classification(n_samples = <span class="number">300</span>, n_features = <span class="number">2</span>, n_redundant = <span class="number">0</span>,n_informative = <span class="number">2</span>, random_state = <span class="number">22</span>, n_clusters_per_class = <span class="number">1</span>, scale = <span class="number">100</span>)</span><br><span class="line"><span class="comment"># random_state: 固定随机数</span></span><br><span class="line"></span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c = y)</span><br><span class="line">plt.title(<span class="string">&#x27;Classification samples&#x27;</span>)</span><br><span class="line">plt.show() <span class="comment"># </span></span><br></pre></td></tr></table></figure>
<p>Plot the generated samples:<img src="https://s3.ax1x.com/2020/11/25/DUajaR.png" /></p>
<center>
<p>fig. 3-2 Samples</p>
</center>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y ,test_size = <span class="number">.3</span>)</span><br><span class="line">clf = SVC()</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">print(clf.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line">X = preprocessing.scale(X) <span class="comment"># normalization</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y ,test_size = <span class="number">.3</span>)</span><br><span class="line">clf = SVC()</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">print(clf.score(X_test, y_test))</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0.9111111111111111</span></span><br><span class="line"><span class="number">0.9555555555555556</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="model-features-and-attributes">4 Model features and attributes</h1>
<h2 id="basic-parameters">4.1 Basic parameters</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># LinearRegression example</span></span><br><span class="line">loaded_data = datasets.load_boston()</span><br><span class="line"><span class="comment"># X, y = datasets_loadboston(retern_X_y = true)</span></span><br><span class="line">data_X, data_y = loaded_data.data, loaded_data.target</span><br><span class="line"></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(data_X, data_y)</span><br><span class="line"></span><br><span class="line">print(data_y[:<span class="number">4</span>])</span><br><span class="line">print(model.predict(data_X[:<span class="number">4</span>, :]))</span><br><span class="line"></span><br><span class="line">print(model.coef_) <span class="comment"># 系数</span></span><br><span class="line">print(model.intercept_) <span class="comment"># 截距</span></span><br><span class="line">print(model.get_params) <span class="comment"># 参数</span></span><br><span class="line">print(model.score(data_X, data_y)) <span class="comment"># default is R^2 coefficietn of determination</span></span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[24.  21.6 34.7 33.4]</span><br><span class="line">[30.00384338 25.02556238 30.56759672 28.60703649]</span><br><span class="line">[-1.08011358e-01  4.64204584e-02  2.05586264e-02  2.68673382e+00</span><br><span class="line"> -1.77666112e+01  3.80986521e+00  6.92224640e-04 -1.47556685e+00</span><br><span class="line">  3.06049479e-01 -1.23345939e-02 -9.52747232e-01  9.31168327e-03</span><br><span class="line"> -5.24758378e-01]</span><br><span class="line">36.459488385089855</span><br><span class="line">&lt;bound method BaseEstimator.get_params of LinearRegression()&gt;</span><br><span class="line">0.7406426641094095</span><br></pre></td></tr></table></figure>
<h2 id="cross-validation">4.2 Cross validation</h2>
<ul>
<li><p>Evaluate the NN</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">knn = KNeighborsClassifier(n_neighbors = <span class="number">5</span>)</span><br><span class="line"><span class="comment"># knn.fit(X_train, y_train)</span></span><br><span class="line"><span class="comment"># print(knn.score(X_test, y_test))</span></span><br><span class="line">scores = cross_val_score(knn, X, y, cv = <span class="number">5</span>, scoring = <span class="string">&#x27;accuracy&#x27;</span>) <span class="comment"># 将test进行5次划分</span></span><br><span class="line">print(scores.mean()) <span class="comment"># 取平均值</span></span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0.9733333333333334</span></span><br></pre></td></tr></table></figure></li>
<li><p>Cross validation</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span>  learning_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">train_sizes, train_loss, test_loss= learning_curve( SVC(gamma=<span class="number">0.01</span>), X, y, cv=<span class="number">10</span>, scoring=<span class="string">&#x27;neg_mean_squared_error&#x27;</span>, train_sizes=[<span class="number">0.1</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># &#x27;neg_mean_squared_error&#x27; 非 &#x27;mean_squared_error&#x27;</span></span><br><span class="line"></span><br><span class="line">train_loss_mean = -np.mean(train_loss, axis=<span class="number">1</span>)</span><br><span class="line">test_loss_mean = -np.mean(test_loss, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(train_sizes, train_loss_mean, <span class="string">&#x27;o-&#x27;</span>, color=<span class="string">&quot;r&quot;</span>,</span><br><span class="line">             label=<span class="string">&quot;Training&quot;</span>)</span><br><span class="line">plt.plot(train_sizes, test_loss_mean, <span class="string">&#x27;o-&#x27;</span>, color=<span class="string">&quot;g&quot;</span>,</span><br><span class="line">             label=<span class="string">&quot;Cross-validation&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;Training examples&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DUabMF.md.png" /></p>
<center>
<p>fig 4-1 Vross-validation</p>
</center></li>
<li><p>Adjustment parameter-1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># test train split #</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">4</span>)</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">5</span>)</span><br><span class="line">knn.fit(X_train, y_train)</span><br><span class="line">y_pred = knn.predict(X_test)</span><br><span class="line">print(knn.score(X_test, y_test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># this is how to use cross_val_score to choose model and configs #</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">k_range = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">31</span>)</span><br><span class="line">k_scores = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> k_range:</span><br><span class="line">    knn = KNeighborsClassifier(n_neighbors=k)</span><br><span class="line"><span class="comment">##    loss = -cross_val_score(knn, X, y, cv=10, scoring=&#x27;mean_squared_error&#x27;) # for regression</span></span><br><span class="line">    scores = cross_val_score(knn, X, y, cv=<span class="number">10</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>) <span class="comment"># for classification</span></span><br><span class="line">    k_scores.append(scores.mean())</span><br><span class="line"></span><br><span class="line">plt.plot(k_range, k_scores)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Value of K for KNN&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Cross-Validated Accuracy&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DUaXZ9.png" /></p>
<center>
<p>fig. 4-2 Adjustment parameters</p>
</center></li>
<li><p>Adjustment parameter-2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> validation_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_digits</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">digits = load_digits()</span><br><span class="line">X = digits.data</span><br><span class="line">y = digits.target</span><br><span class="line">param_range = np.logspace(-<span class="number">6</span>, -<span class="number">2.3</span>, <span class="number">5</span>)</span><br><span class="line">train_loss, test_loss = validation_curve(</span><br><span class="line">        SVC(), X, y, param_name=<span class="string">&#x27;gamma&#x27;</span>, param_range=param_range, cv=<span class="number">10</span>,</span><br><span class="line">        scoring= <span class="string">&#x27;neg_mean_squared_error&#x27;</span>)</span><br><span class="line">train_loss_mean = -np.mean(train_loss, axis=<span class="number">1</span>)</span><br><span class="line">test_loss_mean = -np.mean(test_loss, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(param_range, train_loss_mean, <span class="string">&#x27;o-&#x27;</span>, color=<span class="string">&quot;r&quot;</span>,</span><br><span class="line">             label=<span class="string">&quot;Training&quot;</span>)</span><br><span class="line">plt.plot(param_range, test_loss_mean, <span class="string">&#x27;o-&#x27;</span>, color=<span class="string">&quot;g&quot;</span>,</span><br><span class="line">             label=<span class="string">&quot;Cross-validation&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">&quot;gamma&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Loss&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Overfitting problem&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DUaLqJ.png" /></p>
<center>
<p>fig 4-3 Adjustment parameters</p>
</center></li>
</ul>
<h2 id="transform-target-in-regression-model">4.3 Transform target in regression model</h2>
<p>将原始数据转化为分类模式，可以有效地提高预测的精度，效果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(__doc__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_regression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeCV</span><br><span class="line"><span class="keyword">from</span> sklearn.compose <span class="keyword">import</span> TransformedTargetRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> median_absolute_error, r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn.utils.fixes <span class="keyword">import</span> parse_version</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> parse_version(matplotlib.__version__) &gt;= parse_version(<span class="string">&#x27;2.1&#x27;</span>):</span><br><span class="line">    desity_param = &#123;<span class="string">&#x27;density&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    density_param = &#123;<span class="string">&#x27;normed&#x27;</span>: <span class="literal">True</span>&#125;</span><br><span class="line">    </span><br><span class="line">X, y = make_regression(n_samples = <span class="number">10000</span>, noise = <span class="number">100</span>, random_state = <span class="number">0</span>)</span><br><span class="line">y = np.exp((y + <span class="built_in">abs</span>(y.<span class="built_in">min</span>()))/<span class="number">200</span>)</span><br><span class="line">y_trans = np.log1p(y)</span><br><span class="line"></span><br><span class="line">f, (ax0, ax1) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># density: normalization</span></span><br><span class="line">ax0.hist(y, bins = <span class="number">100</span>, density = <span class="literal">True</span>)</span><br><span class="line">ax0.set_xlim([<span class="number">0</span>, <span class="number">2000</span>])</span><br><span class="line">ax0.set_ylabel(<span class="string">&#x27;Probability&#x27;</span>)</span><br><span class="line">ax0.set_xlabel(<span class="string">&#x27;Target&#x27;</span>)</span><br><span class="line">ax0.set_title(<span class="string">&#x27;Target distribution&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax1.hist(y_trans, bins = <span class="number">100</span>, density = <span class="literal">True</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;Probability&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;Target&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;Transformed target distribution&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f.suptitle(<span class="string">&#x27;Synthetic data&#x27;</span>, y = <span class="number">0.035</span>)</span><br><span class="line">f.tight_layout(rect = [<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.95</span>, <span class="number">0.95</span>])</span><br><span class="line"></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/11/25/DUavI1.png" /></p>
<center>
fig.4-4 Comparison of Transformation
</center>
<p>然后，再来测试其对预测精度的影响：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">f, (ax0, ax1) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, sharey=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">regr = RidgeCV()</span><br><span class="line">regr.fit(X_train, y_train)</span><br><span class="line">y_pred = regr.predict(X_test)</span><br><span class="line"></span><br><span class="line">ax0.scatter(y_test, y_pred)</span><br><span class="line">ax0.plot([<span class="number">0</span>, <span class="number">2000</span>], [<span class="number">0</span>, <span class="number">2000</span>], <span class="string">&#x27;--k&#x27;</span>)</span><br><span class="line">ax0.set_ylabel(<span class="string">&#x27;Target predicted&#x27;</span>)</span><br><span class="line">ax0.set_xlabel(<span class="string">&#x27;True Target&#x27;</span>)</span><br><span class="line">ax0.set_title(<span class="string">&#x27;Ridge regression \n without target transformation&#x27;</span>)</span><br><span class="line">ax0.text(<span class="number">100</span>, <span class="number">1750</span>, <span class="string">r&#x27;$R^2$=%.2f, MAE=%.2f&#x27;</span> % (</span><br><span class="line">    r2_score(y_test, y_pred), median_absolute_error(y_test, y_pred)))</span><br><span class="line">ax0.set_xlim([<span class="number">0</span>, <span class="number">2000</span>])</span><br><span class="line">ax0.set_ylim([<span class="number">0</span>, <span class="number">2000</span>])</span><br><span class="line"></span><br><span class="line">regr_trans = TransformedTargetRegressor(regressor=RidgeCV(), func=np.log1p,inverse_func=np.expm1)</span><br><span class="line"></span><br><span class="line">regr_trans.fit(X_train, y_train)</span><br><span class="line">y_pred = regr_trans.predict(X_test)</span><br><span class="line"></span><br><span class="line">ax1.scatter(y_test, y_pred)</span><br><span class="line">ax1.plot([<span class="number">0</span>, <span class="number">2000</span>], [<span class="number">0</span>, <span class="number">2000</span>], <span class="string">&#x27;--k&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;Target predicted&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;True Target&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;Ridge regression \n with target transformation&#x27;</span>)</span><br><span class="line">ax1.text(<span class="number">100</span>, <span class="number">1750</span>, <span class="string">r&#x27;$R^2$=%.2f, MAE=%.2f&#x27;</span> % (</span><br><span class="line">    r2_score(y_test, y_pred), median_absolute_error(y_test, y_pred)))</span><br><span class="line">ax1.set_xlim([<span class="number">0</span>, <span class="number">2000</span>])</span><br><span class="line">ax1.set_ylim([<span class="number">0</span>, <span class="number">2000</span>])</span><br><span class="line"></span><br><span class="line">f.suptitle(<span class="string">&quot;Synthetic data&quot;</span>, y=<span class="number">0.035</span>)</span><br><span class="line">f.tight_layout(rect=[<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.95</span>, <span class="number">0.95</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.ax1x.com/2020/11/25/DUazPx.png" /></p>
<center>
fig. 4-5 Comparison before and after transforming
</center>
<p>从结果可以看出，经过预处理转化后的数据集能有效地提高预测的精度，降低 <code>MAE</code> 的值。</p>
<h1 id="save-model">5 Save model</h1>
<p>Train model</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"></span><br><span class="line">clf = svm.SVC()</span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X, y = iris.data, iris.target</span><br><span class="line">clf.fit(X, y)</span><br></pre></td></tr></table></figure>
<p>Then, we can use two methods to save our trained models:</p>
<ol type="1">
<li><p>pickle</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># Save</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;save/clf.pickle&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    pickle.dump(clf, f)</span><br><span class="line"><span class="comment"># Restore</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;save/clf.pickle&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	clf2 = pickle.load(f)</span><br><span class="line">print(clf2.predict(X[<span class="number">0</span>:<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li>
<li><p>joblib</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> joblib</span><br><span class="line"><span class="comment"># Save</span></span><br><span class="line">joblib.dump(clf, <span class="string">&#x27;./save/clf.pkl&#x27;</span>)</span><br><span class="line"><span class="comment"># restore</span></span><br><span class="line">clf3 = joblib.load(<span class="string">&#x27;save/clf.pkl&#x27;</span>)</span><br><span class="line">print(clf3.predict(X[<span class="number">0</span>:<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Python module</category>
        <category>Machine learning</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Deep learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Stata</title>
    <url>/2020/12/15/Stata/</url>
    <content><![CDATA[<h1 id="stata-operation">1 Stata operation</h1>
<h2 id="import-data">1.1 Import data</h2>
<ul>
<li><p>use</p>
<p><code>grilic_small.dta</code> 文件的目录请根据自己的文件目录填写，数据文件可在陈强老师的网站下载，<a href="http://www.econometrics-stata.com/col.jsp?id=101">Click here</a>，选择《计量经济学及Stata应用》中的数据集下载。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">use <span class="string">&quot;D:\Demo\University\XMU\Class_files\Econometrics\Econometrics and Stata application\Data-Finished-bachelor\grilic_small.dta&quot;</span>, clear</span><br></pre></td></tr></table></figure></li>
</ul>
<a id="more"></a>
<ul>
<li><p>clear</p>
<p>关闭一个数据集，以便使用另外一个数据集</p></li>
<li><p><code>d</code>escribe</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看数据集中的变量名称、标签等</span></span><br><span class="line">describe <span class="keyword">or</span> d </span><br></pre></td></tr></table></figure></li>
<li><p>set more off/on</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连续滚屏显示命令运行结果</span></span><br><span class="line"><span class="built_in">set</span> more off </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分页显示命令运行结果</span></span><br><span class="line"><span class="built_in">set</span> more on</span><br></pre></td></tr></table></figure></li>
<li><p><code>l</code>ist</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看变量 s 和 lnw 的前 5 个数据</span></span><br><span class="line"><span class="built_in">list</span> s lnw <span class="keyword">in</span> <span class="number">1</span>/<span class="number">5</span> <span class="comment"># or</span></span><br><span class="line">l s lnw <span class="keyword">in</span> <span class="number">1</span>/<span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 罗列第 11-15 个观测值</span></span><br><span class="line"><span class="built_in">list</span> ss lnw <span class="keyword">in</span> <span class="number">11</span>/<span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出满足条件 ‘s&gt;=16&#x27; 的数据</span></span><br><span class="line"><span class="built_in">list</span> s lnw <span class="keyword">if</span> s &gt;= <span class="number">16</span></span><br><span class="line"><span class="comment"># &gt;=: 等于  &lt;=：小于等于  ==：等于  ~= or !=：不等于  =：赋值</span></span><br></pre></td></tr></table></figure></li>
<li><p>drop / keep</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除满足 ’s&gt;=16&#x27; 的观测值</span></span><br><span class="line">drop <span class="keyword">if</span> s &gt;= <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只保留满足 &#x27;s&gt;=16&#x27; 的观测值</span></span><br><span class="line">keep <span class="keyword">if</span> s &gt;= <span class="number">16</span></span><br></pre></td></tr></table></figure>
<p>注：Stata 并不提供 undo 功能，故需慎重删除数据，最好保留备份-</p></li>
<li><p>sort / gsort</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将数据按照变量 s 的升序排列</span></span><br><span class="line">sort s</span><br><span class="line">lsit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 降序排列</span></span><br><span class="line">gsort -s</span><br><span class="line"><span class="built_in">list</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="plot">1.2 Plot</h2>
<h3 id="直方图">1.3.1 直方图</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">histogram s, width(<span class="number">1</span>) frequency</span><br><span class="line">hist s, w(<span class="number">1</span>) freq</span><br><span class="line"><span class="comment"># histogram: 直方图, </span></span><br><span class="line"><span class="comment"># 选择项 &#x27;width(1)&#x27; 表示将组宽设为 1（否则将使用 Stata 根据样本容量计算的默认分组数）</span></span><br><span class="line"><span class="comment"># 选择项 ‘frequency&#x27; 表示将纵坐标定为频数（默认使用密度）</span></span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKz0OK.png" alt="image-20201210163044446" style="zoom:80%;" /></p>
<center>
Fig. 1-1 Histogram figure
</center>
<ul>
<li>查看帮助文档</li>
</ul>
<p>对于任何 <code>Stata</code> 命令，只需要输入 <code>help command_name</code> 即可查看该命令的帮助文档，<strong>初学者应养成经常查看帮助文档的习惯</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">help</span> histogram</span><br><span class="line">h hist</span><br><span class="line"><span class="comment"># 查看 histogram 命令的帮助文档</span></span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">histogram varname [<span class="keyword">if</span>] [<span class="keyword">in</span>] [weight] [, [continuous_opts | discrete_opts] options]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[if], [in]: 条件操作</span></span><br><span class="line"><span class="string">[weight]: 权重</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[continuous_opts]: 连续型变量选择项</span></span><br><span class="line"><span class="string">[discrete_opts]: 离散型选择项</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">continuous_opts        Description</span></span><br><span class="line"><span class="string">----------------------------------------</span></span><br><span class="line"><span class="string">Main</span></span><br><span class="line"><span class="string">  bin(#)               set number of bins to #</span></span><br><span class="line"><span class="string">  width(#)             set width of bins to #</span></span><br><span class="line"><span class="string">  start(#)         	   set lower limit of first bin to #</span></span><br><span class="line"><span class="string">-------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">discrete_opts          Description</span></span><br><span class="line"><span class="string">------------------------------------------</span></span><br><span class="line"><span class="string">Main</span></span><br><span class="line"><span class="string">  discrete             specify that data are discrete</span></span><br><span class="line"><span class="string">  width(#)             set width of bins to #</span></span><br><span class="line"><span class="string">  start(#)             set theoretical minimum value to #</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">options                Description</span></span><br><span class="line"><span class="string">-------------------------------------------</span></span><br><span class="line"><span class="string">Main</span></span><br><span class="line"><span class="string">  density               draw as density; the default</span></span><br><span class="line"><span class="string">  fraction              draw as fractions</span></span><br><span class="line"><span class="string">  frequency             draw as frequencies</span></span><br><span class="line"><span class="string">  percent               draw as percentages</span></span><br><span class="line"><span class="string">  bar_options           rendition of bars</span></span><br><span class="line"><span class="string">  binrescale  | recalculate bin sizes when by() is specified</span></span><br><span class="line"><span class="string">  addlabels             add height labels to bars</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Density plots</span></span><br><span class="line"><span class="string">  normal                  add a normal density to the graph</span></span><br><span class="line"><span class="string">  normopts(line_options)  affect rendition of normal density</span></span><br><span class="line"><span class="string">  kdensity     | add a kernel density estimate to the graph</span></span><br><span class="line"><span class="string">  kdenopts(kdensity_options) | affect rendition of kernel density</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Add plots</span></span><br><span class="line"><span class="string">  addplot(plot)           add other plots to the histogram</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="散点图">1.3.2 散点图</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scatter lnw s</span><br><span class="line">sc lnw s</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKzrwD.png" alt="image-20201210163409860" style="zoom:80%;" /></p>
<center>
Fig. 1-2 Scatter between lnw and s
</center>
<ul>
<li>标签</li>
</ul>
<p>如果想在散点图上标注每个点对应于哪个观测值，可先定义变量 <span class="math inline">\(n\)</span>，表示第 <span class="math inline">\(n\)</span> 个观测值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen n = _n</span><br><span class="line">scatter lnw s, mlabel(n) <span class="comment"># 选择变量 n 作为标签（mark label）</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>_n</code> 表示第 <span class="math inline">\(n\)</span> 个观测值。然后以变量作为每个点的标签来画散点图。结果如下：</p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKzsTe.png" alt="image-20201210164351554" style="zoom:80%;" /></p>
<center>
Fig. 1-3 Scatter with mark label
</center>
<h3 id="核密度估计图">1.3.3 核密度估计图</h3>
<p>直方图必然是不连续的，如果想得到密度函数的连续估计，可输入命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kdensity lnw, normal normop (lpattern (dash))</span><br><span class="line">kdensity lnw, normal normop (lp (dash)) </span><br></pre></td></tr></table></figure>
<p>其中</p>
<ul>
<li><code>kdensity</code>：核密度估计（kernel density estimation）；</li>
<li><code>normal</code>：画正态分布的密度函数作为对比；</li>
<li><code>normop (lp (Dash))</code>：将正态密度用虚线来画。
<ul>
<li><code>normop</code>：normal options</li>
<li><code>lpattern</code>： line pattern.</li>
</ul></li>
</ul>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKzRSI.md.png" alt="image-20201210224215508" style="zoom:80%;" /></p>
<center>
Fig. 1-4 Kernel density estimate
</center>
<h2 id="statistical-analysis">1.3 Statistical analysis</h2>
<ul>
<li><p>统计特征</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">summarize s</span><br><span class="line">su s</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span> lnw, detail <span class="comment"># 显示更多统计指标，如偏度、峰度</span></span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKzDeO.png" alt="image-20201210164927010" style="zoom:80%;" /></p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKzgfA.png" alt="image-20201210223033995" style="zoom:80%;" /></p>
<center>
<p>Fig. 1-4 Statistical description</p>
</center>
<p>显示了变量 <span class="math inline">\(s\)</span> 的样本容量、平均值、标准差、最小值于最大值。如 <strong>不指明变量</strong>，则显示 <strong>所有变量</strong> 的统计指标。</p></li>
<li><p>经验累计分布函数（Empirical cumulative distribution function）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tabulate s <span class="comment"># 显示 s 的经验累积分布番薯</span></span><br><span class="line">ta s</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKzwy6.png" alt="image-20201210165710687" style="zoom:80%;" /></p>
<center>
<p>Fig. 1-5 Empirical cummlative distribution</p>
</center>
<p>其中，<code>Freq</code> 表示频数，<code>Percent</code> 表示百分比，而 <code>Cum.</code> 表示累积百分比。</p></li>
<li><p>相关系数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pwcorr lnw s expr, sig star(<span class="number">.05</span>)</span><br><span class="line"><span class="comment"># 对工资对数、教育年限于工龄之间的相关系数</span></span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><code>pwcorr</code> ： <code>pairwise correlation</code>，即两两相关；</li>
<li>选择项 <code>sig</code> ：相关系数的显著性水平，即 <code>p-value</code>，列在相关系数的下方 ；</li>
<li>选择项 <code>star (.05)</code> ：所有显著性水平小于或等于 5% 的相关系数打赏星号。</li>
</ul>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/12/15/rKz6FH.png" alt="image-20201210170540089" style="zoom:80%;" /></p>
<center>
<p>Fig.1-6 Correlation coefficient</p>
</center>
<p>结果显示，<span class="math inline">\(\rm{ln} w\)</span> 与 <span class="math inline">\(s\)</span> 的相关系数为 0.5368，且在 1% 水平上显著（ <span class="math inline">\(p\)</span> 值为0.0022）；<span class="math inline">\(\rm{ln} w\)</span> 与 <span class="math inline">\(expr\)</span> 的相关系数为 -0.1132，但此相关关系也不显著（<span class="math inline">\(p-value\)</span> 为0.5514）</p></li>
</ul>
<h2 id="generate-new-variable">1.4 Generate new variable</h2>
<h3 id="basic-operation">1.4.1 Basic operation</h3>
<ul>
<li>对数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">generate lns = log(s)</span><br><span class="line">g lns = log(s) <span class="comment"># 对数</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>平方</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen s2 = s ^<span class="number">2</span> <span class="comment"># 平方项</span></span><br></pre></td></tr></table></figure></li>
<li><p>互动项（乘法）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen exprs = s * expr <span class="comment"># s 与 expr 的互动项</span></span><br></pre></td></tr></table></figure></li>
<li><p>指数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen w = exp(lnw) <span class="comment"># 指数</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="虚拟变量">1.4.2 虚拟变量</h3>
<p>假设定义 <span class="math inline">\(s \geq 16\)</span> 为 ”受过高等教育“，并使用 变量 <span class="math inline">\(college\)</span> 来表示:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen colleg = (s &gt;= <span class="number">16</span>)</span><br></pre></td></tr></table></figure>
<p>其中，括弧 <code>()</code> 表示对括弧中的表达式进行逻辑评估：如果此表达式为真，则取值为1；如果为假，则取值为0。</p>
<ul>
<li><p>变量重命名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rename colleg college</span><br><span class="line">ren colleg college</span><br></pre></td></tr></table></figure></li>
<li><p>变量重定义</p>
<p>将 ”受过高等教育“的定义改为 <span class="math inline">\(s \geq 15\)</span>，但仍用 <span class="math inline">\(college\)</span> 作为变量名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Method one</span></span><br><span class="line">drop college</span><br><span class="line">gen college = (s &gt;= <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method two</span></span><br><span class="line">replace college = (s &gt;= <span class="number">15</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>变量输入</p>
<p>对于较长的变量，一一输入较为麻烦，，有如下简便方式：</p>
<ul>
<li><p>在变量 窗口双击需要的变量；</p></li>
<li><p><span class="math inline">\(s1 - s5\)</span> 来选择这 5 个变量；</p></li>
<li><p>用 <code>*</code> 来简化变量名的书写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">drop s* <span class="comment"># 去掉所有以 s 开头的变量</span></span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h2 id="other">1.5 Other</h2>
<h3 id="calculator">1.5.1 Calculator</h3>
<p><code>Stata</code> 也可作为计算器来使用，命令格式为 <code>display expression</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">display log(<span class="number">2</span>) <span class="comment"># 计算 ln2</span></span><br><span class="line">di log(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">dis <span class="number">2</span>^<span class="number">0.5</span> <span class="comment"># 计算 $\sqrt&#123;2&#125;$</span></span><br></pre></td></tr></table></figure>
<h3 id="invoke-and-terminate-commands">1.5.2 Invoke and terminate commands</h3>
<ul>
<li>调用旧命令
<ul>
<li>使用键盘上的 <code>Pg Up</code> 和 <code>Pg Dn</code> 键；</li>
<li>在历史命令窗口 <strong>单击</strong> 旧命令，将命令调入命令窗口；</li>
<li>在历史命令窗口 <strong>双击</strong> 旧命令，再次执行此命令。</li>
</ul></li>
<li>停止执行当前执行命令
<ul>
<li>点击 <code>Break</code> 图标的快捷键；</li>
<li>同时按住 <code>Ctrl + Break</code>。</li>
</ul></li>
</ul>
<h3 id="log-file">1.5.3 Log file</h3>
<p><code>Stata</code> 日志文件的扩展名为 <code>smcl</code>。可通过快捷键 <code>Log</code> 图标使用，也可通过输入如下命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">log using today <span class="comment"># 在当前路径中生成一个名为 &#x27;today.smcl&#x27; 的日志文件</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"># Result:</span></span><br><span class="line"><span class="string">log using &quot;D:\Demo\University\XMU\Class_files\Econometrics\Econometrics and Stata application\Test\Test-log.smcl&quot;</span></span><br><span class="line"><span class="string">--------------------------------------------</span></span><br><span class="line"><span class="string">name:  &lt;unnamed&gt;</span></span><br><span class="line"><span class="string">log:  D:\Demo\University\XMU\Class_files\Econometrics\Econometrics and Stata application\Test\Test-log.smcl</span></span><br><span class="line"><span class="string">log type:  smcl</span></span><br><span class="line"><span class="string">opened on:  10 Dec 2020, 19:10:30</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>暂时关闭日志</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">log off</span><br></pre></td></tr></table></figure></li>
<li><p>恢复使用日志</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">log on</span><br></pre></td></tr></table></figure></li>
<li><p>彻底退出日志</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">log close</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="updata-stata-lib">1.5.4 Updata stata lib</h3>
<p>更新 <code>Stata</code> 命令库（ <code>Stata "ado"</code>文件及其他可执行文件）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">updata <span class="built_in">all</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>非官方命令</p>
<p>最流行的非官方命令下载平台为 <a href="https://ideas.repec.org/s/boc/bocode.html">统计软件成分</a> (Statistical Software Components, SSC)，从 <code>SCC</code> 下载 <code>Stata</code> 程序的命令为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scc install newcommand</span><br></pre></td></tr></table></figure>
<p>如果非官方命令不是来自 <code>SSC</code>，则需要手工安装。只需要将所有相关文件下载到制定的 <code>Stata</code> 文件夹中即可（通常为 <code>ado\plus\</code>）。如果不清楚应把文件复制到哪个文件夹，可输入以下命令，显示 <code>Stata</code> 的系统路径（System directories）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sysdir</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">. sysdir</span><br><span class="line">   STATA:  D:\Program files\Stata <span class="number">16</span>\</span><br><span class="line">    BASE:  D:\Program files\Stata <span class="number">16</span>\ado\base\</span><br><span class="line">    SITE:  D:\Program files\Stata <span class="number">16</span>\ado\site\</span><br><span class="line">    PLUS:  C:\Users\YangSu\ado\plus\ <span class="comment"># 复制到此文件夹</span></span><br><span class="line">PERSONAL:  C:\Users\YangSu\ado\personal\</span><br><span class="line">OLDPLACE:  c:\ado\</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="search-and-findit">1.5.5 Search and findit</h3>
<ul>
<li><p>Search command</p>
<p>如果想使用某种估计方法，但不知道它是否存在，可输入命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">search keyword</span><br></pre></td></tr></table></figure>
<p>此命令搜索 <code>Stata</code> 帮助文件、<code>Stata</code> 常见问题、<code>Stata</code> 案例、<code>Stata Journal</code>、<code>Stata Technical Bulletin</code>等。</p></li>
<li><p>Findit keyword</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">findit keyword</span><br></pre></td></tr></table></figure>
<p><code>findit</code>搜索范围更广，还包括 <code>Stata</code> 的网络资源。</p></li>
</ul>
]]></content>
      <categories>
        <category>Class Notes</category>
        <category>Econometrics</category>
      </categories>
      <tags>
        <tag>Econometrics</tag>
      </tags>
  </entry>
  <entry>
    <title>Energy Economic Codes</title>
    <url>/2020/12/08/Energy-Economic/</url>
    <content><![CDATA[<h1 id="markov-model">1 Markov model</h1>
<h2 id="preparation-and-definition">1.1 Preparation and definition</h2>
<ul>
<li><p>Import modules</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> linalg <span class="keyword">as</span> la</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error, r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot module</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># Microsoft YaHei, Times New Roman</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure></li>
</ul>
<a id="more"></a>
<ul>
<li><p>Plot results</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_result</span>(<span class="params">test_Y, pred_Y, Title</span>):</span></span><br><span class="line">    ylim_min = np.<span class="built_in">round</span>(test_Y.<span class="built_in">min</span>()) - <span class="number">1</span></span><br><span class="line">    ylim_max = np.<span class="built_in">round</span>(test_Y.<span class="built_in">max</span>()) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot comparison results</span></span><br><span class="line">    fig = plt.figure(figsize = (<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">    ax0 = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax0.scatter(test_Y, pred_Y)</span><br><span class="line">    ax0.plot([ylim_min, ylim_max], [ylim_min, ylim_max], <span class="string">&#x27;--k&#x27;</span>)</span><br><span class="line">    ax0.set_xlabel(<span class="string">&#x27;True Target&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">    ax0.set_ylabel(<span class="string">&#x27;Target predicted&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">    ax0.set_title(Title , fontsize = <span class="number">16</span>)</span><br><span class="line">    ax0.text(ylim_min + <span class="number">2</span>, ylim_max - <span class="number">4</span>, <span class="string">r&#x27;$R^2$ = %.2f, $MAE$ = %.2f&#x27;</span> %(r2_score(test_Y, pred_Y), </span><br><span class="line">                mean_absolute_error(test_Y, pred_Y)), fontsize = <span class="number">14</span>)</span><br><span class="line">    ax0.text(ylim_min + <span class="number">2</span>, ylim_max - <span class="number">5</span>, <span class="string">r&#x27;$MSE$ = %.2f, $RMSE$ = %.2f&#x27;</span> %(mean_squared_error(test_Y, pred_Y), </span><br><span class="line">                mean_squared_error(test_Y, pred_Y, squared=<span class="literal">False</span>)), fontsize = <span class="number">14</span>)</span><br><span class="line">    </span><br><span class="line">    ax0.set_xlim([ylim_min, ylim_max])</span><br><span class="line">    ax0.set_ylim([ylim_min, ylim_max])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot prediction and real values</span></span><br><span class="line">    plt.figure(figsize = (<span class="number">8</span>, <span class="number">6</span>)) <span class="comment"># length x width</span></span><br><span class="line">    plt.plot(pred_Y, <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;prediction&#x27;</span>, lw = <span class="number">0.8</span>)</span><br><span class="line">    plt.plot(test_Y, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;real&#x27;</span>, lw = <span class="number">0.8</span>)</span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="number">19</span>), fontsize = <span class="number">15</span>)</span><br><span class="line">    plt.yticks(fontsize = <span class="number">15</span>)</span><br><span class="line">    plt.title(Title, fontsize = <span class="number">16</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;best&#x27;</span>, fontsize  = <span class="number">15</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>
<p>绘制结果图（可选，可通过调整 <code>plot_b</code> 的值来选择是否绘图），包含两个:</p>
<p><img src="https://s3.ax1x.com/2020/12/08/rpDV56.md.png" /></p>
<center>
<p>Fig. 1-1 Trend figure of Coal</p>
</center>
<p><img src="https://s3.ax1x.com/2020/12/08/rpDePK.png" /></p>
<center>
<p>Fig. 1-2 Comparison figure of Coal</p>
</center></li>
<li><p>Calculate loss</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_error</span>(<span class="params">test_data, np_Pred_results, title</span>):</span></span><br><span class="line">    <span class="comment"># Storing error results </span></span><br><span class="line">    R2 = r2_score(test_data, np_Pred_results)</span><br><span class="line">    MAE = mean_absolute_error(test_data, np_Pred_results)</span><br><span class="line">    MSE = mean_squared_error(test_data, np_Pred_results)</span><br><span class="line">    RMSE = mean_squared_error(test_data, np_Pred_results, squared=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    error = [title, R2, MAE, MSE, RMSE]</span><br><span class="line">    <span class="keyword">return</span> error</span><br></pre></td></tr></table></figure>
<p>Calculate the loss: R2, MAE, MSE, RMSE</p></li>
<li><p>Definition of Markov model</p>
<p>The first step: calculate and return transfer matrix (type: np.array)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Markov_trans</span>(<span class="params">data_stru, year_start, year_end</span>):</span></span><br><span class="line">    P = np.identity(<span class="number">4</span>)</span><br><span class="line">    K = np.array([<span class="number">1.0</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">    </span><br><span class="line">    year_start_data = data_stru.loc[year_start, :]</span><br><span class="line">    year_end_data = data_stru.loc[year_end,:]</span><br><span class="line">    </span><br><span class="line">    bool_value = np.array(year_end_data &lt; year_start_data)</span><br><span class="line">    i = <span class="number">0</span> <span class="comment"># index</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> bool_value:</span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">False</span>: <span class="comment"># Decrease</span></span><br><span class="line">            K[i] =  year_end_data[i] - year_start_data[i]</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="literal">True</span>: <span class="comment"># Increase</span></span><br><span class="line">            P[i, i] = year_end_data[i]/year_start_data[i]</span><br><span class="line">            K[i] = <span class="number">0</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">          </span><br><span class="line">    KK = <span class="built_in">sum</span>(K)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> (j != n) &amp; (K[j] == <span class="number">0</span>):</span><br><span class="line">                P[j,n] = (<span class="number">1</span>-P[j,j])*K[n]/KK</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># v 为特征值    Q 为特征向量</span></span><br><span class="line">    P = np.<span class="built_in">round</span>(P, <span class="number">3</span>)</span><br><span class="line">    v, Q = la.eig(P)</span><br><span class="line">    <span class="comment"># diag_P = np.round(np.dot(np.dot(la.inv(Q), P), Q), 3)</span></span><br><span class="line">    V = np.diag(v)**((<span class="number">1</span>)/(year_end-year_start))</span><br><span class="line">    Predict_P =  np.<span class="built_in">round</span>(np.dot(np.dot(Q, V), la.inv(Q)), <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> Predict_P</span><br></pre></td></tr></table></figure>
<p>The second step: calculate and return forecasting result (type: np.array)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Markov_predict</span>(<span class="params">data_stru, P, year_end, year_pred</span>):</span></span><br><span class="line">    year_end_data = data_stru.loc[year_end,:]</span><br><span class="line">    P = np.<span class="built_in">round</span>(P, <span class="number">3</span>)</span><br><span class="line">    v, Q = la.eig(P)</span><br><span class="line">    <span class="comment"># diag_P = np.round(np.dot(np.dot(la.inv(Q), P), Q), 3)</span></span><br><span class="line">    V = np.diag(v)**(year_pred - year_end)</span><br><span class="line">    Predict_P =  np.<span class="built_in">round</span>(np.dot(np.dot(Q, V), la.inv(Q)), <span class="number">3</span>)</span><br><span class="line">    np_year_end_data =np.array(year_end_data)</span><br><span class="line">    Predict_energy_stru = np.around(np.dot(np_year_end_data, Predict_P), <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> Predict_energy_stru</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="preparation">1.2 Preparation</h2>
<ul>
<li><p>Read data file</p>
<p><code>Data.xlsx</code> 文件需要根程序文件在同一目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Read datafile</span></span><br><span class="line">data_stru = pd.read_excel(<span class="string">&#x27;./Data.xlsx&#x27;</span>, header = <span class="number">0</span>, </span><br><span class="line">                          sheet_name = <span class="number">0</span>, index_col= <span class="number">0</span>)</span><br><span class="line">num_year = <span class="built_in">len</span>(data_stru) <span class="comment"># the length of the dataset</span></span><br><span class="line">train_percent = <span class="number">0.7</span> <span class="comment"># Set the first 70% data as train set</span></span><br><span class="line">Error_results = [] <span class="comment"># Store all error results</span></span><br><span class="line">plot_b = <span class="literal">False</span> <span class="comment"># Choose whether plot result</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dataset start with 1953, end with 2017</span></span><br><span class="line">year_train_start, year_end = <span class="number">1953</span>, <span class="number">2018</span></span><br><span class="line">year_train_end = year_train_start + <span class="built_in">round</span>(<span class="built_in">len</span>(data_stru) * <span class="number">0.7</span>) <span class="comment"># = 1999</span></span><br><span class="line"></span><br><span class="line">test_data = np.array(data_stru.loc[year_train_end:, :]) <span class="comment"># from 1999 to 2017</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="model-application">1.3 Model application</h2>
<ul>
<li><p>Avarage trans_P</p>
<p>Model test based on avarage trans_P</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">trans_P = [] <span class="comment"># store all transfer matric</span></span><br><span class="line"><span class="keyword">for</span> startY <span class="keyword">in</span> <span class="built_in">range</span>(year_train_start, year_train_end - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> endY <span class="keyword">in</span> <span class="built_in">range</span>(startY, year_train_end):</span><br><span class="line">        trans_temp = Markov_trans(year_start = year_train_start, </span><br><span class="line">                        year_end = year_train_end, data_stru = data_stru)</span><br><span class="line">        temp = trans_temp.tolist()</span><br><span class="line">        trans_P.append(temp)</span><br><span class="line"></span><br><span class="line">np_trans_P = np.array(trans_P) <span class="comment"># Transfer list into numpy</span></span><br><span class="line">av_trans_P = np.<span class="built_in">sum</span>(np_trans_P, <span class="number">0</span>)/np_trans_P.shape[<span class="number">0</span>] <span class="comment"># Calculate avarage</span></span><br><span class="line"></span><br><span class="line">Pred_results = [] <span class="comment"># Using average transfer matrix to predict energy structure</span></span><br><span class="line"><span class="keyword">for</span> predY <span class="keyword">in</span> <span class="built_in">range</span>(year_train_end, year_end):</span><br><span class="line">    <span class="comment"># Forecasting</span></span><br><span class="line">    Pred_temp = Markov_predict(data_stru = data_stru, P = av_trans_P, </span><br><span class="line">                            year_end = year_train_end - <span class="number">1</span>, year_pred = predY)</span><br><span class="line">    temp = Pred_temp.tolist() <span class="comment"># Turn numpy.array into list</span></span><br><span class="line">    Pred_results.append(temp) <span class="comment"># It&#x27;s convenient to append value using list</span></span><br><span class="line">    </span><br><span class="line">np_Pred_results = np.array(Pred_results) <span class="comment"># Turn list into np.array</span></span><br><span class="line">Columns = data_stru.columns</span><br><span class="line"><span class="comment"># Plot forecasting result if needed</span></span><br><span class="line"><span class="keyword">if</span> plot_b == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        test_Y, pred_Y = test_data[:, i], np_Pred_results[:, i]</span><br><span class="line">        Title = <span class="string">&#x27;&#123;&#125; based on average transfer matrix to predict:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(regression, </span><br><span class="line">                                    Columns[i])</span><br><span class="line">        plot_result(test_Y, pred_Y, Title)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Storing error results</span></span><br><span class="line">title = <span class="string">&#x27;average transfer matrix&#x27;</span>  </span><br><span class="line"><span class="comment"># Calculate 4 error</span></span><br><span class="line">error = calculate_error(test_data, np_Pred_results, title)</span><br><span class="line">Error_results.append(error)</span><br></pre></td></tr></table></figure></li>
<li><p>One step and 46 step</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> year_train_start <span class="keyword">in</span> [<span class="number">1953</span>, <span class="number">1998</span>]: <span class="comment"># from &#x27;1953 to 1999&#x27; or &#x27;1998 to 1999&#x27;</span></span><br><span class="line">    year_train_end, year_end = <span class="number">1999</span>, <span class="number">2018</span></span><br><span class="line">    trans_temp = Markov_trans(year_start = year_train_start, </span><br><span class="line">                            year_end = year_train_end, data_stru = data_stru)</span><br><span class="line">    Pred_results = []</span><br><span class="line">    <span class="keyword">for</span> predY <span class="keyword">in</span> <span class="built_in">range</span>(year_train_end, year_end):</span><br><span class="line">        Pred_temp = Markov_predict(data_stru = data_stru, P = trans_temp, </span><br><span class="line">                                year_end = year_train_end - <span class="number">1</span>, year_pred = predY)</span><br><span class="line">        temp = Pred_temp.tolist()</span><br><span class="line">        Pred_results.append(temp)</span><br><span class="line">        </span><br><span class="line">    np_Pred_results = np.array(Pred_results)</span><br><span class="line">    Columns = data_stru.columns</span><br><span class="line">    <span class="keyword">if</span> plot_b == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            test_Y, pred_Y = test_data[:, i], np_Pred_results[:, i]</span><br><span class="line">            Title = <span class="string">&#x27;&#123;&#125; based on &#123;&#125; and &#123;&#125; to predict:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(regression, </span><br><span class="line">                                    year_train_start, year_train_end, Columns[i])             </span><br><span class="line">            plot_result(test_Y, pred_Y, Title)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Storing error results  </span></span><br><span class="line">    title = <span class="string">&#x27;&#123;&#125; step&#x27;</span>.<span class="built_in">format</span>(year_train_end - year_train_start)   </span><br><span class="line">    error = calculate_error(test_data, np_Pred_results, title)</span><br><span class="line">    Error_results.append(error)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="export-result-to-excel">1.4 Export result to excel</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np_error = np.array(Error_results)</span><br><span class="line">columns = [<span class="string">&#x27;Transfer Matrix&#x27;</span>, <span class="string">&#x27;R2&#x27;</span>, <span class="string">&#x27;MAE&#x27;</span>, <span class="string">&#x27;MSE&#x27;</span>, <span class="string">&#x27;RMSE&#x27;</span>]</span><br><span class="line">pd_error = pd.DataFrame(np_error, columns = columns, dtype = <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">pd_error.to_excel(<span class="string">&#x27;Error result.xlsx&#x27;</span>, encoding = <span class="string">&#x27;utf_8_sig&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="all-codes">1.5 All codes</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Markov model for energy structure prediction#</span></span><br><span class="line"><span class="comment"># ========================= Import modules ====================================</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> linalg <span class="keyword">as</span> la</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error, r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot module</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># Microsoft YaHei, Times New Roman</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== Preparation =======================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read datafile</span></span><br><span class="line">data_stru = pd.read_excel(<span class="string">&#x27;./Data.xlsx&#x27;</span>, header = <span class="number">0</span>, </span><br><span class="line">                          sheet_name = <span class="number">0</span>, index_col= <span class="number">0</span>)</span><br><span class="line">num_year = <span class="built_in">len</span>(data_stru) <span class="comment"># the length of the dataset</span></span><br><span class="line">train_percent = <span class="number">0.7</span> <span class="comment"># Set the first 70% data as train set</span></span><br><span class="line">Error_results = [] <span class="comment"># Store all error results</span></span><br><span class="line">plot_b = <span class="literal">False</span> <span class="comment"># Choose whether plot result</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dataset start with 1953, end with 2017</span></span><br><span class="line">year_train_start, year_end = <span class="number">1953</span>, <span class="number">2018</span></span><br><span class="line">year_train_end = year_train_start + <span class="built_in">round</span>(<span class="built_in">len</span>(data_stru) * <span class="number">0.7</span>) <span class="comment"># = 1999</span></span><br><span class="line"></span><br><span class="line">test_data = np.array(data_stru.loc[year_train_end:, :]) <span class="comment"># from 1999 to 2017</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== Plot Results =====================================</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_result</span>(<span class="params">test_Y, pred_Y, Title</span>):</span></span><br><span class="line">    ylim_min = np.<span class="built_in">round</span>(test_Y.<span class="built_in">min</span>()) - <span class="number">1</span></span><br><span class="line">    ylim_max = np.<span class="built_in">round</span>(test_Y.<span class="built_in">max</span>()) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot comparison results</span></span><br><span class="line">    fig = plt.figure(figsize = (<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">    ax0 = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax0.scatter(test_Y, pred_Y)</span><br><span class="line">    ax0.plot([ylim_min, ylim_max], [ylim_min, ylim_max], <span class="string">&#x27;--k&#x27;</span>)</span><br><span class="line">    ax0.set_xlabel(<span class="string">&#x27;True Target&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">    ax0.set_ylabel(<span class="string">&#x27;Target predicted&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">    ax0.set_title(Title , fontsize = <span class="number">16</span>)</span><br><span class="line">    ax0.text(ylim_min + <span class="number">2</span>, ylim_max - <span class="number">4</span>, <span class="string">r&#x27;$R^2$ = %.2f, $MAE$ = %.2f&#x27;</span> %(r2_score(test_Y, pred_Y), </span><br><span class="line">                mean_absolute_error(test_Y, pred_Y)), fontsize = <span class="number">14</span>)</span><br><span class="line">    ax0.text(ylim_min + <span class="number">2</span>, ylim_max - <span class="number">5</span>, <span class="string">r&#x27;$MSE$ = %.2f, $RMSE$ = %.2f&#x27;</span> %(mean_squared_error(test_Y, pred_Y), </span><br><span class="line">                mean_squared_error(test_Y, pred_Y, squared=<span class="literal">False</span>)), fontsize = <span class="number">14</span>)</span><br><span class="line">    </span><br><span class="line">    ax0.set_xlim([ylim_min, ylim_max])</span><br><span class="line">    ax0.set_ylim([ylim_min, ylim_max])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot prediction and real values</span></span><br><span class="line">    plt.figure(figsize = (<span class="number">8</span>, <span class="number">6</span>)) <span class="comment"># length x width</span></span><br><span class="line">    plt.plot(pred_Y, <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;prediction&#x27;</span>, lw = <span class="number">0.8</span>)</span><br><span class="line">    plt.plot(test_Y, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;real&#x27;</span>, lw = <span class="number">0.8</span>)</span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="number">19</span>), fontsize = <span class="number">15</span>)</span><br><span class="line">    plt.yticks(fontsize = <span class="number">15</span>)</span><br><span class="line">    plt.title(Title, fontsize = <span class="number">16</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;best&#x27;</span>, fontsize  = <span class="number">15</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the loss: R2, MAE, MSE, RMSE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_error</span>(<span class="params">test_data, np_Pred_results, title</span>):</span></span><br><span class="line">    <span class="comment"># Storing error results </span></span><br><span class="line">    R2 = r2_score(test_data, np_Pred_results)</span><br><span class="line">    MAE = mean_absolute_error(test_data, np_Pred_results)</span><br><span class="line">    MSE = mean_squared_error(test_data, np_Pred_results)</span><br><span class="line">    RMSE = mean_squared_error(test_data, np_Pred_results, squared=<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    error = [title, R2, MAE, MSE, RMSE]</span><br><span class="line">    <span class="keyword">return</span> error</span><br><span class="line"></span><br><span class="line"><span class="comment"># =================== Markov model definition =============================</span></span><br><span class="line"><span class="comment"># The first step: calculate and return transfer matrix (type: np.array)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Markov_trans</span>(<span class="params">data_stru, year_start, year_end</span>):</span></span><br><span class="line">    P = np.identity(<span class="number">4</span>)</span><br><span class="line">    K = np.array([<span class="number">1.0</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>])</span><br><span class="line">    </span><br><span class="line">    year_start_data = data_stru.loc[year_start, :]</span><br><span class="line">    year_end_data = data_stru.loc[year_end,:]</span><br><span class="line">    </span><br><span class="line">    bool_value = np.array(year_end_data &lt; year_start_data)</span><br><span class="line">    i = <span class="number">0</span> <span class="comment"># index</span></span><br><span class="line">    <span class="keyword">for</span> b <span class="keyword">in</span> bool_value:</span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">False</span>: <span class="comment"># Decrease</span></span><br><span class="line">            K[i] =  year_end_data[i] - year_start_data[i]</span><br><span class="line">        <span class="keyword">elif</span> b == <span class="literal">True</span>: <span class="comment"># Increase</span></span><br><span class="line">            P[i, i] = year_end_data[i]/year_start_data[i]</span><br><span class="line">            K[i] = <span class="number">0</span></span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">          </span><br><span class="line">    KK = <span class="built_in">sum</span>(K)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            <span class="keyword">if</span> (j != n) &amp; (K[j] == <span class="number">0</span>):</span><br><span class="line">                P[j,n] = (<span class="number">1</span>-P[j,j])*K[n]/KK</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># v 为特征值    Q 为特征向量</span></span><br><span class="line">    P = np.<span class="built_in">round</span>(P, <span class="number">3</span>)</span><br><span class="line">    v, Q = la.eig(P)</span><br><span class="line">    <span class="comment"># diag_P = np.round(np.dot(np.dot(la.inv(Q), P), Q), 3)</span></span><br><span class="line">    V = np.diag(v)**((<span class="number">1</span>)/(year_end-year_start))</span><br><span class="line">    Predict_P =  np.<span class="built_in">round</span>(np.dot(np.dot(Q, V), la.inv(Q)), <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> Predict_P</span><br><span class="line"></span><br><span class="line"><span class="comment"># The second step: calculate and return forecasting result (type: np.array)    </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Markov_predict</span>(<span class="params">data_stru, P, year_end, year_pred</span>):</span></span><br><span class="line">    year_end_data = data_stru.loc[year_end,:]</span><br><span class="line">    P = np.<span class="built_in">round</span>(P, <span class="number">3</span>)</span><br><span class="line">    v, Q = la.eig(P)</span><br><span class="line">    <span class="comment"># diag_P = np.round(np.dot(np.dot(la.inv(Q), P), Q), 3)</span></span><br><span class="line">    V = np.diag(v)**(year_pred - year_end)</span><br><span class="line">    Predict_P =  np.<span class="built_in">round</span>(np.dot(np.dot(Q, V), la.inv(Q)), <span class="number">3</span>)</span><br><span class="line">    np_year_end_data =np.array(year_end_data)</span><br><span class="line">    Predict_energy_stru = np.around(np.dot(np_year_end_data, Predict_P), <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> Predict_energy_stru</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Lable</span></span><br><span class="line">regression = <span class="string">&#x27;Markov model&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =========== Model test based on avarage trans_P ==========================</span></span><br><span class="line">trans_P = [] <span class="comment"># store all transfer matric</span></span><br><span class="line"><span class="keyword">for</span> startY <span class="keyword">in</span> <span class="built_in">range</span>(year_train_start, year_train_end - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> endY <span class="keyword">in</span> <span class="built_in">range</span>(startY, year_train_end):</span><br><span class="line">        trans_temp = Markov_trans(year_start = year_train_start, </span><br><span class="line">                        year_end = year_train_end, data_stru = data_stru)</span><br><span class="line">        temp = trans_temp.tolist()</span><br><span class="line">        trans_P.append(temp)</span><br><span class="line"></span><br><span class="line">np_trans_P = np.array(trans_P) <span class="comment"># Transfer list into numpy</span></span><br><span class="line">av_trans_P = np.<span class="built_in">sum</span>(np_trans_P, <span class="number">0</span>)/np_trans_P.shape[<span class="number">0</span>] <span class="comment"># Calculate avarage</span></span><br><span class="line"></span><br><span class="line">Pred_results = [] <span class="comment"># Using average transfer matrix to predict energy structure</span></span><br><span class="line"><span class="keyword">for</span> predY <span class="keyword">in</span> <span class="built_in">range</span>(year_train_end, year_end):</span><br><span class="line">    <span class="comment"># Forecasting</span></span><br><span class="line">    Pred_temp = Markov_predict(data_stru = data_stru, P = av_trans_P, </span><br><span class="line">                            year_end = year_train_end - <span class="number">1</span>, year_pred = predY)</span><br><span class="line">    temp = Pred_temp.tolist() <span class="comment"># Turn numpy.array into list</span></span><br><span class="line">    Pred_results.append(temp) <span class="comment"># It&#x27;s convenient to append value using list</span></span><br><span class="line">    </span><br><span class="line">np_Pred_results = np.array(Pred_results) <span class="comment"># Turn list into np.array</span></span><br><span class="line">Columns = data_stru.columns</span><br><span class="line"><span class="comment"># Plot forecasting result if needed</span></span><br><span class="line"><span class="keyword">if</span> plot_b == <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        test_Y, pred_Y = test_data[:, i], np_Pred_results[:, i]</span><br><span class="line">        Title = <span class="string">&#x27;&#123;&#125; based on average transfer matrix to predict:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(regression, </span><br><span class="line">                                    Columns[i])</span><br><span class="line">        plot_result(test_Y, pred_Y, Title)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># Storing error results</span></span><br><span class="line">title = <span class="string">&#x27;average transfer matrix&#x27;</span>  </span><br><span class="line"><span class="comment"># Calculate 4 error</span></span><br><span class="line">error = calculate_error(test_data, np_Pred_results, title)</span><br><span class="line">Error_results.append(error)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ======== Model test based on datas from 1953 to 1999 ==================</span></span><br><span class="line"><span class="keyword">for</span> year_train_start <span class="keyword">in</span> [<span class="number">1953</span>, <span class="number">1998</span>]: <span class="comment"># from &#x27;1953 to 1999&#x27; or &#x27;1998 to 1999&#x27;</span></span><br><span class="line">    year_train_end, year_end = <span class="number">1999</span>, <span class="number">2018</span></span><br><span class="line">    trans_temp = Markov_trans(year_start = year_train_start, </span><br><span class="line">                            year_end = year_train_end, data_stru = data_stru)</span><br><span class="line">    Pred_results = []</span><br><span class="line">    <span class="keyword">for</span> predY <span class="keyword">in</span> <span class="built_in">range</span>(year_train_end, year_end):</span><br><span class="line">        Pred_temp = Markov_predict(data_stru = data_stru, P = trans_temp, </span><br><span class="line">                                year_end = year_train_end - <span class="number">1</span>, year_pred = predY)</span><br><span class="line">        temp = Pred_temp.tolist()</span><br><span class="line">        Pred_results.append(temp)</span><br><span class="line">        </span><br><span class="line">    np_Pred_results = np.array(Pred_results)</span><br><span class="line">    Columns = data_stru.columns</span><br><span class="line">    <span class="keyword">if</span> plot_b == <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            test_Y, pred_Y = test_data[:, i], np_Pred_results[:, i]</span><br><span class="line">            Title = <span class="string">&#x27;&#123;&#125; based on &#123;&#125; and &#123;&#125; to predict:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(regression, </span><br><span class="line">                                    year_train_start, year_train_end, Columns[i])             </span><br><span class="line">            plot_result(test_Y, pred_Y, Title)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Storing error results  </span></span><br><span class="line">    title = <span class="string">&#x27;&#123;&#125; step&#x27;</span>.<span class="built_in">format</span>(year_train_end - year_train_start)   </span><br><span class="line">    error = calculate_error(test_data, np_Pred_results, title)</span><br><span class="line">    Error_results.append(error)</span><br><span class="line"></span><br><span class="line">np_error = np.array(Error_results)</span><br><span class="line">columns = [<span class="string">&#x27;Transfer Matrix&#x27;</span>, <span class="string">&#x27;R2&#x27;</span>, <span class="string">&#x27;MAE&#x27;</span>, <span class="string">&#x27;MSE&#x27;</span>, <span class="string">&#x27;RMSE&#x27;</span>]</span><br><span class="line">pd_error = pd.DataFrame(np_error, columns = columns, dtype = <span class="string">&#x27;object&#x27;</span>)</span><br><span class="line">pd_error.to_excel(<span class="string">&#x27;Error result.xlsx&#x27;</span>, encoding = <span class="string">&#x27;utf_8_sig&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="traditional-models">2 Traditional models</h1>
<ul>
<li>Ridge</li>
<li>Lasso</li>
<li>PLS</li>
<li>MLP</li>
<li>Linear SVM</li>
<li>DecisionTree</li>
</ul>
<p>不同之处在于104 行开始的模型定义不同</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ========================= Import modules ====================================</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge, Lasso</span><br><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPRegressor</span><br><span class="line"><span class="keyword">from</span> sklearn.cross_decomposition <span class="keyword">import</span> PLSRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> LinearSVR</span><br><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_absolute_error, r2_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># Plot module</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"><span class="comment"># Microsoft YaHei, Times New Roman</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== Preparation =======================================</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Read datafile</span></span><br><span class="line">data_stru = pd.read_excel(<span class="string">&#x27;./Data.xlsx&#x27;</span>, header = <span class="number">0</span>, </span><br><span class="line">                          sheet_name = <span class="number">0</span>, index_col= <span class="number">0</span>)</span><br><span class="line">data_stru = data_stru.dropna()</span><br><span class="line">dataset = data_stru.values</span><br><span class="line">dataset = dataset.astype(<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line"></span><br><span class="line">Columns = data_stru.columns <span class="comment"># columns name</span></span><br><span class="line">num_year = <span class="built_in">len</span>(data_stru) <span class="comment"># the length of the dataset</span></span><br><span class="line">train_percent = <span class="number">0.70</span> <span class="comment"># Set the first 70% data as train set</span></span><br><span class="line">test_percent = <span class="number">1</span> - train_percent</span><br><span class="line">Error_results = [] <span class="comment"># Store all error results</span></span><br><span class="line">input_size = <span class="number">10</span> <span class="comment"># Feed the previous 10 years as the input</span></span><br><span class="line">num_features = <span class="number">4</span> <span class="comment"># 4 energy categories</span></span><br><span class="line">plot_b = <span class="literal">False</span> <span class="comment"># Choose whether plot result</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # Put NN calculating module into GPU if available</span></span><br><span class="line"><span class="comment"># device = torch.device(&quot;cuda&quot; if torch.cuda.is_available() else &quot;cpu&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Feed the previous 10 years as the input and the 11th year as prediction output</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dataset</span>(<span class="params">dataset, look_back = input_size</span>):</span></span><br><span class="line">    dataX, dataY = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(dataset) - look_back):</span><br><span class="line">        a = dataset[i:(i + look_back)]</span><br><span class="line">        dataX.append(a)</span><br><span class="line">        dataY.append(dataset[i + look_back])</span><br><span class="line">    <span class="keyword">return</span> np.array(dataX), np.array(dataY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Input datasets and output datasets</span></span><br><span class="line">data_X, data_Y = create_dataset(dataset)</span><br><span class="line">ylim_min = np.<span class="built_in">round</span>(data_Y.<span class="built_in">min</span>()) - <span class="number">1</span></span><br><span class="line">ylim_max = np.<span class="built_in">round</span>(data_Y.<span class="built_in">max</span>()) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Divide training set and test set</span></span><br><span class="line">train_X, test_X, train_Y, test_Y = train_test_split(data_X, data_Y, </span><br><span class="line">        shuffle = <span class="literal">False</span>, test_size = test_percent) </span><br><span class="line"><span class="comment"># shuffle: don&#x27;t shuffle data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ======================== Plot Results =====================================</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_result</span>(<span class="params">test_Y, pred_Y, Title</span>):</span></span><br><span class="line">    ylim_min = np.<span class="built_in">round</span>(test_Y.<span class="built_in">min</span>()) - <span class="number">1</span></span><br><span class="line">    ylim_max = np.<span class="built_in">round</span>(test_Y.<span class="built_in">max</span>()) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot comparison results</span></span><br><span class="line">    fig = plt.figure(figsize = (<span class="number">8</span>, <span class="number">6</span>))</span><br><span class="line">    ax0 = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax0.scatter(test_Y, pred_Y)</span><br><span class="line">    ax0.plot([ylim_min, ylim_max], [ylim_min, ylim_max], <span class="string">&#x27;--k&#x27;</span>)</span><br><span class="line">    ax0.set_xlabel(<span class="string">&#x27;True Target&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">    ax0.set_ylabel(<span class="string">&#x27;Target predicted&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">    ax0.set_title(Title , fontsize = <span class="number">16</span>)</span><br><span class="line">    ax0.text(ylim_min + <span class="number">2</span>, ylim_max - <span class="number">4</span>, <span class="string">r&#x27;$R^2$ = %.2f, $MAE$ = %.2f&#x27;</span> %(r2_score(test_Y, pred_Y), </span><br><span class="line">                mean_absolute_error(test_Y, pred_Y)), fontsize = <span class="number">14</span>)</span><br><span class="line">    ax0.text(ylim_min + <span class="number">2</span>, ylim_max - <span class="number">5</span>, <span class="string">r&#x27;$MSE$ = %.2f, $RMSE$ = %.2f&#x27;</span> %(mean_squared_error(test_Y, pred_Y), </span><br><span class="line">                mean_squared_error(test_Y, pred_Y, squared=<span class="literal">False</span>)), fontsize = <span class="number">14</span>)</span><br><span class="line">    </span><br><span class="line">    ax0.set_xlim([ylim_min, ylim_max])</span><br><span class="line">    ax0.set_ylim([ylim_min, ylim_max])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Plot prediction and real values</span></span><br><span class="line">    plt.figure(figsize = (<span class="number">8</span>, <span class="number">6</span>)) <span class="comment"># length x width</span></span><br><span class="line">    plt.plot(pred_Y, <span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;prediction&#x27;</span>, lw = <span class="number">0.8</span>)</span><br><span class="line">    plt.plot(test_Y, <span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;real&#x27;</span>, lw = <span class="number">0.8</span>)</span><br><span class="line">    plt.xticks(<span class="built_in">range</span>(<span class="number">19</span>), fontsize = <span class="number">15</span>)</span><br><span class="line">    plt.yticks(fontsize = <span class="number">15</span>)</span><br><span class="line">    plt.title(Title, fontsize = <span class="number">16</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;best&#x27;</span>, fontsize  = <span class="number">15</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Calculate the loss: R2, MAE, MSE, RMSE</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_error</span>(<span class="params">test_data, np_Pred_results, title</span>):</span></span><br><span class="line">    <span class="comment"># Storing error results</span></span><br><span class="line">    R2 = <span class="built_in">float</span>(<span class="string">&#x27;&#123;:.5f&#125;&#x27;</span>.<span class="built_in">format</span>(r2_score(test_data, np_Pred_results)))</span><br><span class="line">    MAE = <span class="built_in">float</span>(<span class="string">&#x27;&#123;:.5f&#125;&#x27;</span>.<span class="built_in">format</span>(mean_absolute_error(test_data, np_Pred_results)))</span><br><span class="line">    MSE = <span class="built_in">float</span>(<span class="string">&#x27;&#123;:.5f&#125;&#x27;</span>.<span class="built_in">format</span>(mean_squared_error(test_data, np_Pred_results)))</span><br><span class="line">    RMSE =<span class="built_in">float</span>(<span class="string">&#x27;&#123;:.5f&#125;&#x27;</span>.<span class="built_in">format</span>( mean_squared_error(test_data, np_Pred_results, squared=<span class="literal">False</span>)))</span><br><span class="line">    error = [title, R2, MAE, MSE, RMSE]</span><br><span class="line">    <span class="keyword">return</span> error</span><br><span class="line"></span><br><span class="line"><span class="comment"># ================= Ridge Regression =============================</span></span><br><span class="line"><span class="comment"># Ridge model</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict_model</span>(<span class="params">model_train_X, model_train_Y</span>):</span></span><br><span class="line">    regr = Ridge()</span><br><span class="line">    regr.fit(model_train_X, model_train_Y)</span><br><span class="line">    model_pred_Y = regr.predict(model_test_X)</span><br><span class="line">    regression_name = <span class="string">&#x27;Ridge Regression&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> model_pred_Y, regression_name</span><br><span class="line"></span><br><span class="line"><span class="comment"># # Lasso model</span></span><br><span class="line"><span class="comment"># def predict_model(model_train_X, model_train_Y):</span></span><br><span class="line"><span class="comment">#     regr = Lasso()</span></span><br><span class="line"><span class="comment">#     regr.fit(model_train_X, model_train_Y)</span></span><br><span class="line"><span class="comment">#     model_pred_Y = regr.predict(model_test_X)</span></span><br><span class="line"><span class="comment">#     regression_name = &#x27;Lasso Model&#x27;</span></span><br><span class="line"><span class="comment">#     return model_pred_Y, regression_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # PLS model</span></span><br><span class="line"><span class="comment"># def predict_model(model_train_X, model_train_Y):</span></span><br><span class="line"><span class="comment">#     regr = PLSRegression(n_components=1)</span></span><br><span class="line"><span class="comment">#     regr.fit(model_train_X, model_train_Y)</span></span><br><span class="line"><span class="comment">#     model_pred_Y = regr.predict(model_test_X)</span></span><br><span class="line"><span class="comment">#     regression_name = &#x27;PLS Regression&#x27;</span></span><br><span class="line"><span class="comment">#     return model_pred_Y, regression_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ================= MLP Regression =============================</span></span><br><span class="line"><span class="comment"># # MLP model</span></span><br><span class="line"><span class="comment"># def predict_model(model_train_X, model_train_Y):</span></span><br><span class="line"><span class="comment">#     regr = MLPRegressor(random_state = 1, max_iter = 500)</span></span><br><span class="line"><span class="comment">#     regr.fit(model_train_X, model_train_Y)</span></span><br><span class="line"><span class="comment">#     model_pred_Y = regr.predict(model_test_X)</span></span><br><span class="line"><span class="comment">#     regression_name = &#x27;MLP Regression&#x27;</span></span><br><span class="line"><span class="comment">#     return model_pred_Y, regression_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ================= Linear SVM regression =============================</span></span><br><span class="line"><span class="comment"># # SVC model</span></span><br><span class="line"><span class="comment"># def predict_model(model_train_X, model_train_Y):</span></span><br><span class="line"><span class="comment">#     regr = LinearSVR(random_state= 0, tol= 1e-5)</span></span><br><span class="line"><span class="comment">#     regr.fit(model_train_X, model_train_Y)</span></span><br><span class="line"><span class="comment">#     model_pred_Y = regr.predict(model_test_X)</span></span><br><span class="line"><span class="comment">#     regression_name = &#x27;Linear SVR Regression&#x27;</span></span><br><span class="line"><span class="comment">#     return model_pred_Y, regression_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ================= DecisionTree Regressor =============================</span></span><br><span class="line"><span class="comment"># # DecisionTree model</span></span><br><span class="line"><span class="comment"># def predict_model(model_train_X, model_train_Y):</span></span><br><span class="line"><span class="comment">#     regr = DecisionTreeRegressor(random_state=0)</span></span><br><span class="line"><span class="comment">#     regr.fit(model_train_X, model_train_Y)</span></span><br><span class="line"><span class="comment">#     model_pred_Y = regr.predict(model_test_X)</span></span><br><span class="line"><span class="comment">#     regression_name = &#x27;Decision-Tree Regression&#x27;</span></span><br><span class="line"><span class="comment">#     return model_pred_Y, regression_name</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Forecasting</span></span><br><span class="line">pred_result = [] <span class="comment"># to store prediction results</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">3</span>:</span><br><span class="line">        model_train_X = train_X[:, :, i].reshape(-<span class="number">1</span>, input_size)</span><br><span class="line">        model_test_X = test_X[:, :, i].reshape(-<span class="number">1</span>, input_size)</span><br><span class="line">        model_train_Y = train_Y[:, i].reshape(-<span class="number">1</span>)</span><br><span class="line">        model_test_Y = test_Y[:, i].reshape(-<span class="number">1</span>)</span><br><span class="line">        model_pred_Y, regression = predict_model(model_train_X = model_train_X,</span><br><span class="line">                    model_train_Y = model_train_Y)</span><br><span class="line">        pred_result.append(model_pred_Y.tolist())</span><br><span class="line">    <span class="keyword">elif</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="comment"># Calculate the last energy consumption percent</span></span><br><span class="line">        np_pred_result = np.array(pred_result).T</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(np_pred_result.shape) == <span class="number">3</span>: <span class="comment"># Model output is 3-dimension</span></span><br><span class="line">            model_pred_Y = <span class="number">100</span> - np_pred_result.<span class="built_in">sum</span>(<span class="number">2</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>) <span class="comment"># PLS model</span></span><br><span class="line">            np_pred_result = np.concatenate((np_pred_result[<span class="number">0</span>], model_pred_Y), axis = <span class="number">1</span>) <span class="comment"># for PLS model</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="built_in">len</span>(np_pred_result.shape) == <span class="number">2</span>: <span class="comment"># Model output is 2-dimension</span></span><br><span class="line">            model_pred_Y = <span class="number">100</span> - np_pred_result.<span class="built_in">sum</span>(<span class="number">1</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>) <span class="comment"># Lasso model </span></span><br><span class="line">            np_pred_result = np.concatenate((np_pred_result, model_pred_Y), axis = <span class="number">1</span>) <span class="comment"># for Lasso model</span></span><br><span class="line">    Title = <span class="string">&#x27;Using &#123;&#125; to predict:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(regression, Columns[i])</span><br><span class="line">    <span class="keyword">if</span> plot_b == <span class="literal">True</span>:</span><br><span class="line">        plot_result(model_test_Y, model_pred_Y, Title) </span><br><span class="line">        </span><br><span class="line"><span class="comment"># Updata Error table</span></span><br><span class="line">error = calculate_error(test_Y, np_pred_result, regression)</span><br><span class="line">np_error = np.array(error).reshape(<span class="number">1</span>, -<span class="number">1</span>)</span><br><span class="line">columns = [<span class="string">&#x27;Transfer Matrix&#x27;</span>, <span class="string">&#x27;R2&#x27;</span>, <span class="string">&#x27;MAE&#x27;</span>, <span class="string">&#x27;MSE&#x27;</span>, <span class="string">&#x27;RMSE&#x27;</span>]</span><br><span class="line">pd_error = pd.DataFrame(np_error, columns = columns)</span><br><span class="line"></span><br><span class="line">error_excel =  pd.read_excel(<span class="string">&#x27;./Error result.xlsx&#x27;</span>, header = <span class="number">0</span>, sheet_name = <span class="number">0</span>, index_col= <span class="literal">None</span>)</span><br><span class="line">res = pd.concat([error_excel, pd_error], axis = <span class="number">0</span>, ignore_index = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Updata predict table</span></span><br><span class="line">model_col = []</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> Columns:</span><br><span class="line">    temp = <span class="string">&#x27;&#123;&#125;_&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(c, regression.split(<span class="string">&#x27; &#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    model_col.append(temp)</span><br><span class="line">pd_pred_result = pd.DataFrame(np_pred_result, columns = model_col, index = <span class="built_in">range</span>(<span class="number">2001</span>, <span class="number">2018</span>))</span><br><span class="line">pred_excel =  pd.read_excel(<span class="string">&#x27;./Predict results.xlsx&#x27;</span>, header = <span class="number">0</span>, sheet_name = <span class="number">0</span>, index_col= <span class="number">0</span>)</span><br><span class="line">pred_res = pd.concat([pred_excel, pd_pred_result], axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Store updated data</span></span><br><span class="line">res.to_excel(<span class="string">&#x27;./Error result.xlsx&#x27;</span>, encoding = <span class="string">&#x27;utf_8_sig&#x27;</span>, header = <span class="literal">True</span>, index = <span class="literal">False</span>)</span><br><span class="line">pred_res.to_excel(<span class="string">&#x27;./Predict results.xlsx&#x27;</span>, encoding = <span class="string">&#x27;utf_8_sig&#x27;</span>,  header = <span class="literal">True</span>, index = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h1 id="linear-nn-model">3 Linear NN model</h1>
]]></content>
      <categories>
        <category>Class Notes</category>
        <category>Energy economics</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>Prediction</tag>
      </tags>
  </entry>
  <entry>
    <title>Matplotlib</title>
    <url>/2020/11/30/Matplotlib/</url>
    <content><![CDATA[<h1 id="introduction">1 Introduction</h1>
<ul>
<li>中文显示乱码问题</li>
</ul>
<p>Matplotlib 库缺少中文字体，因此在图标上显示中文会出现乱码，解决办法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyplt <span class="keyword">import</span> mpl</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">mpl.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="steps">2 Steps</h1>
<ul>
<li>import module and set font style to avoid messy code</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>]=<span class="literal">False</span></span><br></pre></td></tr></table></figure>
<ul>
<li>step one: create figure and fix size (inch)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>)) <span class="comment"># length x width</span></span><br></pre></td></tr></table></figure>
<ul>
<li>setp two: generate data</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_val = <span class="number">0</span> <span class="comment"># start value</span></span><br><span class="line">stop_val = <span class="number">10</span> <span class="comment"># end value</span></span><br><span class="line">num_val = <span class="number">1000</span> <span class="comment"># samples number</span></span><br><span class="line">x = np.linspace(start_val, stop_val, num_val)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;--g,&#x27;</span>, lw = <span class="number">2</span>, label = <span class="string">&#x27;$sin(x)$&#x27;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>step three: adjust axis and set label</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 调整坐标范围</span></span><br><span class="line">x_min, y_max = <span class="number">0</span>, <span class="number">10</span></span><br><span class="line">y_min, y_max = <span class="number">0</span>, <span class="number">1.5</span></span><br><span class="line">plt.xlim(x_min, x_max)</span><br><span class="line">plt.ylim(y_min, y_max)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set axis label</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x轴&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y轴&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ticks: 刻度线</span></span><br><span class="line">x_location = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">x_labels = [<span class="string">&#x27;2019-01-01&#x27;</span>, <span class="string">&#x27;2019-02-01&#x27;</span>, <span class="string">&#x27;2019-03-01&#x27;</span>, <span class="string">&#x27;2019-04-01&#x27;</span>, <span class="string">&#x27;2019-05-01&#x27;</span>]</span><br><span class="line">y_location = np.arange(-<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">1</span>)</span><br><span class="line">y_labels = [<span class="string">u&#x27;minimum&#x27;</span>, <span class="string">u&#x27;zero&#x27;</span>, <span class="string">u&#x27;maximum&#x27;</span>]</span><br><span class="line">plt.xticks(x_location, x_labels, rotation = <span class="number">45</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">plt.yticks(y_location, y_labels, fontsize = <span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>step four: set grid and legend</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grid</span></span><br><span class="line">plt.grid(<span class="literal">True</span>, ls = <span class="string">&#x27;:&#x27;</span>, color = <span class="string">&#x27;r&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># title</span></span><br><span class="line">plt.title(<span class="string">&#x27;函数式绘图 vs 对象式绘图&#x27;</span>, fontsize = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># legend</span></span><br><span class="line">plt.legend(loc = <span class="string">&#x27;upper right&#x27;</span>, fontsize  = <span class="number">15</span>)</span><br><span class="line">plt.show(</span><br></pre></td></tr></table></figure>
<h2 id="函数式绘图">2.1 函数式绘图</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step one: create figure and fix size</span></span><br><span class="line">plt.figure(figsize = (<span class="number">12</span>, <span class="number">6</span>)) <span class="comment"># length x width</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step two: generate data</span></span><br><span class="line">start_val = <span class="number">0</span> <span class="comment"># start value</span></span><br><span class="line">stop_val = <span class="number">10</span> <span class="comment"># end value</span></span><br><span class="line">num_val = <span class="number">1000</span> <span class="comment"># samples number</span></span><br><span class="line">x = np.linspace(start_val, stop_val, num_val)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;--g,&#x27;</span>, lw = <span class="number">2</span>, label = <span class="string">&#x27;$sin(x)$&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step three: adjust axis</span></span><br><span class="line">x_min = <span class="number">0</span></span><br><span class="line">x_max = <span class="number">10</span></span><br><span class="line">y_min = <span class="number">0</span></span><br><span class="line">y_max = <span class="number">1.5</span></span><br><span class="line">plt.xlim(x_min, x_max)</span><br><span class="line">plt.ylim(y_min, y_max)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step four: set axis label</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x轴&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y轴&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">x_location = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">x_labels = [<span class="string">&#x27;2019-01-01&#x27;</span>, <span class="string">&#x27;2019-02-01&#x27;</span>, <span class="string">&#x27;2019-03-01&#x27;</span>, <span class="string">&#x27;2019-04-01&#x27;</span>, <span class="string">&#x27;2019-05-01&#x27;</span>]</span><br><span class="line">y_location = np.arange(-<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">1</span>)</span><br><span class="line">y_labels = [<span class="string">u&#x27;minimum&#x27;</span>, <span class="string">u&#x27;zero&#x27;</span>, <span class="string">u&#x27;maximum&#x27;</span>]</span><br><span class="line">plt.xticks(x_location, x_labels, rotation = <span class="number">45</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">plt.yticks(y_location, y_labels, fontsize = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step five: set grid</span></span><br><span class="line"><span class="comment"># ls: linestyle</span></span><br><span class="line">plt.grid(<span class="literal">True</span>, ls = <span class="string">&#x27;:&#x27;</span>, color = <span class="string">&#x27;r&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;函数式绘图&#x27;</span>, fontsize = <span class="number">25</span>)</span><br><span class="line">plt.legend(loc = <span class="string">&#x27;upper right&#x27;</span>, fontsize  = <span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWKVf.md.png" /></p>
<center>
fig 2-1 函数式绘图
</center>
<h2 id="对象式绘图">2.2 对象式绘图</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象式绘图</span></span><br><span class="line"><span class="comment"># pyplot 模块中的 figure() 函数创建名为 fig 的 Figure 对象</span></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Figure 对象中创建一个 Axes 对象，每个 Axes 对象即为一个绘图区域</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># generate data</span></span><br><span class="line">start_val, stop_val, num_val = <span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span></span><br><span class="line">x = np.linspace(start_val, stop_val, num_val)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># y = sin(x)</span></span><br><span class="line"><span class="comment"># &#x27;--g,&#x27;: format_string, equals with a combination of linestyle, color, market, 即折线、绿色、像素点</span></span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;--g&#x27;</span>, lw = <span class="number">2</span>, label = <span class="string">&#x27;sin(x)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整坐标范围</span></span><br><span class="line">x_min, x_max = <span class="number">0</span>, <span class="number">10</span></span><br><span class="line">y_min, y_max = <span class="number">0</span>, <span class="number">1.5</span></span><br><span class="line">ax.set_xlim(x_min, x_max)</span><br><span class="line">ax.set_ylim(y_min, y_max)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;x轴&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y轴&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">x_location = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">x_labels = [<span class="string">&#x27;2019-01-01&#x27;</span>, <span class="string">&#x27;2019-02-01&#x27;</span>, <span class="string">&#x27;2019-03-01&#x27;</span>, <span class="string">&#x27;2019-04-01&#x27;</span>, <span class="string">&#x27;2019-05-01&#x27;</span>]</span><br><span class="line">y_location = np.arange(-<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">1</span>)</span><br><span class="line">y_labels = [<span class="string">u&#x27;minimum&#x27;</span>, <span class="string">u&#x27;zero&#x27;</span>, <span class="string">u&#x27;maximum&#x27;</span>]</span><br><span class="line">plt.xticks(x_location, x_labels, rotation = <span class="number">45</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">plt.yticks(y_location, y_labels, fontsize = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ls: linestyle</span></span><br><span class="line">plt.grid(<span class="literal">True</span>, ls = <span class="string">&#x27;:&#x27;</span>, color = <span class="string">&#x27;r&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;函数式绘图 vs 对象式绘图&#x27;</span>, fontsize = <span class="number">25</span>)</span><br><span class="line">plt.legend(loc = <span class="string">&#x27;upper right&#x27;</span>, fontsize  = <span class="number">15</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgW1Pg.md.png" /></p>
<center>
fig 2-2 对象式绘图
</center>
<h1 id="figure-types">3 Figure types</h1>
<h2 id="line-attributes">3.1 Line attributes</h2>
<p>plot() 函数中，可设置参数以调整线条的属性：</p>
<ul>
<li>linestyle: 设定线条类型</li>
<li>color: 指定线条的颜色</li>
<li>marker: 指定线条的标记风格</li>
<li>linewidth: 设定线条的宽度</li>
<li>label: 设置线条的标签</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">start_val, stop_val, num_val = <span class="number">0</span>, <span class="number">10</span>, <span class="number">1000</span></span><br><span class="line">x = np.linspace(start_val, stop_val, num_val)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># y = sin(x)</span></span><br><span class="line"><span class="comment"># &#x27;--g,&#x27;: format_string, equals with a combination of linestyle, color, market, 即折线、绿色、像素点</span></span><br><span class="line">ax.plot(x, y, <span class="string">&#x27;--g&#x27;</span>, lw = <span class="number">2</span>, label = <span class="string">&#x27;$sin(x)$&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="标注点的绘制">3.2 标注点的绘制</h2>
<p>当要在图形上给数据添加指向性注释文本时，可以使用 Matplotlib 的 annotate() 函数，支持箭头指示，方便在合适的位置添加描述信息。关键参数如下：</p>
<ul>
<li>s：注释文本内容</li>
<li>xy：备注是的坐标点，二维元组格式 (x, y)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> xy : (<span class="built_in">float</span>, <span class="built_in">float</span>)</span><br><span class="line"><span class="comment"># The point *(x,y)* to annotate.</span></span><br></pre></td></tr></table></figure>
<ul>
<li>xytext：注释文本的坐标点，二维元组格式 (x, y)</li>
<li>xycoords：被注释点的坐标系属性，默认为 'data'</li>
<li>textcoords：设置注释文本的坐标系属性，默认与 xycoords 属性值相同，通常设置为 'offset points' or 'offset pixels'， 即相对于被注释点 xy 的偏移量</li>
<li>arrowprops：设置箭头的样式，dict 格式</li>
</ul>
<p>If 'arrowprops' does not contain the key ' arrowstyle', the allowed keys are:</p>
<center>
tab 5-1 arrowstyle key-1
</center>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Key</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">width</td>
<td style="text-align: left;">The width of the arrow in points</td>
</tr>
<tr class="even">
<td style="text-align: center;">headwidth</td>
<td style="text-align: left;">The width of the base of the arrow head in points</td>
</tr>
<tr class="odd">
<td style="text-align: center;">headlength</td>
<td style="text-align: left;">The length of the arrow head in points</td>
</tr>
<tr class="even">
<td style="text-align: center;">shrink</td>
<td style="text-align: left;">Fraction of total length to shrink from both ends</td>
</tr>
<tr class="odd">
<td style="text-align: center;">?</td>
<td style="text-align: left;">Any key to <code>matplotlib.patches.FancyArrowPatch</code></td>
</tr>
</tbody>
</table>
<p>如果 arrowprops 包含了关键词 ' arrowstyle'， the above keys are forbidden. The allowed values of 'arrowstyle' are:</p>
<center>
tab 5-2 arrowstyle key-2
</center>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Name</th>
<th style="text-align: center;">Attrs</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>'-'</code></td>
<td style="text-align: center;">None</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'-&gt;'</code></td>
<td style="text-align: center;">head_length=0.4,head_width=0.2</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'-['</code></td>
<td style="text-align: center;">widthB=1.0,lengthB=0.2,angleB=None</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'|-|'</code></td>
<td style="text-align: center;">widthA=1.0,widthB=1.0</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'-|&gt;'</code></td>
<td style="text-align: center;">head_length=0.4,head_width=0.2</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'&lt;-'</code></td>
<td style="text-align: center;">head_length=0.4,head_width=0.2</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'&lt;-&gt;'</code></td>
<td style="text-align: center;">head_length=0.4,head_width=0.2</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'&lt;|-'</code></td>
<td style="text-align: center;">head_length=0.4,head_width=0.2</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'&lt;|-|&gt;'</code></td>
<td style="text-align: center;">head_length=0.4,head_width=0.2</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'fancy'</code></td>
<td style="text-align: center;">head_length=0.4,head_width=0.4,tail_width=0.4</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'simple'</code></td>
<td style="text-align: center;">head_length=0.5,head_width=0.5,tail_width=0.2</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'wedge'</code></td>
<td style="text-align: center;">tail_width=0.3,shrink_factor=0.5</td>
</tr>
</tbody>
</table>
<p>Valid keys for <code>~matplotlib.patches.FancyArrowPatch</code> are:</p>
<center>
tab 5-3 ~matplotlib.patches.FancyArrowPatch
</center>
<table>
<thead>
<tr class="header">
<th>Key</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>arrowstyle</td>
<td>the arrow style</td>
</tr>
<tr class="even">
<td>connectionstyle</td>
<td>the connection style</td>
</tr>
<tr class="odd">
<td>relpos</td>
<td>default is (0.5, 0.5)</td>
</tr>
<tr class="even">
<td>patchA</td>
<td>default is bounding box of the text</td>
</tr>
<tr class="odd">
<td>patchB</td>
<td>default is None</td>
</tr>
<tr class="even">
<td>shrinkA</td>
<td>default is 2 points</td>
</tr>
<tr class="odd">
<td>shrinkB</td>
<td>default is 2 points</td>
</tr>
<tr class="even">
<td>mutation_scale</td>
<td>default is text size (in points)</td>
</tr>
<tr class="odd">
<td>mutation_aspect</td>
<td>default is 1</td>
</tr>
<tr class="even">
<td>?</td>
<td>any key for <code>matplotlib.patches.PathPatch</code></td>
</tr>
</tbody>
</table>
<ul>
<li>bbox：设置文本周围所添加的外框属性</li>
</ul>
<p>Case 1:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># add annotation</span></span><br><span class="line">ax.annotate(<span class="string">u&#x27;The top point&#x27;</span>,</span><br><span class="line">            xy = (np.pi/<span class="number">2</span>, <span class="number">1</span>), <span class="comment"># 箭头指向点的坐标</span></span><br><span class="line">            xytext = (np.pi/<span class="number">2</span>, <span class="number">1.3</span>), <span class="comment"># 注释文本左端的坐标</span></span><br><span class="line">            weight = <span class="string">&#x27;regular&#x27;</span>, <span class="comment"># 注释文本的字体粗细风格，bold：粗体，regular：正常粗细</span></span><br><span class="line">            color = <span class="string">&#x27;g&#x27;</span>, <span class="comment"># 注释文本颜色，green</span></span><br><span class="line">            fontsize = <span class="number">15</span>, <span class="comment"># 注释文本字体大小</span></span><br><span class="line">            arrowprops = &#123; <span class="comment"># arrowprops： arrow properties，以字典格式设置箭头属性</span></span><br><span class="line">                <span class="string">&#x27;arrowstyle&#x27;</span>: <span class="string">&#x27;-&gt;&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;connectionstyle&#x27;</span>: <span class="string">&#x27;arc3&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;g&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">u&#x27;The low point&#x27;</span>,</span><br><span class="line">            xy = (np.pi*<span class="number">3</span>/<span class="number">2</span>, -<span class="number">1</span>), </span><br><span class="line">            xytext = (np.pi*<span class="number">3</span>/<span class="number">2</span>, -<span class="number">1.3</span>),</span><br><span class="line">            weight = <span class="string">&#x27;regular&#x27;</span>, </span><br><span class="line">            color = <span class="string">&#x27;r&#x27;</span>, <span class="comment"># red</span></span><br><span class="line">            fontsize = <span class="number">15</span>, </span><br><span class="line">            arrowprops = &#123; </span><br><span class="line">                <span class="string">&#x27;arrowstyle&#x27;</span>: <span class="string">&#x27;-&gt;&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;connectionstyle&#x27;</span>: <span class="string">&#x27;arc3&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;color&#x27;</span>:<span class="string">&#x27;r&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.ax1x.com/2020/11/30/DgWeKI.md.png" /></p>
<center>
fig 3-1 Annotation case1
</center>
<p>Case 2：绘制以下四种样式的标注点</p>
<ul>
<li>注释文本 'annotate1' 所对应的样式配置：在 arrowprops 参数中使用关键字 'arrowstyle' 设置 <strong>箭头样式</strong> '-&gt;'，关键字 connectionstyle 设置连接线的样式</li>
<li>注释文本 'annotate2' 所对应的样式配置：在 arrowprops 参数中使用关键字 'arrowstyle' ，允许配置箭头的宽度 width、 箭头两端收缩的百分比 shrink 等</li>
<li>注释文本 'annotate3' 所对应的样式配置：使用 bbox 参数在文本周围添加外框，设置外框为 round 格式</li>
<li>注释文本 'annotate1' 所对应的样式配置：使用 bbox 参数在文本周围添加外框， 设置外框为 round 样式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Figure 对象中创建一个 Axes 对象，每个 Axes 对象即为一个绘图区域</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">x = np.arange(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line">y = np.around(np.log(x), <span class="number">2</span>)</span><br><span class="line">ax.plot(x, y, marker = <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">u&#x27;样式1&#x27;</span>, xy = (x[<span class="number">1</span>], y[<span class="number">1</span>]), xytext = (<span class="number">80</span>, <span class="number">10</span>), textcoords = <span class="string">&#x27;offset points&#x27;</span>, </span><br><span class="line">            arrowprops = <span class="built_in">dict</span>(arrowstyle = <span class="string">&#x27;-&gt;&#x27;</span>, connectionstyle = <span class="string">&#x27;angle3, angleA = 80, angleB = 50&#x27;</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">u&#x27;样式2&#x27;</span>, xy = (x[<span class="number">3</span>], y[<span class="number">3</span>]), xytext = (<span class="number">80</span>, <span class="number">10</span>), textcoords = <span class="string">&#x27;offset points&#x27;</span>, </span><br><span class="line">            arrowprops = <span class="built_in">dict</span>(facecolor = <span class="string">&#x27;black&#x27;</span>, shrink = <span class="number">0.05</span>, width = <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">u&#x27;样式3&#x27;</span>, xy = (x[<span class="number">5</span>], y[<span class="number">5</span>]), xytext = (<span class="number">80</span>, <span class="number">10</span>), textcoords = <span class="string">&#x27;offset points&#x27;</span>, </span><br><span class="line">            arrowprops = <span class="built_in">dict</span>(facecolor = <span class="string">&#x27;green&#x27;</span>, headwidth = <span class="number">5</span>, headlength = <span class="number">10</span>),</span><br><span class="line">            bbox = <span class="built_in">dict</span>(boxstyle = <span class="string">&#x27;circle, pad = 0.5&#x27;</span>, fc = <span class="string">&#x27;yellow&#x27;</span>, ec = <span class="string">&#x27;k&#x27;</span>, lw = <span class="number">1</span>, alpha = <span class="number">0.5</span>))</span><br><span class="line"><span class="comment"># fc: facecolor, ec: edegcolor, lw: lineweight</span></span><br><span class="line"></span><br><span class="line">ax.annotate(<span class="string">u&#x27;样式4&#x27;</span>, xy = (x[<span class="number">7</span>], y[<span class="number">7</span>]), xytext = (<span class="number">80</span>, <span class="number">10</span>), textcoords = <span class="string">&#x27;offset points&#x27;</span>, </span><br><span class="line">            arrowprops = <span class="built_in">dict</span>(facecolor = <span class="string">&#x27;blue&#x27;</span>, headwidth = <span class="number">5</span>, headlength = <span class="number">10</span>),</span><br><span class="line">            bbox = <span class="built_in">dict</span>(boxstyle = <span class="string">&#x27;round, pad = 0.5&#x27;</span>, fc = <span class="string">&#x27;gray&#x27;</span>, ec = <span class="string">&#x27;k&#x27;</span>, lw = <span class="number">1</span>, alpha = <span class="number">0.5</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWMa8.png" /></p>
<center>
fig 3-2 annoatation case2
</center>
<h2 id="参考线区域的绘制">3.3 参考线/区域的绘制</h2>
<ul>
<li>axhline(), axvline()</li>
</ul>
<p>使用 Matplotlib 的 axhline() 函数、axvline() 函数分别在图形中添加水平参考线和垂直参考线，使用 axhline() 函数时给定 y 轴上的位置，同理axvline() 使用时需要给定 x 轴上的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.axhline(y = <span class="built_in">min</span>(y), c = <span class="string">&#x27;blue&#x27;</span>, ls = <span class="string">&#x27;:&#x27;</span>, lw = <span class="number">2</span>)</span><br><span class="line">ax.axvline(x = np.pi*<span class="number">3</span>/<span class="number">2</span>, c = <span class="string">&#x27;blue&#x27;</span>, ls = <span class="string">&#x27;-.&#x27;</span>, lw = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>result:</p>
<p><img src="https://s3.ax1x.com/2020/11/30/DgW3GQ.png" /></p>
<center>
fig 3-3 Reference line
</center>
<ul>
<li>axhspan(), axvspan()</li>
</ul>
<p>使用 axhspan() 函数、axvspan() 函数分别在图形中添加 sin() 函数平行于 x 轴的参考区域和平行于 y 轴的参考区域，axhspan() 函数需给定 y 轴上的区间位置，同理在 axvspan() 中需给定 x 轴上的区间位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.axhspan(ymin = <span class="number">0</span>, ymax = <span class="number">1</span>, facecolor = <span class="string">&#x27;purple&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br><span class="line">ax.axvspan(xmin = np.pi *<span class="number">2</span>, xmax = np.pi * <span class="number">5</span>/<span class="number">2</span>, facecolor = <span class="string">&#x27;g&#x27;</span>, alpha = <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>
<p>result:</p>
<p><img src="https://s3.ax1x.com/2020/11/30/DgW82j.png" /></p>
<center>
fig 3-4 Reference interval
</center>
<h2 id="双-y-轴图表的绘制">3.4 双 Y 轴图表的绘制</h2>
<ul>
<li>twinx(), twiny()</li>
</ul>
<p>如果要在同一个 x 轴上显示两个不同数量级别的序列， 可以将第二个序列绘制在右侧辅助的 y 轴上，借助 Matplotlib 的 twinx() 和 twiny() 可以实现两个 y 或 x 轴</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax_aux = ax.twinx()</span><br><span class="line">ax_aux.plot(x, np.arange(<span class="number">1000</span>), color = <span class="string">&#x27;blue&#x27;</span>, label = <span class="string">&#x27;line 1000&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y_location1 = np.arange(<span class="number">0</span>, <span class="number">1000</span>, <span class="number">100</span>)</span><br><span class="line">y_labels1 = np.arange(<span class="number">0</span>, <span class="number">1000</span>, <span class="number">100</span>)</span><br><span class="line">ax_aux.set_yticks(y_location1) <span class="comment"># 刻度</span></span><br><span class="line">ax_aux.set_yticklabels(y_labels1, fontsize= <span class="number">15</span>) <span class="comment"># 刻度标签</span></span><br><span class="line"></span><br><span class="line">ax_aux.set_ylabel(<span class="string">&#x27;Y 轴 - 辅助&#x27;</span>, fontsize= <span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<p>result:</p>
<p><img src="https://s3.ax1x.com/2020/11/30/DgWGxs.md.png" /></p>
<center>
fig 3-5 双 Y 轴 图表
</center>
<ul>
<li>添加图例</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig.legend(loc = <span class="string">&#x27;upper right&#x27;</span>, bbox_to_anchor = (<span class="number">1</span>, <span class="number">1</span>), bbox_transform = ax.transAxes, fontsize = <span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<h2 id="条形图的绘制">3.5 条形图的绘制</h2>
<ul>
<li>bar()</li>
</ul>
<p>条形图时通过相同宽度条形的高度/宽度来表现数据差异的图表，可利用 bar() 函数绘制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Figure 对象中创建一个 Axes 对象，每个 Axes 对象即为一个绘图区域</span></span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pandas 生成时间序列</span></span><br><span class="line">date_index = pd.date_range(<span class="string">&#x27;2019-01-01&#x27;</span>, freq = <span class="string">&#x27;D&#x27;</span>, periods = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">y_location = np.arange(<span class="number">0</span>, <span class="number">1000</span>, <span class="number">200</span>)</span><br><span class="line">y_labels = np.arange(<span class="number">0</span>, <span class="number">1000</span>, <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分别模拟生成跌涨时的成交量数据</span></span><br><span class="line">red_bar = [<span class="number">1000</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">879</span>, <span class="number">986</span>, <span class="number">213</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">green_bar = [<span class="number">0</span>, <span class="number">200</span>, <span class="number">599</span>, <span class="number">567</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">234</span>, <span class="number">998</span>, <span class="number">489</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制条形图</span></span><br><span class="line">ax.bar(date_index, red_bar, facecolor = <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">ax.bar(date_index, green_bar, facecolor = <span class="string">&#x27;green&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">u&#x27;交易日&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">u&#x27;手&#x27;</span>,fontsize = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">ax.set_title(<span class="string">u&#x27;成交量&#x27;</span>, fontsize = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:</p>
<p><img src="https://s3.ax1x.com/2020/11/30/DgWYMn.png" /></p>
<center>
fig 3-6 条形图
</center>
<h2 id="直方图">3.6 直方图</h2>
<ul>
<li>hist()</li>
</ul>
<p>绘制直方图，首先要将全部样本数据按照不同的区间范围划分为若干组，每个组为直方图的柱子，柱子宽度表示该组的区间，柱子的高度表示数据出现的次数</p>
<ul>
<li>x：绘制直方图的数据（一维数组形式），例如服从正态分布的随机数组</li>
<li>bins：直方图的柱数</li>
<li>desity：是否将直方图的频数（数据出现的次数）转换成频率（数据所占的比例）的表示，默认为 False，True表示显示频数统计结果</li>
<li>n：直方图中每一个 bar 区间数据的频数或频率， 由参数 density 设定</li>
<li>bins：用于返回各个 bin 的区间范围</li>
<li>patches：；列表形式返回每个 bin 的图形对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制直方图</span></span><br><span class="line">ax.hist(np.random.normal(loc = <span class="number">0</span>, scale = <span class="number">1</span>, size = <span class="number">1000</span>), bins = <span class="number">50</span>, density = <span class="literal">False</span>, color = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">u&#x27;样本值&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">u&#x27;频数&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题</span></span><br><span class="line">ax.set_title(<span class="string">u&#x27;正态分布直方图&#x27;</span>, fontsize = <span class="number">25</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWtrq.md.png" /></p>
<center>
fig 3-7 直方图
</center>
<h2 id="饼图">3.7 饼图</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> pylab <span class="keyword">import</span> *</span><br><span class="line">rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>]=[<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"></span><br><span class="line">labels=[<span class="string">&quot;东部&quot;</span>,<span class="string">&quot;南部&quot;</span>,<span class="string">&quot;北部&quot;</span>,<span class="string">&quot;中部&quot;</span>]</span><br><span class="line">sizes=[<span class="number">5</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">15</span>]</span><br><span class="line">colors=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>,<span class="string">&quot;yellow&quot;</span>]</span><br><span class="line">explode=(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.05</span>,<span class="number">0</span>) <span class="comment"># 突出</span></span><br><span class="line">plt.pie(sizes, explode = explode, labels = labels, colors = colors, labeldistance = <span class="number">1.1</span>,autopct = <span class="string">&quot;%3.1f%%&quot;</span>, shadow = <span class="literal">True</span>, startangle = <span class="number">90</span>, pctdistance = <span class="number">0.5</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;equal&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWwIU.png" /></p>
<center>
fig 3-8 饼图
</center>
<h2 id="k-线图">3.8 K 线图</h2>
<ul>
<li>candlestick_ochl(), candlestick2_ochl()</li>
</ul>
<p>股票的 K 线记录着一个时间段的开盘价、最高价、最低价、收盘价这 4 个数据，定义如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mpl_finance <span class="keyword">as</span> mpf</span><br><span class="line">candlestick2_ochl(ax, opens, closea, highs, lows, width = <span class="number">4</span>, colorup = <span class="string">&#x27;k&#x27;</span>, colordown = <span class="string">&#x27;r&#x27;</span>, alpha = <span class="number">0.75</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>ochl: opens, closes, highs, lows, 分别表示开盘价、收盘价、最高价、最低价的序列</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> mpl_finance <span class="keyword">as</span> mpf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对象式绘图</span></span><br><span class="line"><span class="comment"># pyplt 模块中的 figure() 函数创建名为</span></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 K 线图</span></span><br><span class="line">opens = [<span class="number">2320.36</span>, <span class="number">2300</span>, <span class="number">2295.35</span>, <span class="number">2347.22</span>, <span class="number">2360.75</span>, <span class="number">2385.43</span>, <span class="number">2376.41</span>, <span class="number">2424.92</span>, <span class="number">2411</span>, <span class="number">2432.68</span>]</span><br><span class="line">closes = [<span class="number">2320.26</span>, <span class="number">2291.3</span>, <span class="number">2347.5</span>, <span class="number">2358.98</span>, <span class="number">2382.48</span>, <span class="number">2385.42</span>, <span class="number">2419.02</span>, <span class="number">2428.15</span>, <span class="number">2433.13</span>, <span class="number">2334.48</span>]</span><br><span class="line">lows = [<span class="number">2287.3</span>, <span class="number">2288.26</span>, <span class="number">2295.35</span>, <span class="number">2337.35</span>, <span class="number">2347.89</span>, <span class="number">2371.23</span>, <span class="number">2369.57</span>, <span class="number">2417.58</span>, <span class="number">2403.3</span>, <span class="number">2427.7</span>]</span><br><span class="line">highs = [<span class="number">2362.94</span>, <span class="number">2308.38</span>, <span class="number">2345.92</span>, <span class="number">2363.8</span>, <span class="number">2382.48</span>, <span class="number">2383.76</span>, <span class="number">2391.82</span>, <span class="number">2421.15</span>, <span class="number">2440.38</span>, <span class="number">2441.73</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制 K 线走势</span></span><br><span class="line">mpf.candlestick2_ochl(ax, opens, closes, highs, lows, width = <span class="number">0.5</span>, colorup = <span class="string">&#x27;r&#x27;</span>, colordown = <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pandas 生成实践序列</span></span><br><span class="line">date_index = pd.date_range(<span class="string">&#x27;2019-01-01&#x27;</span>, freq = <span class="string">&#x27;D&#x27;</span>, periods = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 x 轴的范围</span></span><br><span class="line">ax.set_xlim(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># x 轴刻度设定，每15天标一个日期</span></span><br><span class="line">ax.set_xticks(np.arange(<span class="number">0</span>, <span class="number">10</span>))</span><br><span class="line"><span class="comment"># 标签设置为日期</span></span><br><span class="line">ax.set_xticklabels([date_index.strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)[index] <span class="keyword">for</span> index <span class="keyword">in</span> ax.get_xticks()])</span><br><span class="line"><span class="comment"># 设置轴标签</span></span><br><span class="line">ax.set_xlabel(<span class="string">u&#x27;Date&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">u&#x27;Price&#x27;</span>, fontsize = <span class="number">15</span>)</span><br><span class="line">ax.set_title(<span class="string">u&#x27;日 K 线图&#x27;</span>, fontsize = <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWNq0.png" /></p>
<center>
fig 3-9 K 线图
</center>
<h2 id="time-series">3.9 Time series</h2>
<p>当横轴时间过长，不利于展示图片信息时，可以通过 matplotlib.datas 模块和<code>ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y'))</code>来调整仅显示年份</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.dates <span class="keyword">as</span> mdates</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ticks</span></span><br><span class="line">data_ticks = pd.date_range(start = <span class="string">&#x27;1985-12&#x27;</span>, freq = <span class="string">&#x27;Y&#x27;</span>, end = <span class="string">&#x27;2019-01&#x27;</span>)</span><br><span class="line">data_labels = np.arange(<span class="number">1985</span>, <span class="number">2019</span>)</span><br><span class="line"></span><br><span class="line">data = pd.read_csv(<span class="string">r&#x27;D:\Demo\University\XMU\Thesis\Master\WTI.csv&#x27;</span>)</span><br><span class="line"><span class="comment"># date_index = data.loc[:, &#x27;日期&#x27;]</span></span><br><span class="line">x_index = pd.date_range(start = <span class="string">&#x27;1986-01&#x27;</span>, freq = <span class="string">&#x27;M&#x27;</span>, end = <span class="string">&#x27;2019-01&#x27;</span>)</span><br><span class="line">data1 = data.loc[:, <span class="string">&#x27;收盘&#x27;</span>]</span><br><span class="line">data_pt = data1.to_list()</span><br><span class="line"></span><br><span class="line">petrol_price = pd.DataFrame(data_pt, index = x_index, columns = [<span class="string">&#x27;Pt_price&#x27;</span>])</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line">ax.plot(petrol_price, color = <span class="string">&#x27;b&#x27;</span>, lw = <span class="number">0.8</span>, label = <span class="string">&#x27;WTI现货离岸价格&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置时间显示格式，%Y%m%d%H 年月日时显示</span></span><br><span class="line">ax.xaxis.set_major_formatter(mdates.DateFormatter(<span class="string">&#x27;%Y&#x27;</span>))</span><br><span class="line"><span class="comment"># plt.xlim((1988, 2019))</span></span><br><span class="line">plt.xticks(ticks = data_ticks, label = data_labels, rotation = <span class="number">45</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;1986-2018年油价（WTI现货离岸价格）趋势图&#x27;</span>, fontsize = <span class="number">16</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWgqx.md.png" /></p>
<center>
fig 3-10 WTI油价趋势表
</center>
<h1 id="subplot">4 Subplot</h1>
<p>当需要在图表上显示多个子图时，可以在 Figure 对象中创建 Axes 对象，于是每个 Axes 对象即为一个独立的绘图区域，创建子图的方法主要有 subplot()、add_subplot()、add_axes() 三种方法</p>
<h2 id="create-subplot">4.1 Create subplot</h2>
<h3 id="add_subplot">4.1.1 add_subplot()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>,  <span class="number">8</span>))</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">211</span>) <span class="comment"># 子图以 2 行 1 列排布</span></span><br><span class="line">ax2 = fig.add_subplot(<span class="number">212</span>) <span class="comment"># 创建另一个 Axes 对象</span></span><br><span class="line"></span><br><span class="line">ax1.plot(np.arange(<span class="number">100</span>), np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>), label = <span class="string">u&#x27;0-10 随机数&#x27;</span>, ls = <span class="string">&#x27;-&#x27;</span>, c =<span class="string">&#x27;r&#x27;</span>, lw = <span class="number">1</span>)</span><br><span class="line">ax1.set_title(<span class="string">u&#x27;0-10 随机数&#x27;</span>, fontsize = <span class="number">12</span>)</span><br><span class="line">ax1.legend(loc = <span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(np.arange(<span class="number">100</span>), np.random.randint(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>), label = <span class="string">u&#x27;10-20 随机数&#x27;</span>, ls = <span class="string">&#x27;-&#x27;</span>, c =<span class="string">&#x27;y&#x27;</span>, lw = <span class="number">1</span>)</span><br><span class="line">ax2.set_title(<span class="string">u&#x27;10-20 随机数&#x27;</span>, fontsize = <span class="number">12</span>)</span><br><span class="line">ax2.legend(loc = <span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWsz9.png" /></p>
<center>
fig 4-1 subplot
</center>
<p>add_subplot() 本质上是以坐标来定位子图位置的，左下角坐标位置时子图在整个 Figure 对象上的绝对坐标，如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ax1, ax2)</span><br><span class="line"><span class="comment"># AxesSubplot(0.125,0.536818;0.775x0.343182)</span></span><br><span class="line"><span class="comment"># AxesSubplot(0.125,0.125;0.775x0.343182)</span></span><br></pre></td></tr></table></figure>
<h3 id="add_axes">4.1.2 add_axes()</h3>
<p>使用 add_axes() 创建子图与 add_subplot() 有所不同，add_axes() 函数中需要给定子图在整个 Figure 对象上的绝对坐标[x0, y0, width, height]，即左下角的坐标 (x0, y0) 及其宽度和高度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">ax1 = fig.add_axes([<span class="number">0.125</span>, <span class="number">0.536818</span>, <span class="number">0.775</span>, <span class="number">0.343182</span>])</span><br><span class="line">ax2 = fig.add_axes([<span class="number">0.125</span>, <span class="number">0.125</span>, <span class="number">0.775</span>, <span class="number">0.343182</span>])</span><br><span class="line">ax1.plot(np.arange(<span class="number">100</span>), np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>), label = <span class="string">u&#x27;0-10 随机数&#x27;</span>, ls = <span class="string">&#x27;-&#x27;</span>, c =<span class="string">&#x27;r&#x27;</span>, lw = <span class="number">1</span>)</span><br><span class="line">ax1.set_title(<span class="string">u&#x27;0-10 随机数&#x27;</span>, fontsize = <span class="number">12</span>)</span><br><span class="line">ax1.legend(loc = <span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(np.arange(<span class="number">100</span>), np.random.randint(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>), label = <span class="string">u&#x27;10-20 随机数&#x27;</span>, ls = <span class="string">&#x27;-&#x27;</span>, c =<span class="string">&#x27;y&#x27;</span>, lw = <span class="number">1</span>)</span><br><span class="line">ax2.set_title(<span class="string">u&#x27;10-20 随机数&#x27;</span>, fontsize = <span class="number">12</span>)</span><br><span class="line">ax2.legend(loc = <span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWrRJ.png" /></p>
<center>
fig 4-2 add_axes
</center>
<p>当需要精确定位子图时，可使用 add_axes()，但获取子图精确的位置信息较繁琐</p>
<h3 id="subplot-1">4.1.3 subplot()</h3>
<p>add_subplot() 和 add_axes() 是对象式创建子图的方法，而 subplot() 是函数式创建子图的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">plt.subplot(<span class="number">211</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">100</span>), np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>), label = <span class="string">u&#x27;0-10 随机数&#x27;</span>, ls = <span class="string">&#x27;-&#x27;</span>, c =<span class="string">&#x27;r&#x27;</span>, lw = <span class="number">1</span>)</span><br><span class="line">plt.legend(loc = <span class="number">1</span>)</span><br><span class="line">plt.subplot(<span class="number">212</span>)</span><br><span class="line">plt.plot(np.arange(<span class="number">100</span>), np.random.randint(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>), label = <span class="string">u&#x27;10-20 随机数&#x27;</span>, ls = <span class="string">&#x27;-&#x27;</span>, c =<span class="string">&#x27;y&#x27;</span>, lw = <span class="number">1</span>)</span><br><span class="line">plt.legend(loc = <span class="number">1</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result is same as above figure.</p>
<ul>
<li>Demo: 使用 subplot 创建 2 行 3 列 排布的多子图，以遍历方式在子图上绘制折线图</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">fig_ps, axes_ps = plt.subplots(<span class="number">2</span>, <span class="number">3</span>) </span><br><span class="line"><span class="comment"># subplots 返回两个值，fig_ps 表示图像大小信息， axes_ps 表示子图位置信息</span></span><br><span class="line">print(fig_ps, axes_ps)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        axes_ps[i, j].plot(np.arange(<span class="number">100</span>), np.random.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">100</span>), c =<span class="string">&#x27;y&#x27;</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWBiF.png" /></p>
<center>
fig 4-3 mul-subplot
</center>
<h2 id="布局多子图对象">4.2 布局多子图对象</h2>
<ul>
<li>GridSpec module</li>
</ul>
<p>有时不仅要在多个子图上显示图形，而且也要协调多个子图的位置和比例。三种创建子图的方法中，使用较多的是 add_plot() 方法，而该方法所创建的子图是堆成的子图，因此该方法并不满足非对称子图的应用。 若要创建非对称的子图，可以使用 matplotlib 的 GridSpec 模块。GridSpec 可以自定义子图的位置和调整子图行和列的相对高度和宽度</p>
<p>Import module</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec <span class="comment"># 分割子图</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gridspec.GridSpec 的构造函数</span></span><br><span class="line">gridspec.GridSpec(nrows, ncols, figure = <span class="literal">None</span>, left = <span class="literal">None</span>, bottom = <span class="literal">None</span>, right = <span class="literal">None</span>, top = <span class="literal">None</span>, wspace = <span class="literal">None</span>, hspace = <span class="literal">None</span>, width_ratios = <span class="literal">None</span>, height_ratios = <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p>参数 nrows 和 ncols 分别表示网格的行列数。用 plt.figure() 创建图表，通过 gridspec.GridSpec() 将整个图表划分为多个区域。由于 GridSpec 返回的实例支持切片方式选取网格区域，因此可以结合 add_subplot() 方法更灵活地添加跨度不同网格大小的子图</p>
<p>left, bottom, right, top 分别控制子图与 Figure 左边、底部、右边、顶部的距离比例。gs[0, : ] 表示该子图占第 0 行和所有列</p>
<h3 id="创建多子图布局">4.2.1 创建多子图布局</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>), dpi = <span class="number">100</span>, facecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">graph_ax1 = fig.add_subplot(gs[<span class="number">0</span>, :])</span><br><span class="line">graph_ax2 = fig.add_subplot(gs[<span class="number">1</span>, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">graph_ax3 = fig.add_subplot(gs[<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">graph_ax4 = fig.add_subplot(gs[<span class="number">2</span>, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgW6MR.png" /></p>
<center>
fig 4-4 多子图布局图
</center>
<h3 id="微调">4.2.2 微调</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize = (<span class="number">12</span>, <span class="number">8</span>), dpi = <span class="number">100</span>, facecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>, <span class="number">3</span>, left = <span class="number">0.08</span>, bottom = <span class="number">0.15</span>, right = <span class="number">0.99</span>, </span><br><span class="line">                       top = <span class="number">0.96</span>, wspace = <span class="number">0.5</span>, hspace = <span class="number">0.5</span>, width_ratios = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                      height_ratios = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">graph_ax1 = fig.add_subplot(gs[<span class="number">0</span>, :])</span><br><span class="line">graph_ax2 = fig.add_subplot(gs[<span class="number">1</span>, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">graph_ax3 = fig.add_subplot(gs[<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line">graph_ax4 = fig.add_subplot(gs[<span class="number">2</span>, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWcs1.md.png" /></p>
<center>
fig 4-5 微调之后的多子图布局
</center>
<h1 id="figure-properties">5 Figure properties</h1>
<h2 id="plot">5.1 plot()</h2>
<p>Function definition:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单线条：</span></span><br><span class="line">plot([x], y [, fmt], data = <span class="literal">None</span>, **kwargs)</span><br><span class="line"><span class="comment"># 多线条</span></span><br><span class="line">plot([x], y [, fmt], [x2], y2 [fmt2], ..., **kwargs)</span><br><span class="line"><span class="comment"># fmt = &#x27;[color][marker][line]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>其中，[fmt]为可选参数，用一个字符串来定义图形的基本属性，包括颜色（color），点型（marker），线性（linestyle），具体如下：</p>
<ul>
<li>Colors</li>
</ul>
<center>
tab 5-4 color properties
</center>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Character</th>
<th style="text-align: center;">Color</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>'b'</code></td>
<td style="text-align: center;">blue</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'g'</code></td>
<td style="text-align: center;">green</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'r'</code></td>
<td style="text-align: center;">red</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'c'</code></td>
<td style="text-align: center;">cyan（蓝绿色）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'m'</code></td>
<td style="text-align: center;">magenta（品红）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'y'</code></td>
<td style="text-align: center;">yellow</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'k'</code></td>
<td style="text-align: center;">black</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'w'</code></td>
<td style="text-align: center;">white</td>
</tr>
</tbody>
</table>
<ul>
<li>Markers</li>
</ul>
<center>
tab 5-5 marker properties
</center>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Character</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>'.'</code></td>
<td style="text-align: center;">point marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>','</code></td>
<td style="text-align: center;">pixel marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'o'</code></td>
<td style="text-align: center;">circle marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'v'</code></td>
<td style="text-align: center;">triangle_down marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'^'</code></td>
<td style="text-align: center;">triangle_up marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'&lt;'</code></td>
<td style="text-align: center;">triangle_left marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'&gt;'</code></td>
<td style="text-align: center;">triangle_right marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'1'</code></td>
<td style="text-align: center;">tri_down marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'2'</code></td>
<td style="text-align: center;">tri_up marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'3'</code></td>
<td style="text-align: center;">tri_left marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'4'</code></td>
<td style="text-align: center;">tri_right marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'s'</code></td>
<td style="text-align: center;">square marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'p'</code></td>
<td style="text-align: center;">pentagon marker（五角形）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'*'</code></td>
<td style="text-align: center;">star marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'h'</code></td>
<td style="text-align: center;">hexagon1 marker（六角形）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'H'</code></td>
<td style="text-align: center;">hexagon2 marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'+'</code></td>
<td style="text-align: center;">plus marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'x'</code></td>
<td style="text-align: center;">x marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'D'</code></td>
<td style="text-align: center;">diamond marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'d'</code></td>
<td style="text-align: center;">thin_diamond marker</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'|'</code></td>
<td style="text-align: center;">vline marker</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'_'</code></td>
<td style="text-align: center;">hline marker</td>
</tr>
</tbody>
</table>
<ul>
<li>Line Styles</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Character</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>'-'</code></td>
<td style="text-align: center;">solid line style</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'--'</code></td>
<td style="text-align: center;">dashed line style（虚线）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'-.'</code></td>
<td style="text-align: center;">dash-dot line style</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>':'</code></td>
<td style="text-align: center;">dotted line style</td>
</tr>
</tbody>
</table>
<ul>
<li>Examples format strings:</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Character</th>
<th style="text-align: center;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>'b'</code></td>
<td style="text-align: center;">blue markers with default shape</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'ro'</code></td>
<td style="text-align: center;">red circles</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'g-'</code></td>
<td style="text-align: center;">green solid line</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>'--'</code></td>
<td style="text-align: center;">dashed line with default color</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>'k^:'</code></td>
<td style="text-align: center;">black triangle_up markers connected by a dotted line</td>
</tr>
</tbody>
</table>
<p>Case:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>], <span class="string">&#x27;go--&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], color = <span class="string">&#x27;green&#x27;</span>, marker = <span class="string">&#x27;o&#x27;</span>, linestyle = <span class="string">&#x27;dashed&#x27;</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], color = <span class="string">&#x27;g&#x27;</span>, marker = <span class="string">&#x27;o&#x27;</span>, linestyle = <span class="string">&#x27;dashed&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWaZV.png" /></p>
<center>
fig 5-1 plot parameter
</center>
<h2 id="abbreviation">5.2 Abbreviation</h2>
<p>Matplotlib 支持一些属性的关键词简写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;linewidth&#x27;</span>: [<span class="string">&#x27;lw&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;linestyle&#x27;</span>: [<span class="string">&#x27;ls&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;facecolor&#x27;</span>: [<span class="string">&#x27;fc&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;edgecolor&#x27;</span>: [<span class="string">&#x27;ec&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;markerfacecolor&#x27;</span>: [<span class="string">&#x27;mfc&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;markeredgecolor&#x27;</span>: [<span class="string">&#x27;mec&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;markeredgewidth&#x27;</span>: [<span class="string">&#x27;mew&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;markersize&#x27;</span>: [<span class="string">&#x27;ms&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], color = <span class="string">&#x27;green&#x27;</span>, marker = <span class="string">&#x27;o&#x27;</span>, linestyle = <span class="string">&#x27;dashed&#x27;</span>, linewidth = <span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], c = <span class="string">&#x27;g&#x27;</span>, marker = <span class="string">&#x27;o&#x27;</span>, linestyle = <span class="string">&#x27;dashed&#x27;</span>, lw = <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWdaT.png" /></p>
<center>
fig 5-2 Abbreviation
</center>
<h2 id="ticks">5.3 Ticks</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure(num = <span class="number">1</span>)</span><br><span class="line">plt.plot(x, y1, color = <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;green&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim((-<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">plt.ylim((-<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">plt.xlabel(<span class="string">&#x27;I am x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;I am y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_ticks = np.linspace(-<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(new_ticks)</span><br><span class="line">plt.xticks(new_ticks) <span class="comment"># 刻度</span></span><br><span class="line">plt.yticks([-<span class="number">2</span>, -<span class="number">1.8</span>, -<span class="number">1</span>, <span class="number">1.22</span>, <span class="number">3</span>],</span><br><span class="line">           [<span class="string">r&#x27;$relly\ bad\ \alpha$&#x27;</span>, <span class="string">r&#x27;$bad$&#x27;</span>, <span class="string">r&#x27;$normal$&#x27;</span>, <span class="string">r&#x27;$good$&#x27;</span>, <span class="string">r&#x27;$really\ good$&#x27;</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:<img src="https://s3.ax1x.com/2020/11/30/DgWA8H.png" /></p>
<center>
fig 5-3 Ticks demo
</center>
<h2 id="axis-position">5.4 Axis position</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure(num = <span class="number">1</span>)</span><br><span class="line">plt.plot(x, y1, color = <span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;green&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim((-<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">plt.ylim((-<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">plt.xlabel(<span class="string">&#x27;I am x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;I am y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new_ticks = np.linspace(-<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(new_ticks)</span><br><span class="line">plt.xticks(new_ticks)</span><br><span class="line">plt.yticks([-<span class="number">2</span>, -<span class="number">1.8</span>, -<span class="number">1</span>, <span class="number">1.22</span>, <span class="number">3</span>],</span><br><span class="line">           [<span class="string">r&#x27;$relly\ bad\ \alpha$&#x27;</span>, <span class="string">r&#x27;$bad$&#x27;</span>, <span class="string">r&#x27;$normal$&#x27;</span>, <span class="string">r&#x27;$good$&#x27;</span>, <span class="string">r&#x27;$really\ good$&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># gca = get current axis</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>result:</p>
<p><img src="https://s3.ax1x.com/2020/11/30/DgWkPe.png" /></p>
<center>
fig 5-4 Modify axis position
</center>
<h2 id="legend">5.5 legend()</h2>
<ul>
<li>loc</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Location String</th>
<th style="text-align: center;">Location Code</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">'best'</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="even">
<td style="text-align: center;">'upper right'</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="odd">
<td style="text-align: center;">'upper left'</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="even">
<td style="text-align: center;">'lower left'</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="odd">
<td style="text-align: center;">'lower right'</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">'right'</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="odd">
<td style="text-align: center;">'center left'</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="even">
<td style="text-align: center;">'center right'</td>
<td style="text-align: center;">7</td>
</tr>
<tr class="odd">
<td style="text-align: center;">'lower center'</td>
<td style="text-align: center;">8</td>
</tr>
<tr class="even">
<td style="text-align: center;">'upper center'</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">'center'</td>
<td style="text-align: center;">10</td>
</tr>
</tbody>
</table>
<h2 id="add-text">5.6 Add text</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ax.text(<span class="number">0</span>, <span class="number">2</span>, <span class="string">&#x27;This is a test text.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.ax1x.com/2020/11/30/DgWRZ6.png" /></p>
<center>
fig 5-5 Add text on figure
</center>
]]></content>
      <categories>
        <category>Notes</category>
        <category>Python module</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Data analysis</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Prediction methods</title>
    <url>/2020/12/05/Prediction-methods/</url>
    <content><![CDATA[<h1 id="differential-equation-model">1 Differential equation model</h1>
<h2 id="introduction">1.1 Introduction</h2>
<ul>
<li>特点</li>
</ul>
<p>当描述实际对象的某些特征随时间（或空间）而演变的过程、分析它的变化规律、预测它的未来形态、研究它的控制手段时，通常需要建立对象的 <strong>动态微分方程模型</strong>。</p>
<p>微分模型求解的结果就是问题的答案，该答案是 <strong>唯一</strong> 的。</p>
<ul>
<li>典型的模型：
<ul>
<li>传染病的预测模型</li>
<li>经济增长预测模型</li>
<li>兰彻斯特（Lanchester）战争预测模型</li>
<li>药物在体内的分布于排除预测模型</li>
<li>人口的预测模型</li>
<li>烟雾的扩散与消失模型</li>
</ul></li>
</ul>
<p>模型的基本规律随着时间的增长趋势呈指数形式，根据变量的个数建立微分方程。</p>
<a id="more"></a>
<ul>
<li><strong>优点</strong></li>
</ul>
<p>短、中、长期的预测都能适用，既能反应 <strong>内部规律</strong> 以及 <strong>事物的内在关系</strong>，也能分析两个因素的 <strong>相关关系</strong>，精度相应的比较高，另外对模型的改进也比较容易理解和实现。</p>
<ul>
<li><strong>缺点</strong></li>
</ul>
<p>虽然反应的是内部规律，但由于方程的建立是以局部规律的独立性假定为基础，故中长期预测 <strong>偏差有点大</strong>，且 <strong>解较难得到</strong>。</p>
<h2 id="case">1.2 Case</h2>
<ul>
<li><p>Problem</p>
<p>硫黄岛位于东京以南 660 英里的海面上，是日军的重要空军基地。美军在1945 年2 月开始进攻，激烈的战斗持续了一个月，双方伤亡惨重，日方守军21500 人全部阵亡或被俘，美方投入兵力73000 人，伤亡20265 人，战争进行到28 天时美军宣布占领该岛，实际战斗到36 天才停止。美军的战地记录有按天统计的战斗减员和增援情况。日军没有后援，战地记录则全部遗失。</p></li>
<li><p>Solution Code</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">dxy=@(t,x)[<span class="number">-0.0544</span>*x(<span class="number">2</span>)+<span class="number">54000</span>*(t&gt;=<span class="number">0</span> &amp; t&lt;<span class="number">1</span>)+<span class="number">6000</span>*(t&gt;=<span class="number">2</span> &amp; t&lt;<span class="number">3</span>)+<span class="number">13000</span>*(t&gt;=<span class="number">5</span> &amp; t&lt;<span class="number">6</span>)</span><br><span class="line">    <span class="number">-0.0106</span>*x(<span class="number">1</span>)];  <span class="comment">%用匿名函数定义方程右端项，这里用逻辑语句定义分段函数</span></span><br><span class="line">[t,xy]=ode45(dxy,[<span class="number">0</span>:<span class="number">36</span>],[<span class="number">0</span>,<span class="number">21500</span>])</span><br><span class="line">subplot(<span class="number">211</span>), <span class="built_in">plot</span>(t,xy(:,<span class="number">1</span>),<span class="string">&#x27;r*&#x27;</span>,t,xy(:,<span class="number">2</span>),<span class="string">&#x27;gD&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;时间t&#x27;</span>),  ylabel(<span class="string">&#x27;人数&#x27;</span>), <span class="built_in">legend</span>(<span class="string">&#x27;美军&#x27;</span>,<span class="string">&#x27;日军&#x27;</span>)</span><br><span class="line">subplot(<span class="number">212</span>),  <span class="built_in">plot</span>(xy(:,<span class="number">1</span>),xy(:,<span class="number">2</span>))  <span class="comment">%画微分方程组的轨线</span></span><br><span class="line">xlabel(<span class="string">&#x27;美军人数x&#x27;</span>),  ylabel(<span class="string">&#x27;日军人数y&#x27;</span>)  </span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p><img src="https://s3.ax1x.com/2020/12/05/DLrAIJ.png" /></p>
<center>
<p>Fig. 1-1 Result of case 1</p>
</center></li>
</ul>
<h1 id="grey-model">2 Grey model</h1>
<h2 id="introduction-1">2.1 Introduction</h2>
<ul>
<li><p>主要特点</p>
<p>模型使用的不是原始数据序列，而是生成的数据序列，其核心体系是 <strong>灰色模型（Grey model, GM）</strong>， 即对原始数据作 <strong>累加生成</strong> 得到近似的 <strong>指数规律 </strong>再进行建模的方法。</p></li>
<li><p><strong>优点</strong></p>
<ul>
<li>不需要很多的数据，一般只需要4个数据，就能解决<strong>历史数据少、序列的完整性及可靠性低</strong>的问题；</li>
<li>能利用微分方程来充分挖掘系统的本质，精度高；</li>
<li>能将无规律的原始数据进行生成得到规律性较强的生成序列，预算简便，易于检验，不考虑分布规律，不考虑变化趋势。</li>
</ul></li>
<li><p><strong>缺点</strong></p>
<p>只适用于 <strong>中短期的预测</strong>，只适合 <strong>指数增长的预测</strong>。</p></li>
</ul>
<h2 id="categories">2.2 Categories</h2>
<h3 id="gm1-1-forecasting-model">2.2.1 GM(1, 1) forecasting model</h3>
<p>GM(1, 1) denotes the grey model is a <strong>first order difference equation</strong> and only include <strong>one variable</strong>.</p>
<p>Not finished, to be continued...</p>
<h3 id="gm2-1-dgm-and-verhulst-model">2.2.2 GM(2, 1), DGM and Verhulst model</h3>
<p>GM(1, 1) 模型适用于具有较强 <strong>指数规律</strong> 的序列，只能描述单调的变化过程，对于<strong>非单调的摆动发展序列</strong>或 <strong>有饱和的 S 形序列</strong>，可以考虑建立 GM(2, 1), DGM and Verhulst model。</p>
<ul>
<li><p>灰色 Verhulst 预测模型</p>
<p>Verhulst 模型主要用来描述具有剥和状态的过程，即 S 形过程，常用于</p>
<ul>
<li>人口预测</li>
<li>生物生长</li>
<li>繁殖预测</li>
<li>产品经济寿命预测</li>
</ul></li>
</ul>
<h1 id="difference-equation">3 Difference equation</h1>
<h2 id="introduction-2">3.1 Introduction</h2>
<p>在利用差分方程建模研究实际问题时，常需要根据统计数据用 <strong>最小二乘法</strong> 来 <strong>拟合 </strong>出差分方程的 <strong>系数</strong>。其系统稳定性讨论要用到代数方程的求根。</p>
<h3 id="一阶自回归ar1">3.1.1 一阶自回归（AR(1)）</h3>
<p>由于时间序列一般存在自相关，故最简单的预测方法为，使用过去值 <span class="math inline">\(y_{t-1}\)</span> 来预测当前值 <span class="math inline">\(y_{t}\)</span> ，即一阶自回归模型（AR(1)） <span class="math display">\[
y_t = \beta_0 + \beta_1 y_{t-1} + \varepsilon_t \ \ (t = 2, \dots, T)
\]</span> 其中，扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为白噪声，故无自相关，即 <span class="math inline">\(\rm{Cov}(\varepsilon_t,\ \varepsilon_s) = 0, \forall t \neq s\)</span>。假设自回归系数 $|_1| &lt; 1 $，则 $ {y_t}$ 为渐进独立的平稳过程。</p>
<h3 id="高阶自回归arp">3.1.2 高阶自回归（AR(p)）</h3>
<p>在 AR(1) 模型中，假设扰动项为无自相关，故可用 <span class="math inline">\(OLS\)</span> 进行一致的估计。<strong>然而</strong>， 如果模型为 AR(2)，但却被误设为 AR(1)，则意味着二阶滞后项 <span class="math inline">\(\beta_2 y_{t-2}\)</span> 被纳入扰动项： <span class="math display">\[
y_t = \beta_0 + \beta_1 y_{t-1} + (\beta_2 y_{t-2} + \varepsilon_t)
\]</span> 其中，由于扰动项为 $(<em>2 y</em>{t-2} + _t) $，故扰动项与解释变量 <span class="math inline">\(y_{t-1}\)</span> 相关，因为 <span class="math inline">\(\rm{Cov}(y_{t-1},\ y_{t-2}) \neq 0\)</span>。此时，扰动项存在自相关，<span class="math inline">\(OLS\)</span> 不再一致，需引入 <span class="math inline">\(\beta_2 y_{t-2}\)</span> 才能得到一致估计。</p>
<p>另外，从预测的角度来看，更高阶的滞后项也可能包含有用的信息。为此，更一般地，考虑 $ p$ 阶自回归模型，记为 <span class="math inline">\(AR(p)\)</span>： <span class="math display">\[
y_t = \beta_0 + \beta_1 y_{t-1} + \dots + \beta_p y_{t-p} + \varepsilon_t
\]</span> 其中，扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为白噪声，无自相关，故 <span class="math inline">\(OLS\)</span> 为一致估计。然而，通常我们并不知道滞后期 <span class="math inline">\(p\)</span>。</p>
<p>估计 <span class="math inline">\(\hat{p}\)</span> 的方法：</p>
<ul>
<li><p>设一个最大滞后期 <span class="math inline">\(p_{\max}\)</span>，然后令 $ = p_{} $ 进行估计，并对最后一个滞后期系数的显著性进行 <span class="math inline">\(t\)</span> 检验。</p>
<p>如果接受该系数为 0，则令 $ = p_{} -1 $，重新进行估计，再对最后一个滞后期的系数进行 <span class="math inline">\(t\)</span> 检验。</p></li>
<li><p>使用信息准则，选择 <span class="math inline">\(\hat{p}\)</span> 使得 <span class="math inline">\(AIC\)</span> 或 <span class="math inline">\(BIC\)</span> 最小化，分别记为 <span class="math inline">\(\hat{p}_{AIC}\)</span> 与 <span class="math inline">\(\hat{p}_{BIC}\)</span>。</p></li>
</ul>
<h3 id="自回归分布滞后模型adl">3.1.3 自回归分布滞后模型（ADL）</h3>
<p>在自回归 <span class="math inline">\(AR(p)\)</span> 中，为提高预测力或解释力，可引入其他解释变量，构成 <strong>自回归分布滞后模型</strong>（Autoregressive Distributed Lag Model, ADL(p, 1) or ARDL(p, q)）。 <span class="math display">\[
y_t = \beta_o + \beta_1 y_{t-1} + \dots + \beta_p y_{t-p} + \gamma_1 x_{t-1} + \dots + \gamma_q x_{t-q} + \varepsilon_t
\]</span> 其中，<span class="math inline">\(p\)</span> 为解释变量 <span class="math inline">\(y\)</span> 的自回归阶数，<span class="math inline">\(q\)</span> 为解释变量 <span class="math inline">\(x\)</span> 的滞后阶数。假定扰动项 <span class="math inline">\(\varepsilon_t\)</span> 为白噪声，则 <span class="math inline">\(OLS\)</span> 为一致估计。</p>
<h3 id="误差修正模型ecm">3.1.4 误差修正模型（ECM）</h3>
<p>ADL 是一种动态模型。从经济理论而言，<strong>相关变量之间可能存在长期的均衡关系，而变量的短期变动则是向着这个长期均衡关系的调整</strong>。ECM 正是这一思想在计量经济学中的体现。</p>
<p>考虑 ADL(1, 1) 模型： <span class="math display">\[
y_t = \beta_o + \beta_1 y_{t-1} + \gamma_1 x_{t-1} + \varepsilon_t
\]</span> 其中，<span class="math inline">\(|\beta_1| &lt; 1\)</span>，故为平稳过程。假设经济理论 认为 <span class="math inline">\((y,\ x)\)</span> 之间存在长期均衡关系： <span class="math display">\[
y = \phi + \theta x
\]</span> 其中，<span class="math inline">\(\phi\)</span> 和 <span class="math inline">\(\theta\)</span> 为待定参数。对方程两边求期望，并令 <span class="math inline">\(y^\star = \rm{E}(y_t) = \rm{E}(y_{t-1})\)</span>， <span class="math inline">\(x^\star = \rm{E}(x_t) = \rm{E}(x_{t-1})\)</span>，可得： <span class="math display">\[
y^\star = \frac{\beta_0}{1-\beta_1} + \frac{\gamma_1}{1-\beta_1} x^\star
\]</span> 所以，<span class="math inline">\(\phi = \frac{\beta_0}{1-\beta_1}\)</span>， <span class="math inline">\(\theta = \frac{\gamma_0}{1-\beta_1}\)</span>。其中 $ $ 即为长期程数，衡量当 <span class="math inline">\(x\)</span> 永久性变化 1 单位时，将导致 <span class="math inline">\(y\)</span> 的永久变化幅度。在方程（5）两边同时减去 <span class="math inline">\(y_{t-1}\)</span> 得： <span class="math display">\[
\Delta y_t = (\beta_1 -1)(y_{t-1} - \phi - \theta x_{t-1}) + \varepsilon_t
\]</span> 其中，<span class="math inline">\((y_{t-1} - \phi - \theta x_{t-1})\)</span> 衡量上一期对均衡条件 <span class="math inline">\(y = \phi + \theta x\)</span> 的偏离（误差），而 <span class="math inline">\((\beta_1 -1)(y_{t-1} - \phi - \theta x_{t-1})\)</span> 为根据上期的误差做的反向修正，成为 <code>误差修正项</code>。</p>
<ul>
<li><p>ECM 优点</p>
<p>一般 ADL 模型都可转化为 ECM 模型。ECM 模型经济含义十分明确，而且可以分别考察长期效益（长期均衡关系）与短期效应（误差修正效应）。</p></li>
</ul>
<h1 id="markov-model">4 Markov model</h1>
<h2 id="defination-of-markov-chain">4.1 Defination of Markov Chain</h2>
<p>现实生活中有很多这样的现象，某一系统在已知现在情况的条件下，系统未来时刻的情况只与现在有关，而与过去的历史无直接关系。</p>
<p>如，研究一个商店的累计销售额，如果现在时刻的累计销售额已知，未来某一时刻的累计销售额与现在时刻以前的任一时刻累计销售额无关。</p>
<p>描述这类 <strong>随机现象</strong> 的数学模型称为 <strong>马尔科夫模型</strong>，简称马氏模型</p>
<ul>
<li><strong>定义 1</strong></li>
</ul>
<p>设 <span class="math inline">\(\{\xi_n,\ n = 1,\ 2,\dots \}\)</span> 是一个随机序列，状态空间 <span class="math inline">\(E\)</span> 为有限或可列集，对于任意的正整数 $m, n $，若 <span class="math inline">\(i,\ j,\ ,\ i_k \in E\ (k=1, \dots, n-1)\)</span>，有： <span class="math display">\[
P\{\xi_{n+m} = j | \xi_n = i,\ \xi_{n-1} = i_{n-1}, \dots, \xi_1 = i_1\} = P\{\xi_{n+m} = j | \xi_n = i\}
\]</span> 则称 <span class="math inline">\(\{\xi_{n} , n = 1,\ 2, \dots\}\)</span> 是一个马尔可夫链。式 (9) 也被称为马氏性。</p>
<p>式 (9) 中，可以证明，对于 <span class="math inline">\(m = 1\)</span> 时成立，则它对 <strong>任意</strong> 的正整数 <span class="math inline">\(m\)</span> 都成立。因此，只要当 <span class="math inline">\(m=1\)</span> 式，式 (9) 成立，就可以称随机序列 <span class="math inline">\(\{\xi_n,\ n=1,\ 2, \dots\}\)</span> 具有 <strong>马氏性</strong>，即 <span class="math inline">\(\{\xi_{n} , n = 1,\ 2, \dots\}\)</span> 是一个马尔可夫链。</p>
<ul>
<li><strong>定义 2</strong></li>
</ul>
<p>设 <span class="math inline">\(\{\xi_n,\ n = 1,\ 2,\dots \}\)</span> 是一个马尔科夫链，如果式 (9) 右边的条件概率与 <span class="math inline">\(n\)</span> 无关，即： <span class="math display">\[
P\{\xi_{n+m} = j | \xi_n = i \} = p_{ij}(m)
\]</span> 则称 <span class="math inline">\(\{\xi_n,\ n = 1,\ 2,\dots \}\)</span> 为时齐的马尔可夫链。称 <span class="math inline">\(p_{ij}(m)\)</span> 为系统由状态 <span class="math inline">\(i\)</span> 经过 <span class="math inline">\(m\)</span> 个时间间隔（或 <span class="math inline">\(m\)</span> 步）转移到状态 <span class="math inline">\(j\)</span> 的转移概率。式 (10) 称为时齐性，它的含义式系统由状态 <span class="math inline">\(i\)</span> 到 状态 <span class="math inline">\(j\)</span> 的转移概率 <strong>只依赖与时间间隔的长短</strong>，与起始时刻无关。本章介绍的马尔可夫链都是时齐的，因此省略 <code>时齐</code> 二字。</p>
<h2 id="转移概率矩阵及柯尔莫哥洛夫定理">4.2 转移概率矩阵及柯尔莫哥洛夫定理</h2>
<h3 id="转移概率矩阵">4.2.1 转移概率矩阵</h3>
<p>对于马尔科夫链 <span class="math inline">\(\{\xi_n,\ n = 1,\ 2,\dots \}\)</span> ，称以 <span class="math inline">\(m\)</span> 步转移概率 <span class="math inline">\(p_{ij}(m)\)</span> 为元素的矩阵 <span class="math inline">\(P (m) = p_{ij}(m)\)</span> 为马尔科夫链的 <strong>$ m$ 步转移概率矩阵</strong>。当 <span class="math inline">\(m = 1\)</span>时，记 <span class="math inline">\(P(1) = P\)</span> 称为马尔可夫链的 <strong>一步转移矩阵</strong>，或简称 <strong>转移矩阵</strong>。</p>
<p>转移矩阵具有如下性质：</p>
<ul>
<li>对一切 $i, j E, 0 p_{ij}(m)  $，</li>
<li>对一切 $i E, <em> p</em>{ij}(m) = 1 $，-</li>
<li>对一切 <span class="math inline">\(i,\ j \in E, p_{ij}(0) = \delta_{ij} = \left\{\begin{array}{k}1,\ (i = j) \\ 0,\ (i \neq j) \end{array}\right.\)</span></li>
</ul>
<p>当实际问题可以用马尔可夫链来描述时，首先要确定它的 <strong>状态空间及参数集合</strong>，然后确定它的 <strong>一步转移概率</strong>。该概率的确定，可以由问题的 <strong>内在规律</strong> 得到，也可以由过去的经验给出，还可以根据 <strong>预测数据</strong> 来估计。案例可见 4.4 Cases 的 Case 1。</p>
<h3 id="柯尔莫哥洛夫定理">4.2.2 柯尔莫哥洛夫定理</h3>
<ul>
<li>柯尔莫哥洛夫- 开普曼定理</li>
</ul>
<p>设 <span class="math inline">\(\{\xi_n,\ n = 1,\ 2,\dots \}\)</span> 是一个马尔可夫链，其状态空间 <span class="math inline">\(E = \{1,\ 2,\dots\}\)</span>，则对任意正整数 <span class="math inline">\(m,\ n\)</span>，有： <span class="math display">\[
p_{ij}(n+m) = \sum_{k \in E} p_{ik}(n)p_{kj}(m)
\]</span> 其中：<span class="math inline">\(i,\ j \in E\)</span>。</p>
<ul>
<li><strong>定理</strong></li>
</ul>
<p>设 <span class="math inline">\(P\)</span> 是一步马尔科夫链转移矩阵（ <span class="math inline">\(P\)</span> 的行向量是概率向量），<span class="math inline">\(P^{(0)}\)</span> 是初始分布行向量，则第 <span class="math inline">\(n\)</span> 步的 <strong>概率分布</strong> 为： <span class="math display">\[
P^{(n)} = P^{(0)} P^n
\]</span></p>
<h2 id="转移概率的渐近性质极限概率分布">4.3 转移概率的渐近性质—极限概率分布</h2>
<h3 id="introduction-3">4.3.1 Introduction</h3>
<ul>
<li>随着 <span class="math inline">\(n\)</span> 的增大，<span class="math inline">\(P^n\)</span> 是否会趋于某以固定矩阵？</li>
</ul>
<p>先考虑一个简单的例子：</p>
转移矩阵 $ P =
<span class="math display">\[\begin{bmatrix}
0.5 &amp; 0.5 \\
0.7 &amp; 0.3 \\
\end{bmatrix}\]</span>
$，当 <span class="math inline">\(n \rightarrow + \infty\)</span>，有： <span class="math display">\[
P^n \rightarrow \begin{bmatrix} \frac{7}{12} &amp; \frac{5}{12}\\
\frac{7}{12} &amp; \frac{5}{12} \\
\end{bmatrix}
\]</span> 若取 $ u =
<span class="math display">\[\begin{bmatrix} \frac{7}{12} &amp; \frac{5}{12}\\
\frac{7}{12} &amp; \frac{5}{12} \\
\end{bmatrix}\]</span>
<p>$，则 <span class="math inline">\(uP = u\)</span>，<span class="math inline">\(u^T\)</span> 为矩阵 <span class="math inline">\(P^T\)</span> 的对应于特征值为 <span class="math inline">\(\lambda = 1\)</span> 的特征（概率）向量，<span class="math inline">\(u\)</span> 也称为 <span class="math inline">\(P\)</span> 的不动点向量。</p>
<ul>
<li><p>哪些转移矩阵具有不动点向量？</p>
<p><strong>定义：</strong>马尔可夫链的转移矩阵 <span class="math inline">\(P\)</span> 是正则 <span class="math inline">\(\Leftrightarrow \ \exist\ k \in N^+\)</span>，使 <span class="math inline">\(P^k\)</span> 任一元素都为正</p>
<p><strong>定理：</strong>若 <span class="math inline">\(P\)</span> 是一个马尔科夫链的正则阵，则：</p>
<ul>
<li><span class="math inline">\(P\)</span> 有 <strong>唯一</strong> 的不动点向量 <span class="math inline">\(W,\ W\)</span> 的每个分量都为正；</li>
<li><span class="math inline">\(P\)</span> 的 <span class="math inline">\(n\)</span> 次幂 <span class="math inline">\(P^n\)</span>（ <span class="math inline">\(n\)</span> 为正整数）随 <span class="math inline">\(n\)</span> 的增加趋于矩阵 <span class="math inline">\(\overline{W},\ \overline{W}\)</span> 的每一行向量<strong>均等于不动点向量</strong> <span class="math inline">\(W\)</span>。</li>
</ul></li>
</ul>
<p>设时齐马尔科夫链的状态空间为 <span class="math inline">\(E\)</span>，如果对于所有 <span class="math inline">\(i,\ j \in E\)</span>，转移概率 <span class="math inline">\(p_{ij}(n)\)</span> 存在极限： <span class="math display">\[
\lim_{n\to \infty}p_{ij}(n) = \pi_j\quad (\text{不依赖于 }i)
\]</span> 或： <span class="math display">\[
P(n) = P^n \underset{(n\to \infty)}{\longrightarrow} \begin{bmatrix} \pi_1 &amp; \pi_2 &amp; \dots &amp; \pi_j &amp; \dots \\
\pi_1 &amp; \pi_2 &amp; \dots &amp; \pi_j &amp; \dots \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots \\
\pi_1 &amp; \pi_2 &amp; \ddots &amp; \pi_j &amp; \dots \\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \ddots \\
\end{bmatrix}
\]</span> 则称此链具有 <strong>遍历性</strong>。若 <span class="math inline">\(\sum_\limits j \pi_j = 1\)</span>，则同时称 <span class="math inline">\(\vec {\pi} = [\pi_1,\  \pi_2, \dots]\)</span> 为链的 <strong>极限分布</strong>。</p>
<ul>
<li><p>就有限链的遍历性给出一个充分条件：</p>
<p><strong>定理：</strong>设时齐马尔可夫链 <span class="math inline">\(\{\xi_n,\ n = 1,\ 2,\dots \}\)</span> 的状态空间为 <span class="math inline">\(E = \{a_1,\dots,\ a_N\},\ P = (p_{ij})\)</span> 是它的一步转移矩阵，如果存在正整数 <span class="math inline">\(m\)</span>，使对任意的 <span class="math inline">\(a_i,\ a_j \in E\)</span>，都有： <span class="math display">\[
p_{ij}(m) &gt; 0,\ i, j = 1, 2, \dots, N
\]</span> 则此链具有 <strong>遍历性</strong>；且有极限分布 <span class="math inline">\(\vec \pi = [\pi_i, \dots, \pi_N]\)</span>，他是方程组： <span class="math display">\[
\pi = \pi P\quad or \pi_j = \sum_{i=1}^N \pi_i p_{ij}, \ j = 1, \dots,\ N
\]</span> 的满足条件 <span class="math inline">\(\pi_j &gt; 0,\ \sum_\limits{j=1}^N \pi_j = 1\)</span> 的唯一解。</p></li>
</ul>
<h2 id="cases">4.4 Cases</h2>
<ul>
<li><strong>Case 1:</strong></li>
</ul>
<p>某计算机机房的一台计算机经常出故障，研究者每隔15 分钟观察一次计算 机的运行状态，收集了24 小时的数据（共作97 次观察）。用1 表示正常状态，用0 表示不正常状态，所得的数据序列如下：</p>
<p>1110010011111110011110111111001111111110001101101 111011011010111101110111101111110011011111100111</p>
<p><strong>解：</strong>设 <span class="math inline">\(X_n (n = 1,\dots,97)\)</span> 为第 <span class="math inline">\(n\)</span> 个时段的计算机状态，可以认为它是一个时齐马氏链，状态空间 <span class="math inline">\(E = \{0,\ 1\}\)</span>，编写如下 <span class="math inline">\(Matlab\)</span> 程序：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a1=<span class="string">&#x27;1110010011111110011110111111001111111110001101101&#x27;</span>;</span><br><span class="line">a2=<span class="string">&#x27;111011011010111101110111101111110011011111100111&#x27;</span>;</span><br><span class="line">a=[a1 a2];</span><br><span class="line">f00=<span class="built_in">length</span>(findstr(<span class="string">&#x27;00&#x27;</span>,a))</span><br><span class="line">f01=<span class="built_in">length</span>(findstr(<span class="string">&#x27;01&#x27;</span>,a))</span><br><span class="line">f10=<span class="built_in">length</span>(findstr(<span class="string">&#x27;10&#x27;</span>,a))</span><br><span class="line">f11=<span class="built_in">length</span>(findstr(<span class="string">&#x27;11&#x27;</span>,a))</span><br></pre></td></tr></table></figure>
<p>Result:</p>
<p>求得 96 次的转移情况是： <span class="math display">\[
\left\{
\begin{array}{c}
0 \rightarrow 0,\ \ 8 \text{次}; \qquad\ 0 \rightarrow 1,\ 18 \text{次} \\
1 \rightarrow 0,\ 18 \text{次}; \qquad 1 \rightarrow 1,\ 52 \text{次}
\end{array}
\right.
\]</span> 因此，一步转移概率可用频率近似地表示为： <span class="math display">\[
\left\{
\begin{array}{c}
P_{00} = P\{X_{n+1} = 0 | X_n = 0 \} \approx \frac{8}{8 + 18} = \frac{4}{13} \\
P_{01} = P\{X_{n+1} = 1 | X_n = 0 \} \approx \frac{18}{8 + 18} = \frac{9}{13} \\
P_{10} = P\{X_{n+1} = 0 | X_n = 1 \} \approx \frac{18}{18 + 52} = \frac{9}{35} \\
P_{11} = P\{X_{n+1} = 1 | X_n = 1 \} \approx \frac{52}{18 + 52} = \frac{26}{35} 
\end{array}
\right.
\]</span></p>
<ul>
<li><strong>Case 2:</strong></li>
</ul>
<p>若顾客的购买是无记忆的，即已知现在顾客购买情况，未来顾客的购买情况不受过去购买历史的影响，而只与现在购买情况有关。现在市场上供应 <span class="math inline">\(A,\ B,\ C\)</span> 三个不同厂家生产的 50 克袋装味精，用 <span class="math inline">\(\xi_n = 1,\ \xi_n, \ \xi_n = 3\)</span> 分别表示”顾客第 <span class="math inline">\(n\)</span> 次购买 <span class="math inline">\(A,\ B,\ C\)</span> 厂的味精”。显然，<span class="math inline">\(\{\xi_n, n = 1,\ 2,\dots\}\)</span> 是一个马氏链。若已知第一次顾客购买三个厂味精的概率依次为 <span class="math inline">\(0.2,\ 0.4,\ 0.4\)</span>。又知道一般顾客购买的倾向由表2给出。求</p>
<p>1）顾客第四次购买各家味精的概率；</p>
<p>2）预测经过长期的多次购买滞后，顾客的购买倾向如何？</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">A</td>
<td style="text-align: center;">0.8</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">0.1</td>
</tr>
<tr class="even">
<td style="text-align: center;">B</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">0.1</td>
<td style="text-align: center;">0.4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">C</td>
<td style="text-align: center;">0.5</td>
<td style="text-align: center;">0.3</td>
<td style="text-align: center;">0.2</td>
</tr>
</tbody>
</table>
<p>解：</p>
<p>1）第一次购买的概率分布为：<span class="math inline">\(P^{(1)} = [0.2,\ 0.4,\ 0.4]\)</span>，一步状态转移矩阵为：</p>
<p><span class="math inline">\(P = \begin{bmatrix}0.8 &amp; 0.1 &amp; 0.1 \\ 0.5 &amp; 0.1 &amp; 0.4 \\ 0.5 &amp; 0.3 &amp; 0.2\\\end{bmatrix}\)</span>，则顾客第四次购买各家味精的概率为： <span class="math display">\[
P^{(4)} = P^{(1)} P^3 = [0.7004, 0.136, 0.1636]
\]</span> 2）这个马尔可夫链的转移矩阵 <span class="math inline">\(P\)</span> 满足 <span class="math inline">\(p_{ij}(m) &gt; 0,\ i,\ j = 1, 2,\dots, N\)</span>，可以求出其极限概率分布。为此，解下列方程组： <span class="math display">\[
\left\{
\begin{array}{l}
p_1 = 0.2p_1 + 0.8p_2 + 0.1p_3,\\
p_2 = 0.8p_1 + 0.3p_3, \\
p_3 = 0.2p_2 + 0.6p_3, \\
p_1 + p_2 + p_3 = 1,
\end{array}
\right.
\]</span> 求得 <span class="math inline">\(p_1 = \frac{5}{7},\ p_2 = \frac{11}{84},\ p_3 = \frac{13}{84}\)</span>。这说明，无论第一次顾客购买的情况如何，经过长期多次购买后，<span class="math inline">\(A\)</span> 厂产的味精占有市场的 <span class="math inline">\(\frac{5}{7}\)</span>，<span class="math inline">\(B,\ C\)</span> 两厂的产品分别占有市场的 <span class="math inline">\(\frac{11}{84}\)</span> 和 <span class="math inline">\(\frac{13}{84}\)</span>。</p>
<p>Relative codes:</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">format <span class="built_in">rat</span></span><br><span class="line">p=[<span class="number">0.8</span> <span class="number">0.1</span> <span class="number">0.1</span>;<span class="number">0.5</span> <span class="number">0.1</span> <span class="number">0.4</span>;<span class="number">0.5</span> <span class="number">0.3</span> <span class="number">0.2</span>];</span><br><span class="line">a=[p&#x27;-<span class="built_in">eye</span>(<span class="number">3</span>);<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>)];</span><br><span class="line">b=[<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);<span class="number">1</span>];</span><br><span class="line">p_limit=a\b</span><br></pre></td></tr></table></figure>
<p>或者利用求转移矩阵 <span class="math inline">\(P\)</span> 的转置矩阵 <span class="math inline">\(P^T\)</span> 的特征值 1 对应的特征(概率)向量，求得极 限概率。编写程序如下：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc,clear</span><br><span class="line">p=[<span class="number">0.8</span> <span class="number">0.1</span> <span class="number">0.1</span>;<span class="number">0.5</span> <span class="number">0.1</span> <span class="number">0.4</span>;<span class="number">0.5</span> <span class="number">0.3</span> <span class="number">0.2</span>];</span><br><span class="line">p=sym(p&#x27;);</span><br><span class="line">[x,y]=eig(p)</span><br><span class="line">y=<span class="built_in">diag</span>(y);y=double(y);</span><br><span class="line">ind=<span class="built_in">find</span>(y==<span class="built_in">max</span>(y));</span><br><span class="line">p=x(:,ind)/sum(x(:,ind))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Class Notes</category>
        <category>Methods</category>
      </categories>
      <tags>
        <tag>Deep learning</tag>
        <tag>Prediction</tag>
      </tags>
  </entry>
  <entry>
    <title>Econometrics</title>
    <url>/2020/12/15/Econometrics/</url>
    <content><![CDATA[<h1 id="introduction">1 Introduction</h1>
<p>本文为参考洪永淼老师《高级计量学》复习高级计量经济学的学习笔记。</p>
<a id="more"></a>
<h1 id="一般回归分析和模型设定">2 一般回归分析和模型设定</h1>
<h2 id="条件概率分别">2.1 条件概率分别</h2>
<ul>
<li><p>边际概率密度函数 （<span class="math inline">\(\rm{P}_{18}\)</span>） <span class="math display">\[
\begin{align*}
f_x(x) = \int_{-\infty}^\infty f_{XY}(x,y)\rm{d}y
\end{align*}
\]</span></p></li>
<li><p>给定 <span class="math inline">\(X = x\)</span>，<span class="math inline">\(Y\)</span> 的条件概率密度函数 （<span class="math inline">\(\rm{P}_{18}\)</span>） <span class="math display">\[
\begin{align*}
f_{Y|X}(y|x) = \frac{f_{XY}(x,y)}{f_X{(x)}}
\end{align*}
\]</span></p></li>
<li><p>条件均值（<span class="math inline">\(\rm{P}_{19}\)</span>） <span class="math display">\[
\begin{align*}
E(Y|x) \equiv E(Y|X=x) = \int_{-\infty}^{\infty} y f_{Y|X}(y|x)\rm{d}y
\end{align*}
\]</span></p></li>
<li><p>条件方差（<span class="math inline">\(\rm{P}_{19}\)</span>） <span class="math display">\[
\begin{align*}
var(Y|x) \equiv var(Y|X=x) &amp;= \int_{-\infty}^{\infty} [y-E(Y|x)]^2f_{Y|X}(y|x)\rm{d}y  \\
&amp;= E(Y^2|x)-[E(Y|x)]^2
\end{align*}
\]</span></p></li>
<li><p>条件偏度（Conditional skewness）（<span class="math inline">\(\rm{P}_{19}\)</span>） <span class="math display">\[
\begin{align*}
S(Y|x) \equiv \frac{E[(Y-E(Y|x))^3|x)}{[var(Y|x)]^{3/2}}
\end{align*}
\]</span></p></li>
<li><p>条件峰度（Conditional kurtosis）（<span class="math inline">\(\rm{P}_{19}\)</span>） <span class="math display">\[
\begin{align*}
K(Y|x) \equiv \frac{E[(Y-E(Y|x))^4|x)}{[var(Y|x)]^{2}}
\end{align*}
\]</span></p></li>
<li><p>条件 $$ - 分位数（Conditional <span class="math inline">\(\alpha\)</span>-quantile）（<span class="math inline">\(\rm{P}_{19}\)</span>） <span class="math display">\[
\begin{align*}
P[Y \leq Q(X, \alpha)|X = x] = \alpha \in (0,1)
\end{align*}
\]</span></p></li>
</ul>
<h2 id="条件均值与回归分析">2.2 条件均值与回归分析</h2>
<h3 id="定义">2.2.1 定义</h3>
<ul>
<li><strong>定义 2.1</strong>（<span class="math inline">\(\rm{P}_{20}\)</span>）&lt; 回归函数 (Regression Function) &gt;：条件均值 <span class="math inline">\(E(Y|X)\)</span> 成为 <span class="math inline">\(Y\)</span> 对 <span class="math inline">\(X\)</span> 的回归函数;</li>
</ul>
<h3 id="定理">2.2.2 定理</h3>
<ul>
<li><p><strong>定理 2.1</strong>（<span class="math inline">\(\rm{P}_{21}\)</span>）：<span class="math inline">\(E(E(Y|X)) = E(Y)\)</span>；</p></li>
<li><p><strong>定理 2.2</strong>（<span class="math inline">\(\rm{P}_{21}\)</span>） &lt; 重复期望法则 (Law of Interated Expectations, LIE) &gt;：对给定的可测函数 <span class="math inline">\(G(X,Y)\)</span>，假设期望 <span class="math inline">\(E[G(X,Y)]\)</span> 存在，则： <span class="math display">\[
\begin{align*}
E[G(X, Y)] = E\{E[G(X,Y)|X])\}
\end{align*}
\]</span></p></li>
<li><p><strong>定理 2.3</strong>（<span class="math inline">\(\rm{P}_{23}\)</span>）&lt; <span class="math inline">\(MSE\)</span> 最优解 &gt;：条件均值 <span class="math inline">\(E(Y|X)\)</span> 是下列问题的最优解： <span class="math display">\[
\begin{align*}
E(Y|X = \arg \min_{g\ \in\ \mathbb{F}} E[Y - g(X)]^2
\end{align*}
\]</span> 其中，<span class="math inline">\(\mathbb{F}\)</span> 是所有可测和平方可积函数的集合 (Space of all measurable and quare-integrable functions)，即： <span class="math display">\[
\begin{align*}
\mathbb{F} = \left\{g:\mathbb{R}^{k+1} \to \mathbb{R}\ |\int g^2(x) f_X(x) \rm{b}x &lt; \infty \right\}
\end{align*}
\]</span> &lt; 注：可通过中间变量 <span class="math inline">\(g_0(X) \equiv E(Y|X)\)</span> 证明 &gt;</p></li>
<li><p><strong>定理 2.4</strong>（<span class="math inline">\(\rm{P}_{25}\)</span>）&lt; 回归等式 (Regression Identity) &gt;：给定条件均值 <span class="math inline">\(E(Y|X)\)</span>，总有： <span class="math display">\[
\begin{align*}
Y = E(Y|X) + \varepsilon
\end{align*}
\]</span> 其中，<span class="math inline">\(\varepsilon\)</span> 称为回归扰动项（Regression disturbance），满足： <span class="math display">\[
\begin{align*}
E(\varepsilon|X) = 0
\end{align*}
\]</span></p></li>
</ul>
<h2 id="线性回归建模">2.3 线性回归建模</h2>
<h3 id="定义-1">2.3.1 定义</h3>
<ul>
<li><p><strong>定义 2.3</strong>（<span class="math inline">\(\rm{P}_{29}\)</span>）&lt; 仿射函数 (Affine Function) &gt;：记 <span class="math inline">\(X = (1, X_1, \dots , X_k)^\prime\)</span>，<span class="math inline">\(\beta = (\beta_0, \beta_1, \dots, \beta_k)^\prime\)</span>。则仿射函数族定义为： <span class="math display">\[
\begin{align*}
\mathbb{A} &amp;= \left\{ g:\mathbb{R}^{k+1} \to \mathbb{R}\ |\ g(X) = \beta_0 + \sum_{j=1}^{k} \beta_jX_j, \beta_j \in \mathbb{R} \right\} \\
&amp;= \left\{ g:\mathbb{R}^{k+1} \to \mathbb{R}\ |\ g(X) = X^\prime\beta \right\}
\end{align*}
\]</span> 这里，对参数向量 <span class="math inline">\(\beta\)</span> 的值没有限制。对于这族函数，函数形式一致，分别是解释变量和参数 <span class="math inline">\(\beta\)</span> 的线性函数；</p></li>
<li><p><strong>定义 2.4</strong>（<span class="math inline">\(\rm{P}_{32}\)</span>）&lt; 线性回归模型 (Linear Regression Model) &gt;：方程： <span class="math display">\[
\begin{align*}
Y = X^\prime \beta + u, \beta \in \mathbb{R}^{k+1}
\end{align*}
\]</span> 称为 <span class="math inline">\(Y\)</span> 对 <span class="math inline">\(X\)</span> 的线性回归模型，其中 <span class="math inline">\(u\)</span> 是回归模型误差 (Regression model error)。如果 <span class="math inline">\(k=1\)</span>，称为二元线性回归模型 (Bivariate linear regression model) 或直线回归模型 (Straight linere gression model)。如果 <span class="math inline">\(k&gt;1\)</span>，则称为多元线性回归模型 (Multiple linear regression model)；</p></li>
</ul>
<h3 id="定理-1">2.3.2 定理</h3>
<ul>
<li><p><strong>定理 2.5</strong>（<span class="math inline">\(\rm{P}_{30}\)</span>）&lt; 最优线性最小二乘预测 (Best Linear Least Squares Predictstion) &gt; ：假设<span class="math inline">\(E(Y^2) &lt; \infty\)</span>，且<span class="math inline">\((k+1) \times (k+1)\)</span> 矩阵 <span class="math inline">\(E(X^\prime X)\)</span> 是非奇异的。则以下优化问题： <span class="math display">\[
\begin{align*}
\min_{g\ \in\ \mathbb{A} }E[Y - g(X)]^2 = \min_{\beta\ \in \mathbb{R}^{k+1}}E(Y - X^\prime \beta)^2
\end{align*}
\]</span> 的解，即最优线性最小二乘法预测值为： <span class="math display">\[
\begin{align*}
g^*(X) = X^\prime\beta^*
\end{align*}
\]</span> 其中最优系数向量为（<span class="math inline">\(\star \star \star\)</span>）： <span class="math display">\[
\begin{align*}
\beta^* = [E(X X^\prime)]^{-1}E(XY)
\end{align*}
\]</span></p></li>
<li><p><strong>定理 2.6</strong>（<span class="math inline">\(\rm{P}_{32}\)</span>）：假设定理 2.5 的条件成立。令： <span class="math display">\[
\begin{align*}
Y =  X^\prime \beta + u
\end{align*}
\]</span> 并令 <span class="math inline">\(\beta^* = [E(XX^\prime)]^{-1}E(XY)\)</span> 为最优线性最小二乘近似系数。则： <span class="math display">\[
\begin{align*}
\beta = \beta^*
\end{align*}
\]</span> 当且仅当以下正交条件成立： <span class="math display">\[
\begin{align*}
E(Xu) = 0
\end{align*}
\]</span></p></li>
</ul>
<h2 id="条件均值的模型设定">2.4 条件均值的模型设定</h2>
<h3 id="定义-2">2.4.1 定义</h3>
<ul>
<li><strong>定义 2.5</strong>（<span class="math inline">\(\rm{P}_{34}\)</span>）&lt; 条件均值模型的正确设定 &gt;：线性回归模型： <span class="math display">\[
\begin{align*}
Y = X^\prime \beta + u, \beta \in \mathbb{R^{k+1}}
\end{align*}
\]</span> 是条件均值 <span class="math inline">\(E(Y|X)\)</span> 的正确设定，如果存在某个参数值 <span class="math inline">\(\beta^o \in \mathbb{R^{k+1}}\)</span>，有： <span class="math display">\[
\begin{align*}
E(Y|X) = X^\prime \beta^o
\end{align*}
\]</span> 另一方面，如果对于任意的参数值 <span class="math inline">\(\beta \in \mathbb{R^{k+1}}\)</span>， <span class="math display">\[
\begin{align*}
E(Y|X) \neq X^\prime \beta
\end{align*}
\]</span> 则称线性回归模型是对 <span class="math inline">\(E(Y|X)\)</span> 的错误设定 (Misspecified)；</li>
</ul>
<h3 id="定理-2">2.4.2 定理</h3>
<ul>
<li><p><strong>定理 2.7</strong>（<span class="math inline">\(\rm{P}_{35}\)</span>）：如果线性回归模型： <span class="math display">\[
\begin{align*}
Y =  X^\prime \beta + u
\end{align*}
\]</span> 是对条件均值<span class="math inline">\(E(Y|X)\)</span> 的正确设定则：</p>
<p>1）存在一个参数 <span class="math inline">\(\beta^o\)</span> 和一个随机变量 <span class="math inline">\(\varepsilon\)</span>，有 <span class="math inline">\(Y = X^\prime \beta^o+\varepsilon\)</span>，其中 <span class="math inline">\(E(\varepsilon|X) = 0\)</span>；</p>
<p>2）<span class="math inline">\(\beta^* = \beta^o\)</span></p></li>
</ul>
<h1 id="经典线性回归模型">3. 经典线性回归模型</h1>
<h2 id="假设">3.1 假设</h2>
<ul>
<li><p><strong>假设 3.1</strong>（<span class="math inline">\(\rm{P}_{45}\)</span>）&lt; 线性 (Linearity) &gt;：<span class="math inline">\(\{Y_t, X_t^\prime\}_{t=1}^n\)</span> 是一个可观测的随机样本，且： <span class="math display">\[
Y_t = X_t^\prime \beta^o + \varepsilon_t, t = 1, \dots, n
\]</span> 其中，<span class="math inline">\(\beta^o\)</span> 是一个 <span class="math inline">\(K \times 1\)</span> 未知参数向量，<span class="math inline">\(\varepsilon_t\)</span> 是一个不可观测的随机扰动项；</p>
<p>令： <span class="math display">\[
\begin{align*}
Y &amp; = (Y_1, \dots , Y_n)^\prime, &amp;n \times 1 \\
\varepsilon &amp; = (\varepsilon_1, \dots , \varepsilon_n)^\prime, &amp;n \times 1 \\
X &amp; = (X_1, \dots , X_n)^\prime, &amp;n \times K \\
\end{align*}
\]</span> 这里 <span class="math inline">\(X\)</span> 的第 <span class="math inline">\(t\)</span> 行是 <span class="math inline">\(K\)</span> 维行向量 <span class="math inline">\(X_t^\prime = (1, X_{1t},\dots,X_{kt})\)</span>。从而，(1) 式可以表示为： <span class="math display">\[
\begin{align*}
Y = X \beta^o + \varepsilon
\end{align*}
\]</span></p></li>
<li><p><strong>假设 3.2</strong>（<span class="math inline">\(\rm{P}_{46}\)</span>）&lt; 严格外生性 (Strict Exogeneity) &gt;：<span class="math inline">\(\{Y_t, X_t^\prime\}_{t=1}^n\)</span> <span class="math display">\[
\begin{align*}
E(\varepsilon_t|X) = E(\varepsilon_t|X_1, \dots, X_t,\dots,X_n) = 0 \qquad t = 1,\dots,n
\end{align*}
\]</span> 这一假设隐含着 <span class="math inline">\(E(Y_t|X_t)\)</span> 的模型设定正确；</p></li>
<li><p><strong>假设 3.3</strong>（<span class="math inline">\(\rm{P}_{48}\)</span>）&lt; 非奇异性 (Nonsingularity) &gt;：</p>
<p>1）<span class="math inline">\(K \times K\)</span> 方阵 <span class="math inline">\(X^\prime X = \sum_\limits{t=1}^n X_t X_t^\prime\)</span> 是非奇异的（排除了 <span class="math inline">\(X_t\)</span> 中存在多重共线性）；</p>
<p>2）当 <span class="math inline">\(n \to \infty\)</span> 时，<span class="math inline">\(X^\prime X\)</span> 的最小特征值: <span class="math display">\[
\begin{align*}
\lambda_{min}(X^\prime X) \to \infty
\end{align*}
\]</span> 的概率为 1;</p></li>
<li><p><strong>假设 3.4</strong>（<span class="math inline">\(\rm{P}_{49}\)</span>）&lt; 球形误差方差 (Spherical Error Variance) &gt;：</p>
<p>1）条件同方差: <span class="math display">\[
\begin{align*}
E(\varepsilon_t^2|X) = \sigma^2 &gt; 0, \quad t =1,\dots,n
\end{align*}
\]</span> 2）条件不相关： <span class="math display">\[
\begin{align*}
E(\varepsilon_t\varepsilon_s|X) = 0, t \neq s, \quad t,s \in \{1,\dots,n\}
\end{align*}
\]</span> 上述可写为： <span class="math display">\[
\begin{align*}
E(\varepsilon_t\varepsilon_s|X) = \sigma^2 \delta_{ts}, t \neq s, \quad t,s \in \{1,\dots,n\}
\end{align*}
\]</span> 其中，<span class="math inline">\(\delta_{ts} = 1\)</span> 当且仅当 <span class="math inline">\(t=s\)</span>；</p></li>
</ul>
<h3 id="总结">3.1.1 总结</h3>
<p>给定假设 3.2 和 3.4 意味着 <span class="math inline">\(\varepsilon_t\)</span> 存在条件同方差，即： <span class="math display">\[
\begin{align*}
var(\varepsilon_t|X) = E(\varepsilon_t^2|X) - [E(\varepsilon_t|X)]^2 = E(\varepsilon_t^2|X) = \sigma^2
\end{align*}
\]</span> 同样的，对于所有的 <span class="math inline">\(t \neq s\)</span>，有： <span class="math display">\[
\begin{align*}
cov(\varepsilon_t,\varepsilon_s|X) = E(\varepsilon_t\varepsilon_s|X) = 0
\end{align*}
\]</span> 如果 <span class="math inline">\(t\)</span> 表示个体单元，这意味着 <strong>横截面不相关</strong>，如果 <span class="math inline">\(t\)</span> 表示时间，这意味着 <strong>序列不相关</strong>，为方便起见，这两种情况均称为 <span class="math inline">\(\{\varepsilon_t\}\)</span> <strong>不存在自相关</strong>；</p>
<h2 id="普通最小二乘法">3.2 普通最小二乘法</h2>
<h3 id="定义-3">3.2.1 定义</h3>
<ul>
<li><p><strong>定义 3.1</strong>（<span class="math inline">\(\rm{P}_{50}\)</span>）&lt; <span class="math inline">\(OLS\)</span> 估计量 &gt;：定义线性回归模型 <span class="math inline">\(Y_t = X_t^\prime \beta + u_t\)</span> 的残差平方和 (Sum of squared residuals, SSR) 为： <span class="math display">\[
\begin{align*}
SSR(\beta) \equiv (Y - X\beta)^\prime(Y - X\beta) = \sum_{t=1}^{n}(Y_t - X_t^\prime\beta)^2
\end{align*}
\]</span> 则普通最小二乘法 ( <span class="math inline">\(OLS\)</span> ) 估计量 <span class="math inline">\(\hat\beta\)</span> 是以下优化问题的解： <span class="math display">\[
\begin{align*}
\hat \beta = \arg \min_{\beta\ \in \mathbb{R}^K} SSR(\beta)
\end{align*}
\]</span></p></li>
<li></li>
</ul>
<h3 id="定理-3">3.2.2 定理</h3>
<ul>
<li><p><strong>定理 3.1</strong>（<span class="math inline">\(\rm{P}_{50}\)</span>）&lt; <span class="math inline">\(OLS\)</span> 的存在性 &gt;：在假设 3.1 和 3.3 (1) 下， <span class="math inline">\(OLS\)</span> 估计量 <span class="math inline">\(\hat \beta\)</span> 存在，并且： <span class="math display">\[
\begin{align*}
\hat \beta &amp;= (X^\prime  X)^{-1} \frac{1}{n} \sum_{t=1}^{n} X_t Y_t \\
 &amp; = \left\{\frac{1}{n} \sum_{t = 1}^{n} X_t X_t^\prime\right\}^{-1} \frac{1}{n} \sum_{t=1}^{n} X_t Y_t
\end{align*}
\]</span> 其中第二个表达式在后面章节的渐近分析中将经常用到。</p>
<p><strong>注：</strong> <span class="math inline">\(\hat Y_t \equiv X_t^\prime \hat\beta\)</span> 称为观测值 <span class="math inline">\(Y_t\)</span> 的 <strong>拟合值或者预测值</strong>，而 <span class="math inline">\(e_t \equiv Y_t - \hat Y_t\)</span> 是观测值 <span class="math inline">\(Y_t\)</span> 的 <strong>估计残差或预测误差</strong>。被解释变量 <span class="math inline">\(Y_t\)</span> 可以分解为相互正交的拟合值 <span class="math inline">\(\hat Y\)</span> 与残差 <span class="math inline">\(e\)</span> 之和，参见 Fig. 3-1。</p>
<p><img src="https://s3.ax1x.com/2020/12/21/r03CND.jpg" alt="微信图片_20201218101116" style="zoom:80%;" /></p>
<center>
<p>Fig. 3-1 OLS 的正交性</p>
</center></li>
<li><p><strong>定理 3.2</strong>（<span class="math inline">\(\rm{P}_{52}\)</span>）：给定假设 3.1 和 3.3 (1)，有：</p>
<ol type="1">
<li><p><span class="math display">\[
\begin{align*}
X ^\prime e = 0
\end{align*}
\]</span></p></li>
<li><p><span class="math display">\[
\begin{align*}
\hat \beta - \beta^o = (X^\prime X)^{-1}X^{\prime}\varepsilon
\end{align*}
\]</span> <strong>注：</strong>上式可变为 <span class="math inline">\(C\varepsilon\)</span>，其中 <span class="math inline">\(C\)</span> 是权重向量，因此，给定 <span class="math inline">\(X, \hat\beta-\beta^o\)</span> 是 <span class="math inline">\(\varepsilon\)</span> 的线性组合，当 <span class="math inline">\(\varepsilon\)</span> 服从联合正态分布时，<span class="math inline">\(\hat\beta-\beta^o\)</span> 也服从正态分布。</p></li>
<li><p>定义 <span class="math inline">\(n \times n\)</span> 投影矩阵 <span class="math display">\[
\begin{align*}
P = X(X^\prime X)^{-1}X^{\prime}
\end{align*}
\]</span> 和 <span class="math display">\[
\begin{align*}
M = I_n - P
\end{align*}
\]</span> 则 <span class="math inline">\(P\)</span> 和 <span class="math inline">\(M\)</span> 是对称的（即 <span class="math inline">\(P = P^{\prime},\ M = M^{\prime}\)</span>）幂等矩阵（即 <span class="math inline">\(P = P^{2},\ M = M^{2}\)</span>），并且 <span class="math display">\[
\begin{align*}
PX = X \\
MX = 0
\end{align*}
\]</span></p></li>
<li><p><span class="math display">\[
\begin{align*}
SSR(\hat \beta) = e^\prime e = Y^{-1} MY = \varepsilon^{\prime} M \varepsilon
\end{align*}
\]</span> <strong>注：</strong><span class="math inline">\(e = M \varepsilon\)</span>（<span class="math inline">\(\star\star\star\)</span>）</p></li>
</ol></li>
</ul>
<h2 id="拟合优度和模型选择准则">3.3 拟合优度和模型选择准则</h2>
<h3 id="定义-4">3.3.1 定义</h3>
<ul>
<li><p><strong>定义 3.2</strong>（<span class="math inline">\(\rm{P}_{54}\)</span>）&lt; 非中心化 <span class="math inline">\(R^2\)</span> &gt;：非中心化多元相关系数平方 <span class="math inline">\(R^2\)</span> 定义为： <span class="math display">\[
\begin{align*}
R^2_{uc} = \frac{\hat Y{}^\prime \hat Y}{Y^\prime Y} = 1 - \frac{e^\prime e}{Y^\prime Y}
\end{align*}
\]</span> <span class="math inline">\(R^2\)</span> 的含义是因变量 <span class="math inline">\({Y_t}\)</span> 的非中心化的样本二次型变动可以被预测值 <span class="math inline">\(\{\hat Y{}^\prime\}\)</span> 的非中心化样本二次型变动所预测的比例。由定义可知，总有 <span class="math inline">\(0 \leq R^2_{uc} \leq 1\)</span>。</p></li>
<li><p><strong>定义 3.3</strong>（<span class="math inline">\(\rm{P}_{54}\)</span>）&lt; 中心化 <span class="math inline">\(R^2\)</span> 或决定系数 (Coefficient of Determination) &gt;：决定系数定义为： <span class="math display">\[
\begin{align*}
R^2 \equiv 1 - \frac{\sum_\limits{t=1}^{n} e_t^2}{\sum_\limits{t=1}^{n} (Y_t - \overline Y)^2}
\end{align*}
\]</span> 其中 <span class="math inline">\(\overline Y = n^{-1}\sum_\limits{t=1}^{n}Y_t\)</span> 是样本均值。</p>
<p><strong>注：</strong></p>
<ul>
<li><p>当 <span class="math inline">\(X_t\)</span> 包括截距项，即 <span class="math inline">\(X_{0t} = 1\)</span> 时，可进行如下正交分解： <span class="math display">\[
\begin{align*}
\sum_{t=1}^{n}(Y_t - \overline Y)^2 &amp;= \sum_{t=1}^{n}(\hat Y_t - \overline Y + Y_t - \hat Y_t)^2 \\
&amp; = \sum_{t=1}^{n}(\hat Y_t - \overline Y)^2 + \sum_{t=1}^{n}e_t^2
\end{align*}
\]</span> 此时（<span class="math inline">\(\star \star\star\)</span>）： <span class="math display">\[
\begin{align*}
R^2 &amp;\equiv 1 - \frac{e^\prime e}{\sum_\limits{t=1}^{n}(Y_t - \overline Y)^2}\\
&amp;= \frac{\sum_\limits{t=1}^{n}(\hat Y_t - \overline Y)^2}{\sum_\limits{t=1}^{n}(Y_t - \overline Y)^2}
\end{align*}
\]</span></p></li>
<li><p>如果 <span class="math inline">\(X_t\)</span> 不包括截距项，此时： <span class="math display">\[
\begin{align*}
\sum_{t=1}^{n}(Y_t - \overline Y)^2 &amp;= \sum_{t=1}^{n}(\hat Y_t - \overline Y)^2 + \sum_{t=1}^{n}e_t^2 + 2 \sum_{t=1}^{n}(\hat Y_t - \overline Y)e_t \\
&amp;\neq \sum_{t=1}^{n}(\hat Y_t - \overline Y)^2 + \sum_{t=1}^{n}e_t^2
\end{align*}
\]</span> 在这种情况下，<strong><span class="math inline">\(R^2\)</span> 可能为负值</strong>，因为交叉项 <span class="math inline">\(\sum_\limits{t=1}^{n}(\hat Y_t - \overline Y)e_t\)</span> 可能为负值。</p></li>
</ul></li>
</ul>
<h3 id="定理-4">3.3.2 定理</h3>
<ul>
<li><p><strong>定理 3.3</strong>（<span class="math inline">\(\rm{P}_{56}\)</span>）：<span class="math inline">\(R^2 = \hat \rho_{Y\hat Y}^2\)</span>，这里 <span class="math inline">\(\hat \rho_{Y\hat Y}^2\)</span> 是 <span class="math inline">\(\{Y_t\}\)</span> 和 <span class="math inline">\(\{\hat Y_t\}\)</span> 的样本相关系数。</p></li>
<li><p><strong>定理 3.4</strong>（<span class="math inline">\(\rm{P}_{56}\)</span>）：假设 <span class="math inline">\(\{Y_t, X_{1t}, \dots, X_{ (k+q)t}\}_{t=1}^n\)</span> 是一容量为 <span class="math inline">\(n\)</span> 的随机样本，<span class="math inline">\(R_1^2\)</span> 是下列线性回归模型的中心化拟合度： <span class="math display">\[
\begin{align*}
Y_t= X_t^{\prime}\beta + \varepsilon_t
\end{align*}
\]</span> 其中， <span class="math inline">\(X_t = (1, X_{1t}, \dots, X_{kt})^\prime\)</span>，<span class="math inline">\(\beta\)</span> 是 <span class="math inline">\(K \times 1\)</span> 未知参数向量；<span class="math inline">\(R_2^2\)</span> 是下面扩展的线性回归模型的中心化扰合优度： <span class="math display">\[
\begin{align*}
Y_t = \tilde X_t^\prime \gamma + u_t
\end{align*}
\]</span> 其中，<span class="math inline">\(\tilde X_t = (1, X_{1t}, \dots, X_{kt}, X_{(k+1)t)})^\prime\)</span>，<span class="math inline">\(\gamma\)</span> 是 <span class="math inline">\((K+q) \times 1\)</span> 未知参数向量，<span class="math inline">\(q\)</span> 是正整数。则： <span class="math display">\[
\begin{align*}
R_2^2 \geq R_1^2
\end{align*}
\]</span> <strong>注：</strong>定理 3.4 有重要含义：</p>
<ul>
<li><span class="math inline">\(R^2\)</span> 可用于 <strong>解释变量数目相等</strong> 的线性回归模型的比较，但它不适用于 <strong>比较不同解释变量数目</strong> 的线性模型，因为 <strong>模型的解释变量越多，<span class="math inline">\(R^2\)</span> 就会越大</strong>。</li>
<li><span class="math inline">\(R^2\)</span> 也不是正确模型设定的判断标准。<span class="math inline">\(R^2\)</span> 高并不意味着模型设定正确，事实上，给定解释变量 <span class="math inline">\(X_t\)</span>，<span class="math inline">\(R_2\)</span> 值的大小 <strong>与线性回归模型的信噪比</strong> 有关</li>
</ul></li>
</ul>
<h3 id="模型选择准则">3.3.3 模型选择准则</h3>
<ol type="1">
<li><p><strong>Akaike 信息准则</strong>（Akaike information criterion, AIC）</p>
<p>线性回归模型可通过选择合适的解释变量数模 <span class="math inline">\(K\)</span>，以最小化下面的 Akaike 信息准则来选择模型。 <span class="math display">\[
\begin{align*}
AIC = {\rm{ln}}(s^2) + \frac{2K}{n}
\end{align*}
\]</span> 其中， <span class="math display">\[
\begin{align*}
s^2 = e^\prime e / (n - K)
\end{align*}
\]</span> <span class="math inline">\(K = k+1\)</span> 是自变量 <span class="math inline">\(X_t\)</span> 的数目，第一项 <span class="math inline">\({\rm{ln}} s^2\)</span> 测度模型的拟合优度，而第二项 <span class="math inline">\(2K/n\)</span> 测度模型的复杂程度。另外，<span class="math inline">\(s^2\)</span> 是 <span class="math inline">\(E(\varepsilon_t^2) = \sigma^2\)</span> 的残差方差估计量（Residual variance estimator）。</p></li>
<li><p><strong>Bayesian 信息准则</strong>（Bayesian information criterion, BIC）</p>
<p>线性模型也可以通过选择合适的 <span class="math inline">\(K\)</span>，以最小化以下 <span class="math inline">\(Bayesian\)</span> 信息准则来选择模型： <span class="math display">\[
\begin{align*}
BIC = {\rm{ln}} (s^2) +\frac{K {\rm{ln}}(n)}{n}
\end{align*}
\]</span></p></li>
<li><p><span class="math inline">\(\overline R^2\)</span></p>
<p>我们知道 <span class="math inline">\(R^2\)</span> 的定义为： <span class="math display">\[
\begin{align*}
R^2 = 1 - \frac{e^\prime e / n}{\sum_\limits{t=1}^{n}(Y_t - \overline Y)^2 / n}
\end{align*}
\]</span> 其中，<span class="math inline">\(e^\prime e / n\)</span> 和 <span class="math inline">\(\sum_\limits{t=1}^{n}(Y_t - \overline Y)^2 / n\)</span> 分别是方差 <span class="math inline">\(\sigma^2 = var(\varepsilon_t)\)</span> 和 <span class="math inline">\(\sigma_Y^2 = var  (Y_t)\)</span> 的有偏估计。调整的 <span class="math inline">\(R^2\)</span> 为：</p></li>
</ol>
<p><span class="math display">\[
   \begin{align*}
   \overline R^2 = 1 - \frac{e^\prime e / (n-K)}{(n-1)^{-1}\sum_\limits{t=1}^{n}(Y_t - \overline Y)^2}
   \end{align*}
\]</span></p>
<p>此时有：<span class="math inline">\(E(e^\prime e / (n-K)) = \sigma^2\)</span> 和 <span class="math inline">\(E[(n-1)^{-1}\sum_\limits{t=1}^{n}(Y_t - \overline Y)^2] = \sigma_Y^2\)</span> ，在 <span class="math inline">\(\overline R^2\)</span> 中，调整的是自由度。</p>
<h2 id="ols-估计量的无偏性和有效性">3.4 <span class="math inline">\(OLS\)</span> 估计量的无偏性和有效性</h2>
<h3 id="定理-5">3.4.1 定理</h3>
<ul>
<li><p><strong>定理 3.5</strong>（<span class="math inline">\(\rm{P}_{60}\)</span>）：如果假设 3.1、3.3 (1) 和 3.4 成立，则：</p>
<p>1）<strong>无偏性</strong> &lt; Unbiasedness &gt; ：<span class="math inline">\(E(\hat \beta|X) = \beta^o\)</span>，并且 <span class="math inline">\(E(\hat\beta) = \beta^o\)</span>；</p>
<p><strong>注：将 <span class="math inline">\((X^\prime X)^{-1} X^\prime\)</span> 视为系数矩阵</strong>（<span class="math inline">\(\star\star\star\)</span>）。</p>
<p>2）<strong>方差偏小性</strong> &lt; Vanishing variance &gt; ： <span class="math display">\[
\begin{align*}
var(\hat \beta |X) = E\{[\hat\beta - E(\hat \beta|X)][\hat\beta - E(\hat\beta|X)]^\prime |X\} = \sigma^2(X^\prime X)^{-1}
\end{align*}
\]</span> 如果假设 3.3 (2) 也成立，那么对于任意的 <span class="math inline">\(K \times 1\)</span> 向量 <span class="math inline">\(\tau\)</span>，满足 <span class="math inline">\(\tau^\prime \tau = 1\)</span>，有： <span class="math display">\[
\begin{align*}
  \mathsf{当} n \to \infty \mathsf{时，}\tau^\prime var(\hat\beta|X)\tau \to 0
  \end{align*}
\]</span> 3）<strong>正交性</strong> &lt; Orthogonality between <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> &gt; ： <span class="math display">\[
\begin{align*}
  cov(\hat \beta, e|X) = 0
\end{align*}
\]</span> 4）<strong>Gauss - Markov 定理</strong>：对于任意的线性无偏估计量 <span class="math inline">\(\hat b, var(\hat b|X) - var(\hat\beta|X  )\)</span> 是半正定 (Positive semi-definite, PSD) 的。</p>
<p>5）<strong>残差方差估计量</strong> &lt; Residual variance estimator &gt;： <span class="math display">\[
\begin{align*}
  s^2 = e^\prime e/(n - K) = \frac{1}{n - K }\sum_\limits{t = 1}^{n} e_t^2
\end{align*}
\]</span> 是 <span class="math inline">\(\sigma^2 = E(\varepsilon_t^2)\)</span> 的无偏估计量，即 <span class="math inline">\(E(s^2 | X) = \sigma^2\)</span>。</p>
<p><strong>注：</strong> <strong>由于随机变量 <span class="math inline">\(\{e_t\}\)</span> 必须满足 <span class="math inline">\(K\)</span> 个正规方程 <span class="math inline">\(X^\prime e = 0\)</span>，故其中只有 <span class="math inline">\((n - K)\)</span> 个残差是（自由）独立的，</strong>经过自由度校正后，才是无偏估计。如果样本容量 <span class="math inline">\(n\)</span> 很大，当 <span class="math inline">\(n \to \infty\)</span> 时，<span class="math inline">\(\frac{n - K}{n} \to 1\)</span>，是否进行“小样本校正”并无多大区别。</p></li>
</ul>
<h2 id="ols-估计量的抽样分布">3.5 <span class="math inline">\(OLS\)</span> 估计量的抽样分布</h2>
<h3 id="假设-1">3.5.1 假设</h3>
<ul>
<li><p><strong>假设 3.5</strong>（<span class="math inline">\(\rm{P}_{65}\)</span>）&lt; 条件正态分布 (Conditional Normality) &gt;：<span class="math inline">\(\varepsilon|X \sim N(0, \sigma^2 I)\)</span> 。</p>
<p>假设 3.5 可以推出假设 3.2（<span class="math inline">\(E(\varepsilon|X) = 0\)</span>） 和假设 3.4 （<span class="math inline">\(E(\varepsilon_t\varepsilon_s|X) = \sigma^2I\)</span>）。事实上，在假设 3.5 下，<span class="math inline">\(\varepsilon\)</span> 的条件概率密度函数： <span class="math display">\[
\begin{align*}
  f(\varepsilon|X) = \frac{1}{(\sqrt{2 \pi \sigma^2})^n}exp(-\frac{\varepsilon^\prime \varepsilon} {2\sigma^2}) = f(\varepsilon)
\end{align*}
\]</span> 不依赖于 <span class="math inline">\(X\)</span>，从而随机扰动项 <span class="math inline">\(\varepsilon\)</span> 独立于 <span class="math inline">\(X\)</span>。因此， <span class="math inline">\(\varepsilon\)</span> 的任何条件矩均不依赖于 <span class="math inline">\(X\)</span>。</p></li>
</ul>
<h3 id="定理-6">3.5.2 定理</h3>
<ul>
<li><p><strong>定理 3.6</strong>（<span class="math inline">\(\rm{P}_{65}\)</span>）&lt; <span class="math inline">\(\hat\beta\)</span> 的条件正态分布 &gt;：给定假设 3.1、3.3 (1) 和 3.5，对所有的 <span class="math inline">\(n&gt;K\)</span>： <span class="math display">\[
\begin{align*}
  (\hat \beta - \beta^o)|X \sim N[0, \sigma^2(X^\prime X)^{-1}]
\end{align*}
\]</span></p></li>
<li><p><strong>推论 3.7</strong>（<span class="math inline">\(\rm{P}_{66}\)</span>）&lt; <span class="math inline">\(R(\hat\beta - \beta^o)\)</span> 的条件正态分布 &gt;：给定假设 3.1、3.3 (1) 和 3.5，则对于任何非随机的 <span class="math inline">\(J \times K\)</span> 矩阵 <span class="math inline">\(R\)</span>，有： <span class="math display">\[
  \begin{align*}
  R(\hat \beta - \beta^o)|X \sim N[0, R \sigma^2(X^\prime X)^{-1} R^\prime]
  \end{align*}
\]</span></p></li>
</ul>
<h2 id="ols-估计量的方差---协方差矩阵的估计">3.6 <span class="math inline">\(OLS\)</span> 估计量的方差 - 协方差矩阵的估计</h2>
<h3 id="定理-7">3.6.1 定理</h3>
<ul>
<li><p><strong>引理 3.8</strong>（<span class="math inline">\(\rm{P}_{66}\)</span>）&lt; 正态随机变量的二次型 (Quadratic Form of Normal Random Variables) &gt;：如果一个 <span class="math inline">\(m\times 1\)</span> 随机变量 <span class="math inline">\(v \sim N(0, 1)\)</span>，并且 <span class="math inline">\(Q\)</span> 是一个 <span class="math inline">\(m \times m\)</span> 非随机对称幂等矩阵， 秩 <span class="math inline">\(1\leq m\)</span>，则二次型： <span class="math display">\[
 \begin{align*}
  v^\prime Q v \sim \chi^2_q
  \end{align*}
\]</span> 在以下引用中，<span class="math inline">\(v = \varepsilon/\sigma\sim N(0,1), Q = M\)</span>。因为 <span class="math inline">\(rank(M) = n - K\)</span>，所以： <span class="math display">\[
  \begin{align*}
  \left.\frac{e^\prime e}{\sigma^2} \right|X \sim \chi^2_{n-K}
  \end{align*}
\]</span></p></li>
<li><p><strong>引理 3.9</strong>（<span class="math inline">\(\rm{P}_{67}\)</span>）&lt; 残差方差的估计量 (Residual Variance Estimator) &gt;：给定假设 3.1、3.3 (1) 和 3.5，则对于任意的 <span class="math inline">\(n\leq K\)</span>，有：</p>
<p>1） <span class="math display">\[
\begin{align*}
  \left.\frac{(n-K)s^2}{\sigma^2} \right|X = \left.\frac{e^\prime e}{\sigma^2} \right|X \sim \chi^2_{n-K}
\end{align*}
\]</span> 2）给定 <span class="math inline">\(X\)</span> 的条件下，<span class="math inline">\(s^2\)</span> 和 <span class="math inline">\(\hat\beta\)</span> 是独立的。</p></li>
</ul>
<h2 id="参数假设检验">3.7 参数假设检验</h2>
<h3 id="定义-5">3.7.1 定义</h3>
<ul>
<li><strong>定义 3.4</strong>（<span class="math inline">\(\rm{P}_{73}\)</span>）&lt; 依分布收敛 (Convergence in Distribution) &gt; ：假设 <span class="math inline">\(\{Z_n, n= 1, 2, \dots\}\)</span> 是一个分布函数为<span class="math inline">\(\{F_n(z) = P(Z_n \leq z)\}\)</span> 的随机变量或随机向量的序列，<span class="math inline">\(Z\)</span> 是一个不依赖于 <span class="math inline">\(n\)</span> 的分布函数为 <span class="math inline">\(F(z) = P(Z \leq z)\)</span> 的随机变量或随机向量。称 <span class="math inline">\(Z_n\)</span> 依分布收敛于 <span class="math inline">\(Z\)</span>，如果在分布函数 <span class="math inline">\(F(z)\)</span> 的任何连续点，<span class="math inline">\(Z_n\)</span> 的分布函数值均收敛于 <span class="math inline">\(Z\)</span> 的分布函数值，即： <span class="math display">\[
\begin{align*}
  \lim_{n\to\infty} F_n(z) = F(z)
\end{align*}
\]</span> 或等价地： <span class="math display">\[
\begin{align*}
  \mathsf{当}\ n\to\infty\ \mathsf{时}, F_n(z) \to F(z)
\end{align*}
\]</span> 用符号 <span class="math inline">\(Z_n \overset{d}{\to} Z\)</span> 表示。<span class="math inline">\(Z\)</span> 的分布称为 <span class="math inline">\(Z_n\)</span> 的渐近分布或极限分布。</li>
</ul>
<h3 id="定理-8">3.7.2 定理</h3>
<ul>
<li><strong>推论 3.10</strong>（<span class="math inline">\(\rm{P}_{71}\)</span>）：给定假设 3.1、3.3 (1) 和 3.5，当原假设 <span class="math inline">\(\mathbb{H}_0: R\beta^o = r\)</span> 成立时，对于每一个 <span class="math inline">\(n\geq K\)</span>，有：</li>
</ul>
<p><span class="math display">\[
\begin{align*}
  (R\hat\beta - r)|X \sim N[0, \sigma^2 R(X^\prime X)^{-1}R^\prime]
\end{align*}
\]</span></p>
<ul>
<li><p><strong>推论 3.11</strong>（<span class="math inline">\(\rm{P}_{76}\)</span>）：如果 <span class="math inline">\(q \times 1\)</span> 随机向量 <span class="math inline">\(Z \sim N(0, V)\)</span>，其中 <span class="math inline">\(V = var(Z)\)</span> 是一个 <span class="math inline">\(q\times q\)</span> 对称、非奇异的方差 - 协方差矩阵，则： <span class="math display">\[
\begin{align*}
  Z^\prime V^{-1}Z \sim \chi_q^2
\end{align*}
\]</span></p></li>
<li><p><strong>定理 3.12</strong>（<span class="math inline">\(\rm{P}_{78}\)</span>）：给定假设 3.1、3.3 (1) 和 3.5，当原假设 <span class="math inline">\(\mathbb{H}_0: R\beta^o = r\)</span> 成立时，对于每一个 <span class="math inline">\(n\geq K\)</span>，有： <span class="math display">\[
\begin{align*}
F = \frac{(R \hat\beta - r)^\prime[R(X^\prime X)^{-1}R^\prime]^{-1}(R \hat\beta - r)/J}{s^2} \sim F_{J,n-K}
\end{align*}
\]</span></p></li>
<li><p><strong>定理 3.13</strong>（<span class="math inline">\(\rm{P}_{79}\)</span>）：给定假设 3.1、3.3 (1) ，令 <span class="math inline">\(SSR_u = e^\prime e\)</span> 是以下无约束回归模型的残差平方和： <span class="math display">\[
\begin{align*}
Y = X\beta^o + \varepsilon
\end{align*}
\]</span> 令 <span class="math inline">\(SSR_r = \tilde e^\prime \tilde e\)</span> 是以下有约束模型的残差平方和 ： <span class="math display">\[
\begin{align*}
Y = X\beta^o + \varepsilon
\end{align*}
\]</span> 其约束条件为： <span class="math display">\[
\begin{align*}
R \beta^o = r
\end{align*}
\]</span> 这里 <span class="math inline">\(\tilde e = Y - X \tilde \beta\)</span>，<span class="math inline">\(\tilde \beta\)</span> 是有约束回归模型的 <span class="math inline">\(OLS\)</span> 估计量。则 <span class="math inline">\(F\)</span> 检验统计量可写为： <span class="math display">\[
\begin{align*}
F = \frac{(\tilde e^\prime \tilde e - e^\prime e)/J}{e^\prime e/(n - K)}
\end{align*}
\]</span></p></li>
<li><p><strong>定理 3.14</strong>（<span class="math inline">\(\rm{P}_{81}\)</span>）：给定假设 3.1、3.3 (1) 和 3.5，则当原假设是<span class="math inline">\(\mathbb{H}_0: R\beta^o = r\)</span> 成立且 <span class="math inline">\(n \to \infty\)</span> 时，<span class="math inline">\(Wald\)</span> 检验统计量： <span class="math display">\[
\begin{align*}
\mathcal{W} = \frac{R\hat\beta - r)^\prime[R(X^\prime X)^{-1} R^\prime]^{-1}(R\hat\beta  - r)}{s^2} = J \cdot F \overset{d}{\to}\chi^2_J
\end{align*}
\]</span> 可以发现，这里定义的 <span class="math inline">\(Wald\)</span> 检验统计量与 <span class="math inline">\(F\)</span> 检验统计量 <strong>只相差一个比例常数</strong> <span class="math inline">\(J\)</span>，这是因为目前考虑条件同方差的情形。如果存在条件异方差，仍然可以定义 <span class="math inline">\(Wald\)</span> 检验统计量，但是 <span class="math inline">\(W = J \cdot F\)</span> 这一关系将不再成立。</p></li>
</ul>
<h2 id="广义最小二乘估计">3.9 广义最小二乘估计</h2>
<p>经典线性回归模型依赖于关键假设—假设 3.5（<span class="math inline">\(\varepsilon|X \sim N(0, \sigma^2 I)\)</span> ）。除了条件正态分布外，还隐含不存在条件异方差和自相关性。</p>
<h3 id="假设-2">3.9.1 假设</h3>
<ul>
<li><p><strong>假设 3.6</strong>（<span class="math inline">\(\rm{P}_{87}\)</span>）：<span class="math inline">\(\varepsilon|X \sim N(0, \sigma^2 V)\)</span>，其中 <span class="math inline">\(0 &lt; \sigma^2 &lt; \infty\)</span> 是未知的，但 <span class="math inline">\(V = V(X)\)</span> 是一个已知的堆成与有限的 <span class="math inline">\(n \times n\)</span> 正定矩阵。</p>
<p>从假设可知条件方差（<span class="math inline">\(\star\star\star\)</span>）： <span class="math display">\[
\begin{align*}
var(\varepsilon|X) = E(\varepsilon^\prime\varepsilon|X) = \sigma^2V = \sigma^2 V(X)
\end{align*}
\]</span> 虽然 <span class="math inline">\(var(\varepsilon|X)\)</span> 仅包含一个未知常熟 <span class="math inline">\(\sigma^2\)</span>，但它允许存在已知形式的条件异方差 <span class="math inline">\(V(X)\)</span>。</p></li>
</ul>
<h3 id="定义-6">3.9.2 定义</h3>
<h3 id="定理-9">3.9.3 定理</h3>
<ul>
<li><p><strong>定理 3.15</strong>（<span class="math inline">\(\rm{P}_{87}\)</span>）：给定假设 3.1、3.3 (1) 和 3.6，则：</p>
<p>1）<strong>无偏性</strong>：<span class="math inline">\(E(\hat\beta|X) = \beta^o\)</span>；</p>
<p>2）<strong>方差</strong>：<span class="math inline">\(var(\hat\beta|X) = \sigma^2(X^\prime X)^{-1} X^\prime VX(X^\prime X)^{-1} \neq \sigma^2(X^\prime X)^{-1}\)</span>；</p>
<p>3）<strong>正态分布</strong>：<span class="math inline">\((\hat\beta - \beta^o)|X \sim N[0,\sigma^2 (X^\prime X)^{-1}X^\prime VX(X^\prime X)^{-1}]\)</span>；</p>
<p>4）<strong>相关性</strong>：<span class="math inline">\(cov(\hat\beta,e|X) \neq 0\)</span>。</p></li>
<li><p><strong>引理 3.16</strong>（<span class="math inline">\(\rm{P}_{88}\)</span>）：对于任意的 <span class="math inline">\(n \times n\)</span> 对称正定矩阵 <span class="math inline">\(V\)</span>，总可以写成： <span class="math display">\[
\begin{align*}
V^{-1} &amp;= C^\prime C \\
V &amp;= C^{-1}(C^\prime)^{-1}
\end{align*}
\]</span> 这里，<span class="math inline">\(C\)</span> 是一个 <span class="math inline">\(n \times n\)</span> 非奇异矩阵。这称为 Cholesky 分解（Cholesky factorization），其中 C 可能是非对称矩阵。</p>
<p>考虑线性回归模型： <span class="math display">\[
\begin{align*}
CY = (CX)\beta^o + C \varepsilon
\end{align*}
\]</span> 令 <span class="math inline">\(Y^* = CY, X^* = CX, \varepsilon^* = C\varepsilon\)</span>。变换后的回归模型的 <span class="math inline">\(OLS\)</span> 估计量为： <span class="math display">\[
\begin{align*}
\hat\beta{}^* = (X^{*\prime}X^*)^{-1}(X^{*\prime}Y^*) = (X^\prime V^{-1}X)^{-1} X^\prime V^{-1} Y
\end{align*}
\]</span> 称为广义最小二乘 (<span class="math inline">\(GLS\)</span>) 估计量。</p></li>
<li><p><strong>定理 3.17</strong>（<span class="math inline">\(\rm{P}_{91}\)</span>）：给定假设 3.1、3.3 (1) 和 3.6，则：</p>
<p>1）<strong>无偏性</strong>：<span class="math inline">\(E(\hat\beta{}^*|X) = \beta^o\)</span>；</p>
<p>2）<strong>方差</strong>：<span class="math inline">\(var(\hat\beta{}^*|X) = \sigma^2(X^{*\prime} X^*)^{-1} = \sigma^2(X^\prime V^{-1} X)^{-1}\)</span>；</p>
<p>3）<strong>相关性</strong>：<span class="math inline">\(cov(\hat\beta{}^*,e^*|X) = 0\)</span>，其中 <span class="math inline">\(e^* = Y^* - X^* \hat\beta{}^*\)</span>；</p>
<p>4）<span class="math inline">\(\hat\beta{}^*\)</span> 是最优线性无偏估计量(BLUE);</p>
<p>5）<span class="math inline">\((s^{*2}|X) = \sigma^2\)</span>，其中 <span class="math inline">\(S^{*2} = e^{*\prime}e^*/(n-K)\)</span>。</p></li>
</ul>
<h1 id="独立同分布随机样本的线性回归模型">4 独立同分布随机样本的线性回归模型</h1>
<h2 id="渐近理论导论">4.1 渐近理论导论</h2>
<h3 id="定义-7">4.1.1 定义</h3>
<ul>
<li><p><strong>定义 4.1</strong>（<span class="math inline">\(\rm{P}_{103}\)</span>）&lt; 依均方收敛或依二次方均值收敛 (Convergence in Mean Squares or in Quadratic Mean) &gt; ：一个随机变量（或固定维数的随机向量，即 <span class="math inline">\(Z_n\)</span> 的维数不随 <span class="math inline">\(n\)</span> 的增加而变化）序列 <span class="math inline">\(\{Z_n, n = 1, 2, \dots\}\)</span> 依均方收敛于随机变量（或随机向量） <span class="math inline">\(Z\)</span>，如果当 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
E\ \Vert Z_n - Z \Vert^2 \to 0
\end{align*}
\]</span> 其中，<span class="math inline">\(\Vert \cdot \Vert\)</span> 是随机变量或随机向量的模。记 <span class="math inline">\(Z_n \overset{q.m.}{\to} Z\)</span>。</p>
<p><strong>注：</strong>当 <span class="math inline">\(Z_n\)</span> 是一个固定维数的随机向量时，可理解为 <span class="math inline">\(Z_n\)</span> 的每一个元素的序列收敛于 <span class="math inline">\(Z\)</span> 的相对应元素。如果 <span class="math inline">\(Z_n - Z\)</span> 是一个 <span class="math inline">\(l \times m\)</span> 的矩阵时，可将平方模定义为： <span class="math display">\[
\begin{align*}
\Vert Z_n - Z \Vert^2 = \sum_{t=1}^{l}\sum_{s = 1}^{m} [Z_n - Z]^2_{(t, s)}
\end{align*}
\]</span></p></li>
<li><p><strong>定义 4.2</strong>（<span class="math inline">\(\rm{P}_{103}\)</span>）&lt; 依概率收敛 (Convergence in Probability) &gt; ：一个随机变量序列 <span class="math inline">\(\{Z_n, n = 1, 2, \dots\}\)</span> 依概率收敛于 <span class="math inline">\(Z\)</span>，如果对任意给定的常数 <span class="math inline">\(\epsilon &gt; 0\)</span>，有： <span class="math display">\[
\begin{align*}
\mathsf{当}\ n\to \infty \mathsf{时},\ Pr[\ \Vert Z_n - Z \Vert &gt;\epsilon] \to 0
\end{align*}
\]</span> 或等价地： <span class="math display">\[
\begin{align*}
\mathsf{当}\ n\to \infty \mathsf{时},\ Pr[\ \Vert Z_n - Z \Vert \leq \epsilon] \to 1
\end{align*}
\]</span> 对于依概率收敛，可记为 <span class="math inline">\(Z_n - Z \overset{p}{\to} 0\)</span> 或 <span class="math inline">\(Z_n - Z = O_P(1)\)</span>。</p></li>
<li><p><strong>定义 4.3</strong>（<span class="math inline">\(\rm{P}_{106}\)</span>）&lt; 依概率有界 (Boundedness in Probability) &gt; ：一个随机变量序列 <span class="math inline">\(\{Z_n, n = 1, 2, \dots\}\)</span> 依概率有界的，如果对任意小的常数 <span class="math inline">\(\delta &gt; 0\)</span>，存在常数 <span class="math inline">\(C= C(\delta)&lt; \infty\)</span>，使得，当 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
P(\ \Vert Z_n \Vert &gt; C\ ) \leq \delta
\end{align*}
\]</span> 记为 <span class="math inline">\(Z_n = O_P(1)\)</span>。 <span class="math display">\[
\begin{align*}
\mathsf{当}\ n\to \infty \mathsf{时},\ Pr[\ \Vert Z_n - Z \Vert \leq \epsilon] \to 1
\end{align*}
\]</span> 其中，<span class="math inline">\(\Vert \cdot \Vert\)</span> 是随机变量或随机向量的模。记 <span class="math inline">\(Z_n \overset{q.m.}{\to} Z\)</span>。</p></li>
<li><p><strong>定义 4.4</strong>（<span class="math inline">\(\rm{P}_{108}\)</span>）&lt; 几乎必然收敛 (Almost sure convergence)) &gt; ：<span class="math inline">\(\{Z_n, n = 1, 2, \dots\}\)</span> 几乎必然收敛于 <span class="math inline">\(Z\)</span>，如果： <span class="math display">\[
\begin{align*}
\Pr[\lim_{n\to\infty}\Vert Z_n - Z \Vert = 0] = 1
\end{align*}
\]</span> 记为 <span class="math inline">\(Z_n - Z \overset{a.s.}{\to}\)</span> 或 <span class="math inline">\(Z_n - Z = o_{a.s.}(1)\)</span>。</p>
<p><strong>注：</strong>几乎必然收敛可以推出依概率收敛，但依概率收敛不一定能推出几乎必然收敛。</p></li>
</ul>
<h3 id="定理-10">4.1.2 定理</h3>
<ul>
<li><p><strong>引理 4.1</strong>（<span class="math inline">\(\rm{P}_{105}\)</span>）&lt; 独立同分布样本的弱大数定律 (Weak Law of Large Numbers (WLLN) for I.I.D Samples) &gt; ：假设随机样本 <span class="math inline">\(\{Z_t\}^n_{t=1}\)</span> 服从 <span class="math inline">\(i.i.d.(\mu,\sigma^2)\)</span>，并定义 <span class="math inline">\(\bar Z_n = n^{-1} \sum_\limits{t=1}^{n} Z_t\)</span>，这里 <span class="math inline">\(n = 1,2,\cdots\)</span>。则当 <span class="math inline">\(n \to \infty\)</span> 时： <span class="math display">\[
\begin{align*}
\bar Z_n \overset{p}{\to} \mu
\end{align*}
\]</span></p></li>
<li><p><strong>引理 4.2</strong>（<span class="math inline">\(\rm{P}_{105}\)</span>）&lt; 独立同分布随机样本的弱大数定律 (WLLN for I.I.D Samples) &gt; ：假设 <span class="math inline">\(\{Z_t\}^n_{t=1}\)</span> 是一个独立同分布随机样本，<span class="math inline">\(E(Z_t) = \mu\)</span> 且 <span class="math inline">\(E |Z_t| &lt; \infty\)</span>。定义 <span class="math inline">\(\bar Z_n = n^{-1} \sum_\limits{t=1}^{n} Z_t\)</span>，则当 <span class="math inline">\(n \to \infty\)</span> 时： <span class="math display">\[
\begin{align*}
\bar Z_n \overset{p}{\to} \mu
\end{align*}
\]</span></p></li>
<li><p><strong>引理 4.3</strong>（<span class="math inline">\(\rm{P}_{106}\)</span>）：如果 <span class="math inline">\(Z_t - Z \overset{q.m.}{\to} 0\)</span>，则 <span class="math inline">\(Z_t - Z \overset{p}{\to} 0\)</span>。</p></li>
<li><p><strong>引理 4.4</strong>（<span class="math inline">\(\rm{P}_{109}\)</span>）&lt; 独立同分布随机样本的弱强数定律 (Strong Law of Large Numbers (SLLN) for I.I.D Samples) &gt; ：假设 <span class="math inline">\(\{Z_t\}^n_{t=1}\)</span> 是一个独立同分布随机样本，<span class="math inline">\(E(Z_t) = \mu\)</span> 且 <span class="math inline">\(E |Z_t| &lt; \infty\)</span>。则当 <span class="math inline">\(n \to \infty\)</span> 时： <span class="math display">\[
\begin{align*}
\bar Z_n \overset{a.s.}{\to} \mu
\end{align*}
\]</span></p></li>
<li><p><strong>引理 4.5</strong>（<span class="math inline">\(\rm{P}_{109}\)</span>）&lt; 连续性 (Continuity) &gt; ：</p>
<p>1）假设当 <span class="math inline">\(n \to \infty\)</span> 时，<span class="math inline">\(A_n - A \overset{p}{\to} 0, B_n - B \overset{p}{\to} 0\)</span>，且 <span class="math inline">\(g(\cdot)\)</span> 和 <span class="math inline">\(h(\cdot)\)</span> 是连续函数。则： <span class="math display">\[
\begin{align*}
[g(A_n) + h(B_n)] - [g(A) + h(B)] \overset{p}{\to} 0 \\
g(A_n)h(B_n) - g(A)h(B) \overset{p}{\to} 0
\end{align*}
\]</span> 2）对于几乎必然收敛，也有类似结论。</p></li>
<li><p><strong>引理 4.6</strong>（<span class="math inline">\(\rm{P}_{110}\)</span>）&lt; 独立同分布随机样本的中心极限定理 (CLT for I.I.D Random Samples) &gt;：假设 <span class="math inline">\(\{Z_t\}_{t=1}^{n}\)</span> 是一个 <span class="math inline">\(i.i.d.(\mu, \sigma^2)\)</span> 随机样本呢，这里 <span class="math inline">\(Z_t\)</span> 是随机变量。定义 <span class="math inline">\(\bar Z_n = n^{-1} \sum_\limits{t=1}^n Z_t\)</span> 时，有： <span class="math display">\[
\begin{align*}
\frac{\bar Z_n - E(\bar Z_n)}{\sqrt{var(\bar Z_n)}} = \frac{\sqrt{n}(\bar Z_n - \mu)}{\sigma} \overset{d}{\to} N(0,1)
\end{align*}
\]</span></p></li>
<li><p><strong>引理 4.7</strong>（<span class="math inline">\(\rm{P}_{112}\)</span>）&lt; Cramer-Wold 方法 &gt; ：假设 <span class="math inline">\(Z_n\)</span> 和 <span class="math inline">\(Z\)</span> 均是 <span class="math inline">\(p \times 1\)</span> 随机向量，这里 <span class="math inline">\(p\)</span> 是一个固定正整数。令 <span class="math inline">\(n \to \infty\)</span>。则 <span class="math inline">\(Z_n \overset{d}{\to} Z\)</span>，当且仅当对于任意非零的 <span class="math inline">\(\tau \in R^p\)</span>，且满足 <span class="math inline">\(\tau^\prime\tau = 1\)</span>，使得： <span class="math display">\[
\begin{align*}
\tau^\prime Z_n \overset{d}{\to} \tau^\prime Z
\end{align*}
\]</span></p></li>
<li><p><strong>定理 4.8</strong>（<span class="math inline">\(\rm{P}_{112}\)</span>）&lt; Slitsky 定理 &gt; ：令 <span class="math inline">\(Z_n \overset{d}{\to}Z, a_n \overset{d}{\to} a\)</span> 且 <span class="math inline">\(b_n \overset{d}{\to}b\)</span>, 其中 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 是常数。则当 <span class="math inline">\(n \to \infty\)</span> 时，有 ： <span class="math display">\[
\begin{align*}
a_n + b_n Z_n \overset{d}{\to} a + bZ
\end{align*}
\]</span></p></li>
<li><p><strong>定理 4.9</strong>（<span class="math inline">\(\rm{P}_{112}\)</span>）&lt; Delta 方法 &gt; ：假设 <span class="math inline">\(\sqrt n(Z_n - \mu)/\sigma \overset{d}{\to} N(0,1)\)</span>，<span class="math inline">\(g(\cdot)\)</span> 是连续可导的函数。且 <span class="math inline">\(g^\prime(\mu) \neq 0\)</span>。则当 <span class="math inline">\(n \to \infty\)</span> 时，有 <span class="math inline">\(\sqrt n [g(\bar Z_n) - g(\mu)] = g^\prime(\mu)\sqrt n(\bar Z_n - \mu) + O_P(1)\)</span>，且： <span class="math display">\[
\begin{align*}
\sqrt n [g(\bar Z_n) - g(\mu)] \overset{d}{\to} N\{0,\sigma^2[g^\prime(\mu)]^2\}
\end{align*}
\]</span></p></li>
</ul>
<h2 id="线性回归模型假设">4.2 线性回归模型假设</h2>
<h3 id="假设-3">4.2.1 假设</h3>
<ul>
<li><p><strong>假设 4.1</strong>（<span class="math inline">\(\rm{P}_{114}\)</span>）&lt; 独立同分布 (I.I.D) &gt; ：<span class="math inline">\(\{Y_t,X_t^\prime\}\)</span> 是一个可观测的独立同分布随机样本；</p></li>
<li><p><strong>假设 4.2</strong>（<span class="math inline">\(\rm{P}_{114}\)</span>）&lt; 线性 (Linearity) &gt; ： <span class="math display">\[
\begin{align*}
Y_t = X_t^\prime \beta^o + \varepsilon_t \qquad t = 1,\cdots,n
\end{align*}
\]</span></p></li>
<li><p><strong>假设 4.3</strong>（<span class="math inline">\(\rm{P}_{114}\)</span>）&lt; 正确模型设定 (Correct Model Specification) &gt; ：<span class="math inline">\(E(\varepsilon_t|X_t) = 0\)</span> 且 <span class="math inline">\(E(\varepsilon_t^2) = \sigma^2 &lt; \infty\)</span>；</p></li>
<li><p><strong>假设 4.4</strong>（<span class="math inline">\(\rm{P}_{114}\)</span>）&lt; 非奇异性同分布 (Nonsingularity) &gt; ： <span class="math inline">\(K\times K\)</span> 阶矩阵 <span class="math inline">\(Q = E(X_t X_t^\prime)\)</span> 是对称、有限与非奇异的；</p></li>
<li><p><strong>假设 4.5</strong>（<span class="math inline">\(\rm{P}_{114}\)</span>）： <span class="math inline">\(K\times K\)</span> 阶矩阵 <span class="math inline">\(V \equiv var(X_t \varepsilon_t) = E(X_t X_t^\prime\varepsilon_t^2)\)</span> 是对称、有限与正定 (PD) 的；</p></li>
</ul>
<h2 id="ols-估计量的一致性">4.3 <span class="math inline">\(OLS\)</span> 估计量的一致性</h2>
<p>由假设 4.4 可知，对于所有的 <span class="math inline">\(j\in\{0, 1, \cdots, k\}, E(X_{jt}^2)&lt;\infty\)</span>。根据对立同分布随机样本的强大数据定律（引理 4.4），当 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
\frac{X^\prime X}{n} = \frac{1}{n}\sum_{t=1}^{n} X_t X_t^\prime \overset{a.s.}{\to}E(X_t X_t^\prime) = Q \qquad (\star\star\star)
\end{align*}
\]</span> 假设有一个随机样本 <span class="math inline">\(\{Y_t, X_t^\prime\}_{t=1}^n\)</span>。回忆 #OLS$ 估计量： <span class="math display">\[
\begin{align*}
\hat \beta = (X^\prime X)^{-1}X^\prime Y = \hat Q{}^{-1} n^{-1} \sum_{t=1}{n} X_t Y_t
\end{align*}
\]</span> 其中， <span class="math display">\[
\begin{align*}
\hat Q{}^{-1} = n^{-1} \sum_{t=1}^{n} X_t X_t^\prime
\end{align*}
\]</span> 将 <span class="math inline">\(Y_t = X_t^\prime \beta^o + \varepsilon_t\)</span>（参见假设 4.2）代入，得： <span class="math display">\[
\begin{align*}
\hat \beta  = \beta^o + \hat Q{}^{-1} n^{-1}\sum_{t=1}^{n} X_t \varepsilon_t
\end{align*}
\]</span> 下面考察 <span class="math inline">\(\hat\beta\)</span> 的一致性。 ### 4.3.1 定理</p>
<ul>
<li><strong>定理 4.10</strong>（<span class="math inline">\(\rm{P}_{116}\)</span>）&lt; <span class="math inline">\(OLS\)</span> 估计量的一致性 (Consistency of OLS) &gt; ：给定假设 4.1-4.4，且当 <span class="math inline">\(n\to\infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
\hat\beta \overset{d}{\to} \beta^o \mathsf{或} \hat\beta - \beta^o = O_P(1)
\end{align*}
\]</span></li>
</ul>
<h3 id="ols-估计量的渐近正态性">4.4 <span class="math inline">\(OLS\)</span> 估计量的渐近正态性</h3>
<h3 id="假设-4">4.4.1 假设</h3>
<ul>
<li><strong>假设 4.6</strong>（<span class="math inline">\(\rm{P}_{119}\)</span>）&lt; 条件同方差 (Conditional Homoskedasticity) &gt;：<span class="math inline">\(E(\varepsilon_t^2|X_t) = \sigma^2\)</span>。</li>
</ul>
<h3 id="定理-11">4.4.2 定理</h3>
<ul>
<li><strong>引理 4.11</strong>（<span class="math inline">\(\rm{P}_{117}\)</span>）&lt; 独立同分布随机样本的多元中心极限定理 (Multivariate CLT for I.I.D. Random Samples) &gt;：假设 <span class="math inline">\(\{Z_t\}^n_{t=1}\)</span> 是一个独立同分布随机样本，且 <span class="math inline">\(E(Z_t) = 0, var(Z_t) = E(Z_t Z_t^\prime) = V\)</span> 是一个有限、对称与正定的矩阵，定义： <span class="math display">\[
\begin{align*}
\bar Z_n = n^{-1} \sum_{t=1}^n Z_t
\end{align*}
\]</span> 则当 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
\sqrt n \bar Z_n \overset{d}{\to} N(0, V)
\end{align*}
\]</span> 或等价地： <span class="math display">\[
\begin{align*}
V^{-\frac{1}{2}} \sqrt n \bar Z_n \overset{d}{\to} N(0, I)
\end{align*}
\]</span> 其中，<span class="math inline">\(I\)</span> 是一个维数与 <span class="math inline">\(V\)</span> 相同的单位矩阵。引理 4.11 表明，<span class="math inline">\(V \equiv var(Z_t)\)</span> 是 <span class="math inline">\(\sqrt n \bar Z_n\)</span> 的渐近分布的方差，简称 <span class="math inline">\(\sqrt n \bar Z_n\)</span> 的渐近方差，记为 <span class="math inline">\(avar(\sqrt n \bar Z_n) = V\)</span>。</li>
<li><strong>定理 4.12</strong>（<span class="math inline">\(\rm{P}_{118}\)</span>）&lt; <span class="math inline">\(OLS\)</span> 估计量的渐近正态分布 (Asymptotic Normality of OLS) &gt;：给定假设 4.1-4.5，则当 <span class="math inline">\(n\to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
\sqrt n (\bar \beta - \beta^o) \overset{d}{\to} N(0, Q^{-1}VQ^{-1})
\end{align*}
\]</span> 其中 <span class="math inline">\(V \equiv var(X_t\varepsilon_t) = E(X_t X_t^\prime \varepsilon_t^2)\)</span>。</li>
<li><strong>定理 4.13</strong>（<span class="math inline">\(\rm{P}_{119}\)</span>）：给定假设 4.1-4.6，则当 <span class="math inline">\(n\to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
\sqrt n (\bar \beta - \beta^o) \overset{d}{\to} N(0, \sigma^2Q^{-1})
\end{align*}
\]</span> 定理 4.13 表明，当存在条件同方差时，<span class="math inline">\(\sqrt n(\bar \beta - \beta^o)\)</span> 的渐近方差 (<span class="math inline">\(\star\star\star\)</span>) 为： <span class="math display">\[
\begin{align*}
avar(n (\bar \beta) = \sigma^2Q^{-1}
\end{align*}
\]</span> ## 4.5 渐近方差估计量 ### 4.5.1 定理 <strong>1. 条件同法差</strong></li>
</ul>
<p>在这种情况下，由定理 4.13，<span class="math inline">\(\sqrt{n}(\hat\beta - \beta^o)\)</span> 渐近方差为： <span class="math display">\[
\begin{align*}
avar(\sqrt n \hat \beta) = \sigma^2 Q^{-1}
\end{align*}
\]</span> - <strong>引理 4.14</strong>（<span class="math inline">\(\rm{P}_{120}\)</span>）：给定假设 4.1、4.2 和 4.4，则： <span class="math display">\[
  \begin{align*}
  \hat Q = n^{-1} \sum_{t=1}^n X_t X_t^\prime \overset{p}{\to} Q
  \end{align*}
  \]</span> 其次，考虑估计 <span class="math inline">\(\sigma^2\)</span>。因为 <span class="math inline">\(\sigma^2 = E(\varepsilon_t^2)\)</span>，可使用样本残差方差估计量： <span class="math display">\[
  \begin{align*}
  s^2 = e^\prime e/(n-K) = \frac{1}{n-K} \sum_{t=1}{n} e_t^2
  \end{align*}
  \]</span></p>
<ul>
<li><strong>定理 4.15</strong>（<span class="math inline">\(\rm{P}_{120}\)</span>）：&lt; <span class="math inline">\(\sigma^2\)</span> 的一致估计量 (Consistent Estimator of <span class="math inline">\(\sigma^2\)</span>)&gt;：给定假设 4.1-4.4，当 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
s^2 \overset{p}{\to} \sigma^2
\end{align*}
\]</span></li>
<li><strong>定理 4.16</strong>（<span class="math inline">\(\rm{P}_{121}\)</span>）：&lt; 条件同方差下 <span class="math inline">\(\sqrt n (\hat\beta - \beta^o)\)</span> 的渐近方差估计量 (Asymototic Variance Estimator of OLS Under Conditional Homoskedasticity) &gt;：给定假设 4.1-4.4，当 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
s^2 \hat Q {}^{-1} \overset{p}{\to} avar(\sqrt n \hat \beta) = \sigma^2 Q^{-1}
\end{align*}
\]</span> <span class="math inline">\(\sqrt n (\hat\beta - \beta^o)\)</span> 的渐近方差估计量是： <span class="math display">\[
\begin{align*}
s^2 \hat Q {}^{-1} = s^2(X^\prime X /n)^{-1}
\end{align*}
\]</span> 这等价于，当 <span class="math inline">\(n\)</span> 很大时，<span class="math inline">\((\hat\beta - \beta^o)\)</span> 的方差估计量近似为： <span class="math display">\[
\begin{align*}
s^2 \hat Q {}^{-1}/n = s^2(X^\prime X)^{-1}
\end{align*}
\]</span></li>
</ul>
<p><strong>2. 条件异方差</strong></p>
<p>在存在条件异方差（即 <span class="math inline">\(E(\varepsilon_t^2|X_t) \neq \sigma^2\)</span>) 时，<span class="math inline">\(\sqrt n (\hat\beta - \beta^o)\)</span> 的渐近方差为： <span class="math display">\[
\begin{align*}
avar(\sqrt n \hat \beta) = Q^{-1} V Q^{-1}
\end{align*}
\]</span> 其中，<span class="math inline">\(V = E(X_t X_t^\prime \varepsilon_t^2)\)</span>。 - <strong>引理 4.17</strong>（<span class="math inline">\(\rm{P}_{122}\)</span>）：给定假设 4.1-4.5 和 4.7，则当 <span class="math inline">\(n \to \infty\)</span> 时，有 <span class="math display">\[
  \begin{align*}
  \hat V = \frac{1}{n} \sum_{t = 1}^{n} X_t X_t^\prime e_t^2 \overset{p}{\to} V
  \end{align*}
  \]</span></p>
<ul>
<li><strong>引理 4.18</strong>（<span class="math inline">\(\rm{P}_{123}\)</span>）&lt; 条件异方差下 <span class="math inline">\(\sqrt n \hat \beta\)</span> 的渐近方差估计量 (Asymptotic Variance Estimator of OLS Under Conditional Heteroskedasticity) &gt;：给定假设 4.1-4.5 和 4.7，则当 <span class="math inline">\(n \to \infty\)</span> 时，有 <span class="math display">\[
\begin{align*}
\hat Q{}^{-1} \hat V \hat Q{}^{-1} \overset{p}{\to} avar{\sqrt n \hat \beta} = Q^{-1} V Q^{-1}
\end{align*}
\]</span> 这就是 <span class="math inline">\(\sqrt n \hat \beta\)</span> 的 <span class="math inline">\(White (1980)\)</span> 异方差一致性方差 - 协方差矩阵估计量 (Heteroskedasticity-consistent variance-covariance matrix estimator)。因此，当存在条件异方差及 <span class="math inline">\(n\)</span> 很大时，<span class="math inline">\(\hat \beta - \beta^o\)</span> 的方差估计量为: <span class="math display">\[
\begin{align*}
\frac{\hat Q{}^{-1} \hat V \hat Q{}^{-1}}{n} &amp;= \frac{(X^\prime X /n)^{-1} \hat V (X^\prime X /n)^{-1}}{n}\\
&amp;=  (X^\prime X)^{-1} X^\prime D(e) D(e)^\prime X (X^\prime X)^{-1}\\
&amp;\neq s^2(X^\prime X)^{-1}
\end{align*}
\]</span></li>
</ul>
<h3 id="假设-5">4.5.2 假设</h3>
<ul>
<li><strong>假设 4.7</strong>（<span class="math inline">\(\rm{P}_{122}\)</span>）：(1) 对于所有的 <span class="math inline">\(j \in \{0,1,\cdots,k\}, E(X_{jt}^4)&lt;\infty\)</span>。(2) <span class="math inline">\(E(X\varepsilon_{t}^4)&lt;\infty\)</span>。 <span class="math display">\[
\begin{align*}
s^2 \hat Q {}^{-1} \overset{p}{\to} avar(\sqrt n \hat \beta) = \sigma^2 Q^{-1}
\end{align*}
\]</span></li>
</ul>
<h2 id="参数假设检验-1">4.6 参数假设检验</h2>
<p>下面考虑如何构建统计量以检验原假设： <span class="math display">\[
\begin{align*}
\mathbb{H}: R\beta^o = r
\end{align*}
\]</span> 其中 <span class="math inline">\(R\)</span> 时 <span class="math inline">\(J \times K\)</span> 满秩矩阵，<span class="math inline">\(r\)</span> 是 <span class="math inline">\(J \times 1\)</span> 常向量，且 <span class="math inline">\(J \leq K\)</span>。</p>
<p>首先考虑统计量 <span class="math inline">\(R \hat\beta - r = R(\hat\beta - \beta^o) + R\beta^o - r\)</span>，所以再原假设 <span class="math inline">\(\mathbb{H}: R\beta^o = r\)</span> 下有： <span class="math display">\[
\begin{align*}
\sqrt n (R \hat\beta - r) &amp;= R\sqrt n(\hat\beta - \beta^o) \\
&amp;\overset{d}{\to} N(0, RQ^{-1}VQ^{-1}R^\prime)
\end{align*}
\]</span> <strong>1. 条件同方差情形</strong></p>
<ul>
<li><strong>定理 4.19</strong>（<span class="math inline">\(\rm{P}_{125}\)</span>）&lt; <span class="math inline">\(t\)</span> 检验 &gt;：给定假设 4.1-4.4 和 4.6，则当假设 <span class="math inline">\(\mathbb{H}_0: R\beta^o = r\)</span> 成立， <span class="math inline">\(J = 1\)</span>，且 <span class="math inline">\(n\to \infty\)</span> 时，经典 <span class="math inline">\(t\)</span> 检验统计量： <span class="math display">\[
\begin{align*}
T = \frac{R\beta^o - r}{\sqrt{s^2 R(X^\prime X)^{-1}R^\prime}}   \overset{p}{\to} N(0, 1)
\end{align*}
\]</span></li>
<li><strong>定理 4.20</strong>（<span class="math inline">\(\rm{P}_{125}\)</span>）&lt; 渐近 <span class="math inline">\(\chi^2\)</span> 检验 &gt;：给定假设 4.1-4.4 和 4.6，则当假设 <span class="math inline">\(\mathbb{H}_0: R\beta^o = r\)</span> 成立， <span class="math inline">\(J \leq 1\)</span>，且 <span class="math inline">\(n\to \infty\)</span>, <span class="math inline">\(Wald\)</span> 检验统计量： <span class="math display">\[
\begin{align*}
\mathcal{W} &amp;\equiv (R\beta^o - r)^\prime[s^2 R(X^\prime X)^{-1}R]^{-1}(R\beta^o - r) \\
&amp;= J \cdot F \overset{d}{\to} \chi^2_J
\end{align*}
\]</span></li>
<li><strong>定理 4.21</strong>（<span class="math inline">\(\rm{P}_{126}\)</span>）&lt; <span class="math inline">\((n-K)\mathcal{R}^2\)</span> 检验 &gt;：给定假设 4.1-4.6，检验以下原假设： <span class="math display">\[
\begin{align*}
\mathbb{H}_0:\beta^o_0 = \beta^o_1 = \cdots = \beta^o_k = 0
\end{align*}
\]</span> 其中，<span class="math inline">\(\beta^o_0, \beta^o_1, \cdots, \beta^o_k\)</span> 是线性回归方程: <span class="math display">\[
\begin{align*}
Y = \beta^o_0 + \beta^o_1 X_{1t} + \cdots + \beta^o_k X_{kt} + \varepsilon_t
\end{align*}
\]</span> 除截距项 <span class="math inline">\(\beta_0^o\)</span> 意外的所有回归系数。令 <span class="math inline">\(\mathcal{R}^2\)</span> 是无约束线性回归模型的决定系数，则当原假设 <span class="math inline">\(\mathbb{H}_0\)</span> 成立及 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
(n - K) \mathcal{R}^2 \overset{d}{\to} \chi^2_k
\end{align*}
\]</span> 其中，<span class="math inline">\(\mathcal{R}^2\)</span> 的定义（<span class="math inline">\(\rm{P}_{82}\)</span>）为： <span class="math display">\[
\begin{align*}
\mathcal{R}^2 = 1 - \frac{e^\prime e}{(Y - \bar Y l)^\prime (Y - \bar Y l)} = 1 - \frac{e^\prime e}{\tilde e{}^\prime \tilde e}
\end{align*}
\]</span></li>
</ul>
<p><strong>2. 条件异方差情形</strong> 在原假设 <span class="math inline">\(\mathbb{H}_0: R \beta^o = r\)</span> 成立的条件下，有： <span class="math display">\[
\begin{align*}
\sqrt n (R \hat\beta - r) \overset{d}{\to} N(0, RQ^{-1}VQ^{-1}R^\prime)
\end{align*}
\]</span> 其中，<span class="math inline">\(V = E(x_t X_T^\prime \varepsilon_t^2)\)</span>，因此有 <span class="math display">\[
\begin{align*}
\frac{R\beta^o - r}{\sqrt{R Q^{-1} V Q^{-1} R^\prime}} \overset{p}{\to} N(0, 1)
\end{align*}
\]</span> 给定 <span class="math inline">\(\hat Q \overset{p}{\to} Q, \hat V \overset{p}{\to} V\)</span>，这里 <span class="math inline">\(\hat V = X^\prime D(e) D(e)^\prime X/n\)</span>，并由 Slutsky 定理，可定义稳健性 <span class="math inline">\(t\)</span> 检验统计量： <span class="math display">\[
\begin{align*}
T_r \equiv \frac{\sqrt n(R \hat\beta - r)}{\sqrt{R \hat Q{}^{-1} \hat V \hat Q{}^{-1} R^\prime}}
\end{align*}
\]</span> 当 <span class="math inline">\(\mathbb{H}_0:R\beta^o = r\)</span> 成立，且 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
T_r \overset{p}{\to} N(0, 1)
\end{align*}
\]</span> 这里，稳健性 (Robustness) 是指，当存在条件异方差时，<span class="math inline">\(T_r\)</span> 也是渐近有效的。 - <strong>定理 4.22</strong>（<span class="math inline">\(\rm{P}_{128}\)</span>）&lt; 条件异方差下的稳健 <span class="math inline">\(t\)</span> 检验 (Robust t-Test Under Conditional Heteroskedasticity) &gt;：给定假设 4.1-4.5 和 4.7，则当原假设 <span class="math inline">\(\mathbb{H}_0: R \beta^o = r\)</span> 成立。</p>
<p>当 <span class="math inline">\(J = 1\)</span>，且 <span class="math inline">\(n \to \infty\)</span> 时，稳健 <span class="math inline">\(t\)</span> 检验统计量为： <span class="math display">\[
  \begin{align*}
  T_r \equiv \frac{\sqrt n(R \hat\beta - r)}{\sqrt{R \hat Q{}^{-1} \hat V \hat Q{}^{-1} R^\prime}} \overset{p}{\to} N(0, 1)
  \end{align*}
  \]</span> 当 <span class="math inline">\(J \geq 1\)</span>，在原假设 <span class="math inline">\(\mathbb{H}_0: R \beta^o = r\)</span> 下，有二次型： <span class="math display">\[
  \begin{align*}
  \mathcal{W} &amp;\equiv \sqrt n (R\beta^o - r)^\prime[R \hat Q{}^{-1} \hat V \hat Q{}^{-1} R^\prime)^{-1}R]^{-1}\sqrt n(R\beta^o - r) \\
  &amp;\overset{d}{\to} \chi^2_J
  \end{align*}
  \]</span> 其中， <span class="math display">\[
  \begin{align*}
  \hat Q &amp;= \frac{X^\prime X}{n}\\
  \hat V &amp;= var(X_t e_t) = \frac{X^\prime D(e)D(e)^\prime X}{n}
  \end{align*}
  \]</span> 这里，<span class="math inline">\(D(e) = diag\{e_1, 2_2, \cdots,e_n\}\)</span>。</p>
<ul>
<li><strong>定理 4.23</strong>（<span class="math inline">\(\rm{P}_{128}\)</span>）&lt; 条件异方差下的稳健 <span class="math inline">\(Wald\)</span> 检验 (Robust Wald Test Under Conditional Heteroskedasticity) &gt;：给定假设 4.1-4.5 和 4.7，则当原假设 <span class="math inline">\(\mathbb{H}_0: R \beta^o = r\)</span> 成立，且 <span class="math inline">\(n \to \infty\)</span> 时，有： <span class="math display">\[
\begin{align*}
\mathcal{W} &amp;\equiv \sqrt n (R\beta^o - r)^\prime[R \hat Q{}^{-1} \hat V \hat Q{}^{-1} R^\prime)^{-1}R]^{-1}\sqrt n(R\beta^o - r) \\
&amp;\overset{d}{\to} \chi^2_J
\end{align*}
\]</span></li>
</ul>
<h2 id="条件异方差检验">4.7 条件异方差检验</h2>
<p><strong><span class="math inline">\(White\)</span> 条件异方差检验</strong></p>
<p>考虑原假设：<span class="math inline">\(\mathbb{H}_0: E(\varepsilon_t^2|X_t) = \sigma^2\)</span>，其中，<span class="math inline">\(\varepsilon_t\)</span> 是 <span class="math inline">\(Y_t = X_t^\prime \beta^o + \varepsilon_t\)</span> 的随机扰动项。</p>
<p>非零假设为： <span class="math display">\[
\begin{align*}
\varepsilon_t^2 = \gamma^\prime \rm{vech}(X_t X_t^\prime) + v_t
\end{align*}
\]</span> 其中，<span class="math inline">\(\rm{vech}(X_t X_t^\prime)\)</span> 是一个向量化算子，它将 <span class="math inline">\(K \times K\)</span> 对称矩阵 <span class="math inline">\(X_t X_t^\prime\)</span> 下三角元素转变为一个 <span class="math inline">\(\frac{K(K+1)}{2} \times 1\)</span> 向量。在 <span class="math inline">\(mathbb{H}\)</span> 下，除截距项外，所有斜率系数均为零。</p>
<p>假设 <span class="math inline">\(E(\varepsilon_t^4|X_t) = \mu_4\)</span>，可以得到： <span class="math display">\[
\begin{align*}
(n-J-1)\tilde{\mathcal{R}} \overset{d}{\to} \chi_J^2
\end{align*}
\]</span></p>
<h1 id="平稳时间序列的线性回归模型">5 平稳时间序列的线性回归模型</h1>
]]></content>
      <categories>
        <category>Class Notes</category>
        <category>Econometrics</category>
      </categories>
      <tags>
        <tag>Econometrics</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2020/11/29/Python/</url>
    <content><![CDATA[<h1 id="python-数据类型">1. Python 数据类型</h1>
<h2 id="string">1.1 String</h2>
<ul>
<li>字符串的换行</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 长字符串的换行</span></span><br><span class="line">s2 = <span class="string">&#x27;It took me six months to write this Python tutorial. \</span></span><br><span class="line"><span class="string">    Please give me more support. \</span></span><br><span class="line"><span class="string">    I will keep it updated.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 表达式的换行</span></span><br><span class="line">num = <span class="number">20</span> + <span class="number">3</span> / <span class="number">4</span> + \</span><br><span class="line">    <span class="number">2</span> * <span class="number">3</span></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>长字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 长字符串中的换行，缩进等会如实输出</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Long string information</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>原始字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rstr = <span class="string">r&#x27;D:\Program Files\Python 3.8\python.exe&#x27;</span></span><br><span class="line">print(rstr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始字符串中的引号童谣要进行转义处理</span></span><br><span class="line">str2 = <span class="string">r&#x27;I\&#x27;m a great coder!&#x27;</span></span><br><span class="line">print(str1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串结尾的反斜杠，如表达：D:\Program Files\Python 3.8\</span></span><br><span class="line">str3 = <span class="string">r&#x27;D:\Program Files\Python 3.8&#x27;</span> + <span class="string">&#x27;\\&#x27;</span></span><br><span class="line">print(str1)</span><br></pre></td></tr></table></figure>
<h2 id="bytes">1.2 Bytes</h2>
<p>Bytes 类型表示一个字节串，时Python 3 新增的， python 2 中不存在</p>
<p>Bytes 和 string 的对比：</p>
<ul>
<li>string由若干个字符组成，以字符为单位进行操作；Bytes由字节组成</li>
<li>除了操作的处理单元不同，它们支持的所有方法基本相同</li>
<li>都是不可变序列，不能随意增加和删除数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过构造函数创建空 bytes</span></span><br><span class="line">b1 = <span class="built_in">bytes</span>()</span><br><span class="line"><span class="comment"># 通过空字符串创建空 bytes</span></span><br><span class="line">b2 = <span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 通过b前缀将字符串转换成 bytes</span></span><br><span class="line">b3 = <span class="string">b&#x27;http://c.biancheng.net/python/&#x27;</span></span><br><span class="line">print(<span class="string">&quot;b3: &quot;</span>, b3)</span><br><span class="line">print(b3[<span class="number">3</span>])</span><br><span class="line">print(b3[<span class="number">7</span>:<span class="number">22</span>])</span><br><span class="line"><span class="comment"># 为 bytes() 方法指定字符集</span></span><br><span class="line">b4 = <span class="built_in">bytes</span>(<span class="string">&#x27;C语言中文网8岁了&#x27;</span>, encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;b4: &quot;</span>, b4)</span><br><span class="line"><span class="comment"># 通过 encode() 方法将字符串转换成 bytes</span></span><br><span class="line">b5 = <span class="string">&quot;C语言中文网8岁了&quot;</span>.encode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;b5: &quot;</span>, b5)</span><br><span class="line"><span class="comment"># 通过 decode() 方法将 bytes 转化为字符串</span></span><br><span class="line">str1 = b5.decode(<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;str1: &quot;</span>, str1)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b3:  <span class="string">b&#x27;http://c.biancheng.net/python/&#x27;</span></span><br><span class="line"><span class="number">112</span></span><br><span class="line"><span class="string">b&#x27;c.biancheng.net&#x27;</span></span><br><span class="line">b4:  <span class="string">b&#x27;C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86&#x27;</span></span><br><span class="line">b5:  <span class="string">b&#x27;C\xe8\xaf\xad\xe8\xa8\x80\xe4\xb8\xad\xe6\x96\x87\xe7\xbd\x918\xe5\xb2\x81\xe4\xba\x86&#x27;</span></span><br><span class="line">str1:  C语言中文网<span class="number">8</span>岁了</span><br></pre></td></tr></table></figure>
<p>从运行结果可以发现，对于非 ASCII 字符，print 输出的是它的字符编码值（十六进制形式），而不是字符本身。非 ASCII 字符一般占用两个字节以上的内存，而 bytes 是按照单个字节来处理数据的，所以不能一次处理多个字节。</p>
<h2 id="list">1.3 list</h2>
<h3 id="创建列表">1.3.1 创建列表</h3>
<ul>
<li>使用 [] 创建列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可支持不同数据类型</span></span><br><span class="line">program = [<span class="string">&quot;C语言&quot;</span>, <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Java&quot;</span>]</span><br><span class="line"><span class="comment"># 支持创建空列表</span></span><br><span class="line">emptylist = [ ]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 list() 函数创建列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将字符串转换成列表</span></span><br><span class="line">list1 = <span class="built_in">list</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">print(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将元组转换成列表</span></span><br><span class="line">tuple1 = (<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>)</span><br><span class="line">list2 = <span class="built_in">list</span>(tuple1)</span><br><span class="line">print(list2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典转换成列表</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">42</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line">list3 = <span class="built_in">list</span>(dict1)</span><br><span class="line">print(list3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将区间转换成列表</span></span><br><span class="line">range1 = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">list4 = <span class="built_in">list</span>(range1)</span><br><span class="line">print(list4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建空列表</span></span><br><span class="line">print(<span class="built_in">list</span>())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
<h3 id="访问列表元素">1.3.2 访问列表元素</h3>
<ul>
<li><p>使用索引访问列表元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listname[i]</span><br></pre></td></tr></table></figure></li>
<li><p>使用切片访问列表元素</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listname[start : end : step]</span><br></pre></td></tr></table></figure>
<h3 id="删除列表操作">1.3.3 删除列表操作</h3>
<ul>
<li>del 关键词删除列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> listname</span><br><span class="line"><span class="comment"># listname 表示要删除列表的名称</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> listname[index]</span><br><span class="line"><span class="keyword">del</span> listname[start : end]</span><br><span class="line"><span class="comment"># 删除从索引 start 到 end 之间的元素，不包括 end 位置的元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li>pop() 方法：根据索引值删除元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listname.pop(index)</span><br><span class="line"><span class="comment"># index 表示索引值，如果不写 index 参数，默认会删除列表中的最后一个元素，类似于数据结构中“出栈”操作</span></span><br></pre></td></tr></table></figure>
<ul>
<li>remove() 方法：根据元素本身的值来进行删除操作</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># remove() 方法只会删除第一个与指定值相同的元素，而且必须保证该元素是存在的，否则会报ValueError 错误</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次删除36</span></span><br><span class="line">nums.remove(<span class="number">36</span>)</span><br><span class="line">print(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次删除36</span></span><br><span class="line">nums.remove(<span class="number">36</span>)</span><br><span class="line">print(nums)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除78</span></span><br><span class="line">nums.remove(<span class="number">78</span>)</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">40</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">40</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line"></span><br><span class="line">  File <span class="string">&quot;D:\Demo\Python\Test\Test1.py&quot;</span>, line <span class="number">493</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    nums.remove(<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line">ValueError: <span class="built_in">list</span>.remove(x): x <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<ul>
<li>clear()方法：删除列表所有元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="built_in">list</span>(<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>)</span><br><span class="line">url.clear()</span><br><span class="line">print(url)</span><br><span class="line"><span class="comment"># clear() 会清空列表</span></span><br></pre></td></tr></table></figure>
<p>​ 运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[]</span><br></pre></td></tr></table></figure>
<h3 id="列表添加元素">1.3.4 列表添加元素</h3>
<ul>
<li>用 '+' 进行拼接</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">language = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;Java&quot;</span>]</span><br><span class="line">birthday = [<span class="number">1991</span>, <span class="number">1998</span>, <span class="number">1995</span>]</span><br><span class="line">info = language + birthday</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;language =&quot;</span>, language)</span><br><span class="line">print(<span class="string">&quot;birthday =&quot;</span>, birthday)</span><br><span class="line">print(<span class="string">&quot;info =&quot;</span>, info)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">+ 运算符可以将多个修了连接起来，相当于在第一个列表的末尾添加了另一个列表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>append() 方法添加元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listname.append(obj)</span><br><span class="line"><span class="comment"># 用于在列表的末尾追加元素，obj 可以是单个元素，也可以是列表、元组等</span></span><br></pre></td></tr></table></figure>
<ul>
<li>inser() 方法插入元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listname.insert(index, obj)</span><br><span class="line"><span class="comment"># index 表示指定位置的索引值</span></span><br></pre></td></tr></table></figure>
<h3 id="列表修改元素">1.3.5 列表修改元素</h3>
<ul>
<li>修改单个元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line">nums[<span class="number">2</span>] = -<span class="number">26</span>  <span class="comment">#使用正数索引</span></span><br><span class="line">nums[-<span class="number">3</span>] = -<span class="number">66.2</span>  <span class="comment">#使用负数索引</span></span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<ul>
<li>修改一组元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># 修改第 1~4 个元素的值（不包括第4个元素）</span></span><br><span class="line">nums[<span class="number">1</span>: <span class="number">4</span>] = [<span class="number">45.25</span>, -<span class="number">77</span>, -<span class="number">52.5</span>]</span><br><span class="line">print(nums)</span><br><span class="line">·</span><br><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># 在4个位置插入元素</span></span><br><span class="line">nums[<span class="number">4</span>: <span class="number">4</span>] = [-<span class="number">77</span>, -<span class="number">52.5</span>, <span class="number">999</span>]</span><br><span class="line">print(nums)</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># 使用切片语法赋值不支持单个值，会报TypeError</span></span><br><span class="line">nums[<span class="number">4</span>: <span class="number">4</span>] = -<span class="number">77</span></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># 步长为2，为第1、3、5个元素赋值</span></span><br><span class="line">nums[<span class="number">1</span>: <span class="number">6</span>: <span class="number">2</span>] = [<span class="number">0.025</span>, -<span class="number">99</span>, <span class="number">20.5</span>]</span><br><span class="line">print(nums)</span><br></pre></td></tr></table></figure>
<h3 id="列表查找元素">1.3.6 列表查找元素</h3>
<ul>
<li>index() 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listname.index(obj,start,end)</span><br><span class="line"><span class="comment"># 查找某个元素在列表中出现的位置，不存在则报ValueError错误，查找之前最好使用count()判断一下</span></span><br><span class="line">nums = [<span class="number">40</span>, <span class="number">36</span>, <span class="number">89</span>, <span class="number">2</span>, <span class="number">36</span>, <span class="number">100</span>, <span class="number">7</span>, -<span class="number">20.5</span>, -<span class="number">999</span>]</span><br><span class="line"><span class="comment"># 检索列表中的所有元素</span></span><br><span class="line">print( nums.index(<span class="number">2</span>) )</span><br><span class="line"><span class="comment"># 检索3~7之间的元素</span></span><br><span class="line">print( nums.index(<span class="number">100</span>, <span class="number">3</span>, <span class="number">7</span>) )</span><br><span class="line"><span class="comment"># 检索4之后的元素</span></span><br><span class="line">print( nums.index(<span class="number">7</span>, <span class="number">4</span>) )</span><br><span class="line"><span class="comment"># 检索一个不存在的元素</span></span><br><span class="line">print( nums.index(<span class="number">55</span>) )</span><br></pre></td></tr></table></figure>
<ul>
<li>count() 方法：统计某个元素在列表中出现的次数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">listname.count(obj)</span><br><span class="line"><span class="comment"># count() 防回0，则表示列表中不存在该元素</span></span><br></pre></td></tr></table></figure>
<h2 id="tuple">1.4 tuple</h2>
<h3 id="创建元组">1.4.1 创建元组</h3>
<ul>
<li>使用 () 直接创建</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplename = (element1, element2, ... )</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 tuple() 函数创建元组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tuple</span>(data)</span><br><span class="line"><span class="comment"># data 表示可以转化为元组的数据，包括字符串、元组、range 对象等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串转换成元组</span></span><br><span class="line">tup1 = <span class="built_in">tuple</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">print(tup1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转换成元组</span></span><br><span class="line">list1 = [<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>]</span><br><span class="line">tup2 = <span class="built_in">tuple</span>(list1)</span><br><span class="line">print(tup2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典转换成元组</span></span><br><span class="line">dict1 = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">42</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">9</span>&#125;</span><br><span class="line">tup3 = <span class="built_in">tuple</span>(dict1)</span><br><span class="line">print(tup3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将区间转换成元组</span></span><br><span class="line">range1 = <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">tup4 = <span class="built_in">tuple</span>(range1)</span><br><span class="line">print(tup4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建空元组</span></span><br><span class="line">print(<span class="built_in">tuple</span>())</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">()</span><br></pre></td></tr></table></figure>
<h3 id="访问元组元素">1.4.2 访问元组元素</h3>
<ul>
<li>使用索引访问元组元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplename[i]</span><br></pre></td></tr></table></figure>
<ul>
<li>使用切片访问元组元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tuplename[start: end: step]</span><br></pre></td></tr></table></figure>
<h3 id="修改元组">1.4.3 修改元组</h3>
<p>元组是不可变序列，元组中的元素不能被修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">100</span>, <span class="number">0.5</span>, -<span class="number">36</span>, <span class="number">73</span>)</span><br><span class="line">print(tup)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用新的元组去替代旧的元组</span></span><br><span class="line">tup = (<span class="string">&#x27;Shell脚本&#x27;</span>,<span class="string">&quot;http://c.biancheng.net/shell/&quot;</span>)</span><br><span class="line">print(tup)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 + 运算符拼接形成新的元组</span></span><br></pre></td></tr></table></figure>
<h3 id="删除元组">1.4.4 删除元组</h3>
<ul>
<li>del 关键字</li>
</ul>
<h2 id="dict">1.5 dict</h2>
<p>dict 是一种无序的、可变的序列，他的元素以“键值对（key - value）”的形式存储</p>
<p><img src="https://s3.ax1x.com/2020/11/30/Dg2hm6.gif" alt="reflect1" style="zoom:80%;" /></p>
<center>
Fig. 1-1 字典数据结构
</center>
<h3 id="创建字典">1.5.1 创建字典</h3>
<ul>
<li>使用 {} 创建字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname = &#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;key2&#x27;</span>:<span class="string">&#x27;value2&#x27;</span>, ..., <span class="string">&#x27;keyn&#x27;</span>:valuen&#125;</span><br><span class="line"><span class="comment"># 同义字典中的各个键必须唯一，不能重复</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过 fromkeys() 方法创建字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname = <span class="built_in">dict</span>.fromkeys(<span class="built_in">list</span>, value = <span class="literal">None</span>)</span><br><span class="line"><span class="comment"># list 参数表示字典中的所有键的列表，value参数表示默认值，如果不写，则为空值None</span></span><br><span class="line"></span><br><span class="line">knowledge = &#123;<span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>&#125;</span><br><span class="line">scores = <span class="built_in">dict</span>.fromkeys(knowledge, <span class="number">60</span>)</span><br><span class="line">print(scores)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 dict() 映射函数创建字典</li>
</ul>
<center>
表1-1 dict() 函数创建字典
</center>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>创建格式</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a = dict(str1=value1, str2=value2, str3=value3)</td>
<td>str 表示字符串类型的键，value 表示键对应的值。使用此方式创建字典时，字符串不能带引号。</td>
</tr>
<tr class="even">
<td>#方式1<br />demo = [('two',2), ('one',1), ('three',3)] <br />#方式2<br /> demo = [['two',2], ['one',1], ['three',3]] <br />#方式3 <br />demo = (('two',2), ('one',1), ('three',3)) <br />#方式4 <br />demo = (['two',2], ['one',1], ['three',3]) a = dict(demo)</td>
<td>向 dict() 函数传入列表或元组，而它们中的元素又各自是包含 2 个元素的列表或元组，其中第一个元素作为键，第二个元素作为值。</td>
</tr>
<tr class="odd">
<td>keys = ['one', 'two', 'three'] <br />#还可以是字符串或元组 <br />values = [1, 2, 3] <br />#还可以是字符串或元组 <br />a = dict( zip(keys, values) )</td>
<td>通过应用 dict() 函数和 zip() 函数，可将前两个列表转换为对应的字典。</td>
</tr>
</tbody>
</table>
<p>如果不为 dict() 函数传入任何参数，则表示创建空字典</p>
<h3 id="访问字典">1.5.2 访问字典</h3>
<ul>
<li>利用索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname[key]</span><br><span class="line"><span class="comment"># 由于字典中的元素是无序的，每个元素的位置都不固定，所以字典也不能像列表和元组那样，采用切片的方式一次性访问多个元素</span></span><br><span class="line"></span><br><span class="line">tup = ([<span class="string">&#x27;two&#x27;</span>,<span class="number">26</span>], [<span class="string">&#x27;one&#x27;</span>,<span class="number">88</span>], [<span class="string">&#x27;three&#x27;</span>,<span class="number">100</span>], [<span class="string">&#x27;four&#x27;</span>,-<span class="number">59</span>])</span><br><span class="line">dic = <span class="built_in">dict</span>(tup)</span><br><span class="line">print(dic[<span class="string">&#x27;one&#x27;</span>])  <span class="comment">#键存在</span></span><br><span class="line">print(dic[<span class="string">&#x27;five&#x27;</span>])  <span class="comment">#键不存在</span></span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">88</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">    File <span class="string">&quot;C:\Users\mozhiyan\Desktop\demo.py&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        print(dic[<span class="string">&#x27;five&#x27;</span>])  <span class="comment">#键不存在</span></span><br><span class="line">KeyError: <span class="string">&#x27;five&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>get() 方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname.get(key[,default])</span><br><span class="line"><span class="comment"># default 用于指定要查询的键不存在时，此方法返回的默认值，如果不指定，则返回 None</span></span><br><span class="line"></span><br><span class="line">a = <span class="built_in">dict</span>(two=<span class="number">0.65</span>, one=<span class="number">88</span>, three=<span class="number">100</span>, four=-<span class="number">59</span>)</span><br><span class="line">print( a.get(<span class="string">&#x27;one&#x27;</span>) )</span><br><span class="line">print( a.get(<span class="string">&#x27;five&#x27;</span>, <span class="string">&#x27;该键不存在&#x27;</span>) )</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">88</span></span><br><span class="line">该键不存在</span><br></pre></td></tr></table></figure>
<h3 id="字典操作">1.6.3 字典操作</h3>
<ul>
<li>删除字典</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> dictname</span><br></pre></td></tr></table></figure>
<ul>
<li>添加键值对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname[key] = value</span><br></pre></td></tr></table></figure>
<ul>
<li>修改键值对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname[key] = new value</span><br><span class="line"><span class="comment"># key值不能被修改，只能修改value</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除键值对</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span> dictname[key]</span><br></pre></td></tr></table></figure>
<ul>
<li>判断字典中是否存在指定键值对( in 或 not in 运算符)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="comment"># 判断 a 中是否包含名为&#x27;数学&#x27;的key</span></span><br><span class="line">print(<span class="string">&#x27;数学&#x27;</span> <span class="keyword">in</span> a) <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 判断 a 是否包含名为&#x27;物理&#x27;的key</span></span><br><span class="line">print(<span class="string">&#x27;物理&#x27;</span> <span class="keyword">in</span> a) <span class="comment"># False</span></span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="字典方法">1.6.4 字典方法</h3>
<ul>
<li><p>keys() : 返回字典的所有key</p></li>
<li><p>values() : 返回字典所有键值对应的value</p></li>
<li><p>items() : 防回字典中所有的键值对</p></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scores = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line">print(scores.keys())</span><br><span class="line">print(scores.values())</span><br><span class="line">print(scores.items())</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict_keys([<span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>])</span><br><span class="line">dict_values([<span class="number">95</span>, <span class="number">89</span>, <span class="number">90</span>])</span><br><span class="line">dict_items([(<span class="string">&#x27;数学&#x27;</span>, <span class="number">95</span>), (<span class="string">&#x27;语文&#x27;</span>, <span class="number">89</span>), (<span class="string">&#x27;英语&#x27;</span>, <span class="number">90</span>)])</span><br><span class="line"><span class="comment"># keys()、values() 和 items() 返回值的类型分别为 dict_keys、dict_values 和 dict_items</span></span><br></pre></td></tr></table></figure>
<p>在 Python 2.x 中，上面三个方法的返回值都是列表（list）类型。但在 Python 3.x 中，它们的返回值并不是我们常见的列表或者元组类型，因为 Python 3.x 不希望用户直接操作这几个方法的返回值。</p>
<p>在 Python 3.x 中如果想使用这三个方法返回的数据，一般有下面两种方案：</p>
<ol type="1">
<li>使用 list() 函数，将他们转化为列表</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line">b = <span class="built_in">list</span>(a.keys())</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;数学&#x27;</span>, <span class="string">&#x27;语文&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>]</span><br></pre></td></tr></table></figure>
<ol start="2" type="1">
<li>使用 for in 循环遍历</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> a.keys():</span><br><span class="line">    print(k,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;\n---------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> v <span class="keyword">in</span> a.values():</span><br><span class="line">    print(v,end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">print(<span class="string">&quot;\n---------------&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> a.items():</span><br><span class="line">    print(<span class="string">&quot;key:&quot;</span>,k,<span class="string">&quot; value:&quot;</span>,v)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">数学 语文 英语</span><br><span class="line">---------------</span><br><span class="line"><span class="number">95</span> <span class="number">89</span> <span class="number">90</span></span><br><span class="line">---------------</span><br><span class="line">key: 数学  value: <span class="number">95</span></span><br><span class="line">key: 语文  value: <span class="number">89</span></span><br><span class="line">key: 英语  value: <span class="number">90</span></span><br></pre></td></tr></table></figure>
<ul>
<li>update() 方法</li>
</ul>
<p>update方法可以使用一个字典所包含的简直对来更新已有的字典。</p>
<p>在执行 update（）方法是，如果被更新的字典中已包含对应的键值对，那么原 value会被覆盖；如果不包含对应的键值对，则该键值对被添加进去</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line">a.update(&#123;<span class="string">&#x27;one&#x27;</span>:<span class="number">4.5</span>, <span class="string">&#x27;four&#x27;</span>: <span class="number">9.3</span>&#125;)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">4.5</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;four&#x27;</span>: <span class="number">9.3</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>pop() 和 popitem() 方法</li>
</ul>
<p>都是用来删除字典中键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname.pop(key)</span><br><span class="line">dictname.popitem()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;化学&#x27;</span>: <span class="number">83</span>, <span class="string">&#x27;生物&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;物理&#x27;</span>: <span class="number">89</span>&#125;</span><br><span class="line">print(a)</span><br><span class="line">a.pop(<span class="string">&#x27;化学&#x27;</span>)</span><br><span class="line">print(a)</span><br><span class="line">a.popitem()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;化学&#x27;</span>: <span class="number">83</span>, <span class="string">&#x27;生物&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;物理&#x27;</span>: <span class="number">89</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;生物&#x27;</span>: <span class="number">98</span>, <span class="string">&#x27;物理&#x27;</span>: <span class="number">89</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;数学&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;语文&#x27;</span>: <span class="number">89</span>, <span class="string">&#x27;英语&#x27;</span>: <span class="number">90</span>, <span class="string">&#x27;生物&#x27;</span>: <span class="number">98</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>setdefault() 方法：返回某个 key 对应的 value</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dictname.setdefault(key, defaultvalue)</span><br><span class="line"><span class="comment"># defaultvalue 表示默认值（可以不写，不写的话是 None）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当指定的 key 不存在时，setdefault() 会先为这个不存在的 key 设置一个默认的 defaultvalue，然后再返回 defaultvalue</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">也就是说，setdefault() 方法总能返回指定 key 对应的 value：</span></span><br><span class="line"><span class="string">1) 如果该 key 存在，那么直接返回该 key 对应的 value；</span></span><br><span class="line"><span class="string">2) 如果该 key 不存在，那么先为该 key 设置默认的 defaultvalue，然后再返回该 key 对应的 defaultvalue。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="字典拷贝">1.6.5 字典拷贝</h3>
<p>copy() 返回一个字典的拷贝，即一个具有相同键值对的新字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝。</p>
<p>拿拷贝字典 a 为例，copy() 方法只会对最表层的键值对进行深拷贝，也就是说，它会再申请一块内存用来存放 {'one': 1, 'two': 2, 'three': []}；而对于某些列表类型的值来说，此方法对其做的是浅拷贝，也就是说，b 中的 [1,2,3] 的值不是自己独有，而是和 a 共有。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line"><span class="comment"># 向 a 中添加新键值对，由于b已经提前将 a 所有键值对都深拷贝过来，因此 a 添加新键值对，不会影响 b。</span></span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;four&#x27;</span>]=<span class="number">100</span></span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于 b 和 a 共享[1,2,3]（浅拷贝），因此移除 a 中列表中的元素，也会影响 b。</span></span><br><span class="line">a[<span class="string">&#x27;three&#x27;</span>].remove(<span class="number">1</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;four&#x27;</span>: <span class="number">100</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>], <span class="string">&#x27;four&#x27;</span>: <span class="number">100</span>&#125;</span><br><span class="line">&#123;<span class="string">&#x27;one&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;two&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>]&#125;</span><br></pre></td></tr></table></figure>
<h2 id="set">1.6 set</h2>
<p>同一集合中，只能存储 <strong>不可变</strong> 的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些<strong>可变</strong> 的数据类型，否则会抛出 TypeError 错误。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;element1,element2,...,elementn&#125;</span><br><span class="line"><span class="comment"># Python 中有两种集合类型，一种是 set 类型的集合，另一种是 frozenset 类型的集合，它们唯一的区别是，set 类型集合可以做添加、删除元素的操作，而 forzenset 类型集合不行</span></span><br></pre></td></tr></table></figure>
<h3 id="创建-set-集合">1.6.1 创建 set 集合</h3>
<ul>
<li>使用 {} 创建</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setname = &#123;element1,element2,...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>set() 函数创建集合</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setname = <span class="built_in">set</span>(iteration)</span><br><span class="line"></span><br><span class="line"><span class="comment"># for example</span></span><br><span class="line">set1 = <span class="built_in">set</span>(<span class="string">&quot;c.biancheng.net&quot;</span>)</span><br><span class="line">set2 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">set3 = <span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">print(<span class="string">&quot;set1:&quot;</span>,set1)</span><br><span class="line">print(<span class="string">&quot;set2:&quot;</span>,set2)</span><br><span class="line">print(<span class="string">&quot;set3:&quot;</span>,set3)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set1: &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;</span><br><span class="line">set2: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">set3: &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历-set-集合元素">1.6.2 遍历 set 集合元素</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> ele <span class="keyword">in</span> a:</span><br><span class="line">    print(ele,end=<span class="string">&#x27; &#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="删除-set-集合">1.6.3 删除 set 集合</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="string">&#x27;c&#x27;</span>,<span class="number">1</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>),<span class="string">&#x27;c&#x27;</span>&#125;</span><br><span class="line">print(a)</span><br><span class="line"><span class="keyword">del</span>(a)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>
<h3 id="集合的基本操作">1.6.4 集合的基本操作</h3>
<ul>
<li>添加元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setname.add(element)</span><br><span class="line"><span class="comment"># 使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据，否则 Python 解释器会报 TypeError 错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除指定元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">setname.remove(element)</span><br></pre></td></tr></table></figure>
<ul>
<li>布尔运算（交集、并集、差集以及对称差集运算）</li>
</ul>
<p><img src="https://s3.ax1x.com/2020/11/30/DgR9hQ.gif" alt="booleanpic" style="zoom:80%;" /></p>
<center>
Fig. 1-2 集合的布尔运算
</center>
<center>
表 1-2 集合的布尔运算
</center>
<table>
<thead>
<tr class="header">
<th>运算操作</th>
<th>Python运算符</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>交集</td>
<td>&amp;</td>
<td>取两集合公共的元素</td>
<td>&gt;&gt;&gt; set1 &amp; set2 {3}</td>
</tr>
<tr class="even">
<td>并集</td>
<td>|</td>
<td>取两集合全部的元素</td>
<td>&gt;&gt;&gt; set1 | set2 {1,2,3,4,5}</td>
</tr>
<tr class="odd">
<td>差集</td>
<td>-</td>
<td>取一个集合中另一集合没有的元素</td>
<td>&gt;&gt;&gt; set1 - set2 {1,2}</td>
</tr>
<tr class="even">
<td>对称差集</td>
<td>^</td>
<td>取集合 A 和 B 中不属于 A&amp;B 的元素</td>
<td>&gt;&gt;&gt; set1 ^ set2 {1,2,4,5}</td>
</tr>
</tbody>
</table>
<h3 id="set-集合方法详解">1.6.5 set 集合方法详解</h3>
<p><a href="http://c.biancheng.net/view/4402.html">set 集合方法详解</a></p>
<h1 id="python-函数操作">2. Python 函数操作</h1>
<h2 id="系统函数">2.1 系统函数</h2>
<h3 id="input">2.1.1 input()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(tipmsg)</span><br></pre></td></tr></table></figure>
<ul>
<li>str 表示一个字符串类型的变量，input 会将读取到的字符串放入 str 中</li>
<li>tipmsg 表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写 tipmsg，就不会有任何提示信息</li>
</ul>
<h3 id="pirnt">2.1.2 pirnt()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(value,..., sep =<span class="string">&#x27;&#x27;</span>, end = <span class="string">&#x27;\n&#x27;</span>, file = sys.stdout, flush = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<p>value 参数可以接受任意多个变量或值，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_name = <span class="string">&#x27;Charlie&#x27;</span></span><br><span class="line">user_age = <span class="number">8</span></span><br><span class="line"><span class="comment">#同时输出多个变量和字符串</span></span><br><span class="line">print(<span class="string">&quot;读者名：&quot;</span>,user_name,<span class="string">&quot;年龄：&quot;</span>,user_age, sep = <span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="字符串方法">2.2 字符串方法</h2>
<h3 id="字符串拼接">2.2.1 字符串拼接</h3>
<ul>
<li>字符串和数字的拼接</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>(obj)</span><br><span class="line"><span class="built_in">repr</span>(obj)</span><br><span class="line"><span class="comment">#  Python 不允许直接拼接数字和字符串，需要借助str() 和 repr() 函数将数字转换为字符串</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>str() 和 repr() 的区别</strong></p>
<p>str() 和 repr() 函数虽然都可以将数字转换成字符串，但它们之间是有区别的： 1) str() 将数据转换成适合人类阅读的字符串形式 2) repr() 将数据转换成适合解释器阅读的字符串形式（Python 表达式的形式），适合在开发和调试阶段使用；如果没有等价的语法，则会发生 SyntaxError 异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span></span><br><span class="line">s_str = <span class="built_in">str</span>(s)</span><br><span class="line">s_repr = <span class="built_in">repr</span>(s)</span><br><span class="line">print( <span class="built_in">type</span>(s_str) )</span><br><span class="line"><span class="built_in">print</span> (s_str)</span><br><span class="line">print( <span class="built_in">type</span>(s_repr) )</span><br><span class="line"><span class="built_in">print</span> (s_repr)</span><br></pre></td></tr></table></figure>
<p>​ 运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">http</span>:</span>//c.biancheng.net/shell/</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">&#x27;<span class="title">http</span>:</span>//c.biancheng.net/shell/<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="截取字符串">2.2.2 截取字符串</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">strname[index]</span><br><span class="line">strname[start : end : step]</span><br></pre></td></tr></table></figure>
<h3 id="len">2.2.3 len()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">len</span>（<span class="built_in">str</span>）</span><br><span class="line"><span class="comment"># 在 Python 中，不同的字符所占的字节数不同，数字、英文字母、小数点、下划线以及空格，各占一个字节，而一个汉字可能占 2~4 个字节，具体占多少个，取决于采用的编码方式。例如，汉字在 GBK/GB2312 编码中占用 2 个字节，而在 UTF-8 编码中一般占用 3 个字节</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s3.ax1x.com/2020/11/30/DgRPpj.gif" /></p>
<center>
图 2-1 UTF-8
</center>
<h3 id="split">2.2.4 split()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.split(sep,maxsplit)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">str: 表示要分割的字符串</span></span><br><span class="line"><span class="string">sep: 用于指定分隔符，可以包含多个字符，默认为 None，表示所有空字符</span></span><br><span class="line"><span class="string">maxsplit：可选参数，用于指定分割的次数，最后列表中子串的个数最多为 maxsplit+1。如果不指定或者指定为 -1，则表示分割次数没有限制。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="join">2.2.5 join()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">newstr = <span class="built_in">str</span>.join(iterable)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">newstr：表示合并后生成的新字符串；</span></span><br><span class="line"><span class="string">str：用于指定合并时的分隔符；</span></span><br><span class="line"><span class="string">iterable：做合并操作的源字符串数据，允许以列表、元组等形式提供。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span> = [<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;biancheng&#x27;</span>,<span class="string">&#x27;net&#x27;</span>]</span><br><span class="line"><span class="string">&#x27;.&#x27;</span>.join(<span class="built_in">list</span>)</span><br><span class="line"><span class="comment"># 运行结果： &#x27;c.biancheng.net&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="count">2.2.6 count()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.count(sub[,start[,end]])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">str：表示原字符串；</span></span><br><span class="line"><span class="string">sub：表示要检索的字符串；</span></span><br><span class="line"><span class="string">start：指定检索的起始位置，也就是从什么位置开始检测。如果不指定，默认从头开始检索；</span></span><br><span class="line"><span class="string">end：指定检索的终止位置，如果不指定，则表示一直检索到结尾。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;c.biancheng.net&quot;</span></span><br><span class="line"><span class="built_in">str</span>.count(<span class="string">&#x27;.&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="find">2.2.7 find()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.find(sub[,start[,end]])</span><br></pre></td></tr></table></figure>
<h3 id="index">2.2.8 index()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.index(sub[,start[,end]])</span><br><span class="line"><span class="comment"># 同 find() 方法类似，index() 方法也可以用于检索是否包含指定的字符串，不同之处在于，当指定的字符串不存在时，index() 方法会抛出异常</span></span><br></pre></td></tr></table></figure>
<h3 id="对齐">2.2.9 对齐</h3>
<ul>
<li>ljust()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S.ljust(width[, fillchar])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">S：表示要进行填充的字符串；</span></span><br><span class="line"><span class="string">width：表示包括本身长度在内，字符串要占的总长度；</span></span><br><span class="line"><span class="string">fillchar：作为可选参数，用来指定填充字符串时所用的字符，默认情况使用空格。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>rjust()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S.rjust(width[, fillchar])</span><br></pre></td></tr></table></figure>
<ul>
<li>center()</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">S.center(width[, fillchar])</span><br></pre></td></tr></table></figure>
<h3 id="startswith-和-endswith">2.2.10 startswith() 和 endswith()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.startswith(sub[,start[,end]])</span><br><span class="line"><span class="comment"># 检索字符串是否以指定字符串开头，如果是返回 True；反之返回 False</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>.endswith(sub[,start[,end]])</span><br><span class="line"><span class="comment"># endswith() 方法用于检索字符串是否以指定字符串结尾，如果是则返回 True；反之则返回 False</span></span><br></pre></td></tr></table></figure>
<h3 id="大小写转换">2.2.11 大小写转换</h3>
<ul>
<li>title()</li>
<li>lower()</li>
<li>upper()</li>
</ul>
<h3 id="strip">2.2.12 strip()</h3>
<ul>
<li>strip()：删除串前后（左右两侧）的空格或特殊字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="string">&quot;  c.biancheng.net \t\n\r&quot;</span></span><br><span class="line"><span class="built_in">str</span>.strip()</span><br><span class="line"><span class="comment"># &#x27;c.biancheng.net&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span>.strip(<span class="string">&quot; ,\r&quot;</span>)</span><br><span class="line"><span class="comment"># &#x27;c.biancheng.net \t\n&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">str</span></span><br><span class="line"><span class="comment"># &#x27;  c.biancheng.net \t\n\r&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># strip() 并没有改变字符本身</span></span><br></pre></td></tr></table></figure>
<ul>
<li>lstrip()：删除字符串前面（左边）的空格或特殊字符</li>
<li>rstrip()：删除字符串后面（右边）的空格或特殊字符</li>
</ul>
<h3 id="format">2.2.13 format()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.<span class="built_in">format</span>(args)</span><br><span class="line"><span class="comment"># str 用于指定字符串的显示样式；args 用于指定要进行格式转换的项，如果有多项，之间有逗号进行分割</span></span><br></pre></td></tr></table></figure>
<p>学习 format() 方法的难点，在于搞清楚 str 显示样式的书写格式。在创建显示样式模板时，需要使用<code>&#123;&#125;</code>和<code>：</code>来指定占位符，其完整的语法格式为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123; [index][ : [ [fill] align] [sign] [<span class="comment">#] [width] [.precision] [type] ] &#125;</span></span><br></pre></td></tr></table></figure>
<p>具体参照：<a href="http://c.biancheng.net/view/4301.html">format完整</a></p>
<h3 id="encode-和-decode">2.2.14 encode() 和 decode()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span>.encode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br><span class="line"><span class="comment"># encoding=&quot;GBK&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bytes</span>.decode([encoding=<span class="string">&quot;utf-8&quot;</span>][,errors=<span class="string">&quot;strict&quot;</span>])</span><br></pre></td></tr></table></figure>
<center>
表 2-2 encode() 参数
</center>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>str</td>
<td>表示要进行转换的字符串。</td>
</tr>
<tr class="even">
<td>encoding = "utf-8"</td>
<td>指定进行编码时采用的字符编码，该选项默认采用 utf-8 编码。例如，如果想使用简体中文，可以设置 gb2312。<br /> 当方法中只使用这一个参数时，可以省略前边的“encoding=”，直接写编码格式，例如 str.encode("UTF-8")。</td>
</tr>
<tr class="odd">
<td>errors = "strict"</td>
<td>指定错误处理方式，其可选择值可以是：<br />1) strict：遇到非法字符就抛出异常。<br />2) ignore：忽略非法字符。<br />3) replace：用“？”替换非法字符。<br />4) xmlcharrefreplace：使用 xml 的字符引用。该参数的默认值为 strict。</td>
</tr>
</tbody>
</table>
<h3 id="dir-和-help">2.2.15 dir() 和 help()</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dir</span>(obj)</span><br><span class="line"><span class="built_in">help</span>(obj)</span><br></pre></td></tr></table></figure>
<h1 id="python-运算符">3. Python 运算符</h1>
<h2 id="escape-character">3.1 Escape character</h2>
<p>转义字符以 <code>\0、\x</code> 开头，以 <code>\x</code> 开头表示后跟十六进制形势的编码值，Python中的转义字符只能使用八进制或十六进制</p>
<p>ASCII编码共收录了128个字符，<code>\0</code> 、<code>\x</code> 后面最多只能跟两位数字，所以八进制形势并不能表示所有的ASCII字符，只有十六进制才能表示所有的ASCII字符</p>
<center>
表3-1 转义字符一览表
</center>
<table>
<thead>
<tr class="header">
<th>转义字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>换行符，将光标位置移到下一行开头。</td>
</tr>
<tr class="even">
<td> 回车符，将光标位置移到本行开头。</td>
<td></td>
</tr>
<tr class="odd">
<td> 水平制表符，也即 Tab 键，一般相当于四个空格。</td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>蜂鸣器响铃。注意不是喇叭发声，现在的计算机很多都不带蜂鸣器了，所以响铃不一定有效。</td>
</tr>
<tr class="odd">
<td> 退格（Backspace），将光标位置移到前一列。</td>
<td></td>
</tr>
<tr class="even">
<td>\\</td>
<td>反斜线</td>
</tr>
<tr class="odd">
<td>\'</td>
<td>单引号</td>
</tr>
<tr class="even">
<td>\"</td>
<td>双引号</td>
</tr>
<tr class="odd">
<td>\</td>
<td>在字符串行尾的续行符，即一行未完，转到下一行继续写。</td>
</tr>
</tbody>
</table>
<h2 id="位运算符">3.2 位运算符</h2>
<p>位运算符是指按照数据在内存中的二进制位进行操作</p>
<center>
表3-2 位运算符一览表
</center>
<table>
<thead>
<tr class="header">
<th>位运算符</th>
<th>说明</th>
<th>适用形式</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&amp;</td>
<td>按位与</td>
<td>a &amp; b</td>
<td>4 &amp; 5</td>
</tr>
<tr class="even">
<td>|</td>
<td>按位或</td>
<td>a | b</td>
<td>4 | 5</td>
</tr>
<tr class="odd">
<td>^</td>
<td>按位异或</td>
<td>a ^ b</td>
<td>4 ^ 5</td>
</tr>
<tr class="even">
<td>~</td>
<td>按位取反</td>
<td>~a</td>
<td>~4</td>
</tr>
<tr class="odd">
<td>&lt;&lt;</td>
<td>按位左移</td>
<td>a &lt;&lt; b</td>
<td>4 &lt;&lt; 2，表示整数 4 按位左移 2 位</td>
</tr>
<tr class="even">
<td>&gt;&gt;</td>
<td>按位右移</td>
<td>a &gt;&gt; b</td>
<td>4 &gt;&gt; 2，表示整数 4 按位右移 2 位</td>
</tr>
</tbody>
</table>
<h2 id="比较运算符">3.3 比较运算符</h2>
<center>
表3-3 比较运算符一览表
</center>
<table>
<thead>
<tr class="header">
<th>比较运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>&gt;</td>
<td>大于，如果<code>&gt;</code>前面的值大于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr class="even">
<td>&lt;</td>
<td>小于，如果<code>&lt;</code>前面的值小于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>==</td>
<td>等于，如果<code>==</code>两边的值相等，则返回 True，否则返回 False。</td>
</tr>
<tr class="even">
<td>&gt;=</td>
<td>大于等于（等价于数学中的 ≥），如果<code>&gt;=</code>前面的值大于或者等于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>&lt;=</td>
<td>小于等于（等价于数学中的 ≤），如果<code>&lt;=</code>前面的值小于或者等于后面的值，则返回 True，否则返回 False。</td>
</tr>
<tr class="even">
<td>!=</td>
<td>不等于（等价于数学中的 ≠），如果<code>!=</code>两边的值不相等，则返回 True，否则返回 False。</td>
</tr>
<tr class="odd">
<td>is</td>
<td>判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。</td>
</tr>
<tr class="even">
<td>is not</td>
<td>判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。</td>
</tr>
</tbody>
</table>
<ul>
<li>== 和 is 的区别</li>
</ul>
<p>== 用来比较两个变量的值是否相等，而 is 则用来比对两个变量引用的是否是同一个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time  <span class="comment">#引入time模块</span></span><br><span class="line">t1 = time.gmtime() <span class="comment"># gmtime()用来获取当前时间</span></span><br><span class="line">t2 =  time.gmtime()</span><br><span class="line">print(t1 == t2) <span class="comment">#输出True</span></span><br><span class="line">print(t1 <span class="keyword">is</span> t2) <span class="comment">#输出False</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">time 模块的 gmtime() 方法用来获取当前的系统时间，精确到秒级，因为程序运行非常快，所以 t1 和 t1 得到的时间是一样的。== 用来判断 t1 和 t2 的值是否相等，所以返回 True。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="逻辑运算符">3.4 逻辑运算符</h2>
<center>
表3-4 逻辑运算符一览表
</center>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 27%" />
<col style="width: 7%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="header">
<th>逻辑运算符</th>
<th>含义</th>
<th>基本格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>and</td>
<td>逻辑与运算，等价于数学中的“且”</td>
<td>a and b</td>
<td>当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。</td>
</tr>
<tr class="even">
<td>or</td>
<td>逻辑或运算，等价于数学中的“或”</td>
<td>a or b</td>
<td>当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。</td>
</tr>
<tr class="odd">
<td>not</td>
<td>逻辑非运算，等价于数学中的“非”</td>
<td>not a</td>
<td>如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。</td>
</tr>
</tbody>
</table>
<h2 id="三目运算符">3.5 三目运算符</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">max</span> = a <span class="keyword">if</span> a&gt;b <span class="keyword">else</span> b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述代码实现如下功能</span></span><br><span class="line"><span class="keyword">if</span> a&gt;b:</span><br><span class="line">    <span class="built_in">max</span> = a;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">max</span> = b;</span><br></pre></td></tr></table></figure>
<h2 id="数字操作符">3.6 数字操作符</h2>
<center>
表 3-5 数字操作符（优先级递减）
</center>
<table>
<thead>
<tr class="header">
<th>操作符</th>
<th>操作</th>
<th>示例</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>**</td>
<td>指数</td>
<td>2**3</td>
<td>8</td>
</tr>
<tr class="even">
<td>%</td>
<td>取模/取余数</td>
<td>22%8</td>
<td>6</td>
</tr>
<tr class="odd">
<td>//</td>
<td>整除/商数取整</td>
<td>22//8</td>
<td>2</td>
</tr>
<tr class="even">
<td>/</td>
<td>除法</td>
<td>22/8</td>
<td>2.75</td>
</tr>
<tr class="odd">
<td>*</td>
<td>乘法</td>
<td>3*5</td>
<td>15</td>
</tr>
<tr class="even">
<td>*</td>
<td>字符串复制</td>
<td>['s'] * 4</td>
<td>['s', ',s', 's', 's']</td>
</tr>
<tr class="odd">
<td>-</td>
<td>减法</td>
<td>5-2</td>
<td>3</td>
</tr>
<tr class="even">
<td>+</td>
<td>加法</td>
<td>2+2</td>
<td>4</td>
</tr>
</tbody>
</table>
<h1 id="python-流程控制">4. Python 流程控制</h1>
<h2 id="pass">4.1 pass</h2>
<p><strong>pass</strong> 是 Python 中的关键字，用来让解释器跳过此处，什么都不做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">age = <span class="built_in">int</span>( <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄：&quot;</span>) )</span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">12</span> :</span><br><span class="line">    print(<span class="string">&quot;婴幼儿&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">12</span> <span class="keyword">and</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    print(<span class="string">&quot;青少年&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt; <span class="number">30</span>:</span><br><span class="line">    print(<span class="string">&quot;成年人&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">30</span> <span class="keyword">and</span> age &lt; <span class="number">50</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;老年人&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="assert-断言">4.2 assert 断言</h2>
<p>assert 语句，又称断言语句，可看做是功能缩小版的 if 语句，用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，会报 AssertionError 错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> 表达式</span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能与下式类似</span></span><br><span class="line"><span class="keyword">if</span> 表达式==<span class="literal">True</span>:</span><br><span class="line">    程序继续执行</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    程序报 AssertionError 错误</span><br></pre></td></tr></table></figure>
<h2 id="break-和-continue">4.3 break 和 continue</h2>
<ul>
<li><p>break 语句，可以完全终止当前循环</p></li>
<li><p>continue 语句，可以跳过执行本次循环体中剩余的代码，转而执行下一次的循环</p></li>
</ul>
<h2 id="zip">4.4 zip()</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">zip</span>(iterable, ...)</span><br><span class="line"><span class="comment">#  iterable,... 表示多个列表、元组、字典、集合、字符串，甚至还可以为 range() 区间</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_list = [<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line">my_tuple = (<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>)</span><br><span class="line"></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(my_list,my_tuple)])</span><br><span class="line"></span><br><span class="line">my_dic = &#123;<span class="number">31</span>:<span class="number">2</span>,<span class="number">32</span>:<span class="number">4</span>,<span class="number">33</span>:<span class="number">5</span>&#125;</span><br><span class="line">my_set = &#123;<span class="number">41</span>,<span class="number">42</span>,<span class="number">43</span>,<span class="number">44</span>&#125;</span><br><span class="line"></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(my_dic)])</span><br><span class="line"></span><br><span class="line">my_pychar = <span class="string">&quot;python&quot;</span></span><br><span class="line">my_shechar = <span class="string">&quot;shell&quot;</span></span><br><span class="line"></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">zip</span>(my_pychar,my_shechar)])</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="number">11</span>, <span class="number">21</span>), (<span class="number">12</span>, <span class="number">22</span>), (<span class="number">13</span>, <span class="number">23</span>)]</span><br><span class="line">[(<span class="number">31</span>,), (<span class="number">32</span>,), (<span class="number">33</span>,)]</span><br><span class="line">[(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;s&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;h&#x27;</span>), (<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;e&#x27;</span>), (<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;l&#x27;</span>), (<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;l&#x27;</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="reversed">4.5 reversed()</h2>
<p>reserved() 可以返回一个给定序列的逆序序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将列表进行逆序</span></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将元组进行逆序</span></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串进行逆序</span></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="string">&quot;abcdefg&quot;</span>)])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 range() 生成的区间列表进行逆序</span></span><br><span class="line">print([x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">reversed</span>(<span class="built_in">range</span>(<span class="number">10</span>))])</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<h2 id="sorted">4.6 sorted()</h2>
<p>sorted() 用于给序列（列表、元组、字典、集合、字符串）进行排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span> = <span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">key 参数可以自定义排序规则</span></span><br><span class="line"><span class="string">reverse 参数指定以升序（False，默认）还是降序（True）进行排序</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h1 id="python-虚拟环境">5 Python 虚拟环境</h1>
<h2 id="创建虚拟环境">5.1 创建虚拟环境</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cd D:\Demo\Python\Demo <span class="comment"># 存放虚拟环境的目录</span></span><br><span class="line">python -m venv venv <span class="comment">#创建名为 venv 的虚拟环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 激活虚拟环境</span></span><br><span class="line">.\venv\Scripts\activate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出当前虚拟环境</span></span><br><span class="line">.\venv\Scripts\deactivate.bat</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
